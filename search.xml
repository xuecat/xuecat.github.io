<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[jenkins配置(254)]]></title>
      <url>https://xuecat.github.io/2020/11/02/254/</url>
      <content type="html"><![CDATA[<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">name=ingestdbsvr</div><div class="line"><span class="keyword">version</span>=1.8.5</div><div class="line">time=$(date +%Y%<span class="keyword">m</span>%<span class="keyword">d</span>%<span class="keyword">H</span>)</div><div class="line">images=<span class="variable">$&#123;name&#125;</span>:<span class="variable">$&#123;version&#125;</span>.<span class="variable">$&#123;time&#125;</span>.<span class="variable">$&#123;BUILD_NUMBER&#125;</span></div><div class="line">tarname=<span class="variable">$&#123;images&#125;</span>.tar</div><div class="line">pushurl=172.16.128.170:5000/<span class="variable">$&#123;images&#125;</span></div><div class="line">date +%<span class="keyword">H</span>:%<span class="keyword">M</span>:%<span class="built_in">S</span></div><div class="line">dotnet build -c Release  IngestDB.sln</div><div class="line"><span class="keyword">cd</span> IngestDB </div><div class="line">dotnet publish -c Release -o ../publish</div><div class="line"><span class="keyword">cd</span> ..</div><div class="line">cp BinU/netcoreapp2.1/IngestDB.dll -r publish/</div><div class="line">cp BinU/netcoreapp2.1/IngestDBCore.dll -r publish/</div><div class="line"></div><div class="line">cp BinU/netcoreapp2.1/<span class="keyword">Plugin</span>/IngestMatrixPlugin.dll -r publish/<span class="keyword">Plugin</span>/</div><div class="line">cp BinU/netcoreapp2.1/<span class="keyword">Plugin</span>/IngestDeviceInterfacePlugin.dll -r publish/<span class="keyword">Plugin</span>/</div><div class="line">cp BinU/netcoreapp2.1/<span class="keyword">Plugin</span>/IngestGlobalInterfacePlugin.dll -r publish/<span class="keyword">Plugin</span>/</div><div class="line">cp BinU/netcoreapp2.1/<span class="keyword">Plugin</span>/IngestTaskInterfacePlugin.dll -r publish/<span class="keyword">Plugin</span>/</div><div class="line">cp BinU/netcoreapp2.1/<span class="keyword">Plugin</span>/IngestTaskPlugin.dll -r publish/<span class="keyword">Plugin</span>/</div><div class="line">cp BinU/netcoreapp2.1/<span class="keyword">Plugin</span>/IngestDevicePlugin.dll -r publish/<span class="keyword">Plugin</span>/</div><div class="line">cp BinU/netcoreapp2.1/<span class="keyword">Plugin</span>/MSVNotifyPlugin.dll -r publish/<span class="keyword">Plugin</span>/</div><div class="line">cp BinU/netcoreapp2.1/<span class="keyword">Plugin</span>/IngestGlobalPlugin.dll -r publish/<span class="keyword">Plugin</span>/</div><div class="line">cp BinU/netcoreapp2.1/<span class="keyword">Plugin</span>/KafKaNotifyPlugin.dll -r publish/<span class="keyword">Plugin</span>/</div><div class="line">cp BinU/netcoreapp2.1/<span class="keyword">Plugin</span>/UdpNotifyPlugin.dll -r publish/<span class="keyword">Plugin</span>/</div><div class="line"></div><div class="line">#docker images | grep 'ingestdbsvr' | awk '&#123;<span class="keyword">print</span> <span class="variable">$3&#125;</span>' | xargs docker rmi</div><div class="line">chmod -Rf 777 publish</div><div class="line">docker build -t <span class="variable">$images</span> .</div><div class="line">docker tag <span class="variable">$images</span> <span class="variable">$pushurl</span></div><div class="line">docker push <span class="variable">$pushurl</span></div><div class="line"></div><div class="line">time=$(date +%Y%<span class="keyword">m</span>%<span class="keyword">d</span>%<span class="keyword">H</span>)</div><div class="line">appname=ingestdbsvr</div><div class="line"><span class="keyword">version</span>=1.8.5.<span class="variable">$&#123;time&#125;</span>.<span class="variable">$&#123;BUILD_NUMBER&#125;</span></div><div class="line">images=<span class="variable">$&#123;appname&#125;</span>:<span class="variable">$&#123;version&#125;</span></div><div class="line">Oldtag=`docker images|grep <span class="variable">$&#123;appname&#125;</span>|awk '&#123;<span class="keyword">print</span> <span class="variable">$2&#125;</span>'|<span class="keyword">sort</span> -r|awk 'NR==1&#123;<span class="keyword">print</span>&#125;'`</div><div class="line">container=`docker ps -a|grep <span class="variable">$&#123;appname&#125;</span>|awk '&#123;<span class="keyword">print</span> <span class="variable">$1&#125;</span>'|<span class="keyword">sort</span> -r|awk 'NR==1&#123;<span class="keyword">print</span>&#125;'`</div><div class="line">echo  <span class="variable">$&#123;appname&#125;</span>-<span class="variable">$&#123;Oldtag&#125;</span></div><div class="line">echo <span class="variable">$&#123;appname&#125;</span>-<span class="variable">$&#123;version&#125;</span></div><div class="line">echo <span class="variable">$&#123;appname&#125;</span>:<span class="variable">$&#123;container&#125;</span></div><div class="line">docker stop <span class="variable">$&#123;container&#125;</span></div><div class="line">docker <span class="keyword">rm</span> -f <span class="variable">$&#123;container&#125;</span></div><div class="line"><span class="keyword">mkdir</span> /sobeyhive/<span class="keyword">app</span>/<span class="variable">$&#123;appname&#125;</span>-<span class="variable">$&#123;version&#125;</span></div><div class="line">cp -rp /sobeyhive/<span class="keyword">app</span>/<span class="variable">$&#123;appname&#125;</span>-notchange/<span class="keyword">run</span>.<span class="keyword">sh</span> /sobeyhive/<span class="keyword">app</span>/<span class="variable">$&#123;appname&#125;</span>-<span class="variable">$&#123;version&#125;</span>/</div><div class="line"><span class="keyword">rm</span> -fr  /sobeyhive/<span class="keyword">app</span>/<span class="variable">$&#123;appname&#125;</span>-<span class="variable">$&#123;Oldtag&#125;</span> </div><div class="line"><span class="keyword">cd</span> /RunScript/ </div><div class="line"><span class="keyword">sh</span> ingestdbsvrsrg.<span class="keyword">sh</span>  <span class="variable">$&#123;version&#125;</span></div><div class="line"><span class="keyword">sleep</span> 5</div><div class="line"></div><div class="line">scp -r  /other/sobeyhive/<span class="keyword">app</span>/ingestmsgsvr-1.6.0/ingestmsgsvr<span class="comment">/* root@172.16.128.117:/other/jenkins/workspace/IngestMsgSvr-Integration-SRG1.8.5/publish/   </span></div><div class="line"> </div><div class="line">sleep 1</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c#语法糖253]]></title>
      <url>https://xuecat.github.io/2020/10/22/253/</url>
      <content type="html"><![CDATA[<p><a href="https://help.semmle.com/wiki/display/CSHARP/Abstract+class+only+declares+common+constants" target="_blank" rel="external">原文章地址</a></p>
<p><img src="/picture/253_11.jpg" alt=""></p>
<ol>
<li>abstract类最好用来声明公共<code>const</code>变量</li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Bad</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">MathConstants</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">double</span> Pi = <span class="number">3.14</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">MathConstants</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">double</span> radius;</div><div class="line"> </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Area</span>(<span class="params"></span>) </span>=&gt; Math.Pow(radius, <span class="number">2</span>) * Pi;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>ReadOnlyCollection</code>替换<code>Array</code>的<code>readonly</code></li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//错误</span></div><div class="line"><span class="keyword">class</span> <span class="title">Bad</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">string</span>[] Foo = &#123; <span class="string">"hello"</span>, <span class="string">"world"</span> &#125;;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></div><div class="line">    &#123;</div><div class="line">        Foo[<span class="number">0</span>] = <span class="string">"goodbye"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//对的</span></div><div class="line"><span class="keyword">class</span> <span class="title">Good</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> ReadOnlyCollection&lt;<span class="keyword">string</span>&gt; Foo</div><div class="line">        = <span class="keyword">new</span> ReadOnlyCollection&lt;<span class="keyword">string</span>&gt;(<span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"hello"</span>, <span class="string">"world"</span> &#125;);</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></div><div class="line">    &#123;</div><div class="line"> </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>Assembly</code>的代码</li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AssemblyPathInjectionHandler</span> : <span class="title">IHttpHandler</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessRequest</span>(<span class="params">HttpContext ctx</span>) </span>&#123;</div><div class="line">    <span class="keyword">string</span> configType = ctx.Request.QueryString[<span class="string">"configType"</span>];</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (configType.equals(<span class="string">"configType1"</span>) || configType.equals(<span class="string">"configType2"</span>)) &#123;</div><div class="line">      <span class="comment">// GOOD: Loaded assembly is one of the two known safe options</span></div><div class="line">      <span class="keyword">var</span> safeAssembly = Assembly.LoadFile(<span class="string">@"C:\SafeLibraries\"</span> + configType + <span class="string">".dll"</span>);</div><div class="line"> </div><div class="line">      <span class="comment">// Code execution is limited to one of two known and vetted assemblies</span></div><div class="line">      MethodInfo m = safeAssembly.GetType(<span class="string">"Config"</span>).GetMethod(<span class="string">"GetCustomPath"</span>);</div><div class="line">      Object customPath = m.Invoke(<span class="literal">null</span>, <span class="literal">null</span>);</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>Cyclomatic Complexity(圈复杂度)</p>
</li>
<li><p><code>dynamic</code> 弱语言的东西类似js的结构体，和模板搭配很好用</p>
</li>
<li><p><code>Obsolete</code></p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="name">Obsolete</span>(<span class="string">"该方法已被弃用，请使用NewMethod代替"</span>)]</div><div class="line">static void OldMethod()</div></pre></td></tr></table></figure>
</li>
<li><p><code>abstract</code>属性可以通过继承覆盖<br>···<br>public abstract class Shape<br>{<br> private string name;</p>
<p> public Shape(string s)<br> {</p>
<pre><code>// calling the set accessor of the Id property.
Id = s;
</code></pre><p> }<br> public string Id<br> {</p>
<pre><code>get
{
    return name;
}

set
{
    name = value;
}
</code></pre><p> }</p>
<p> // Area is a read-only property - only a get accessor is needed:<br> public abstract double Area<br> {</p>
<pre><code>get;
</code></pre><p> }</p>
<p> public override string ToString()<br> {</p>
<pre><code>return $&quot;{Id} Area = {Area:F2}&quot;;
</code></pre><p> }<br>}<br>public class Square : Shape<br>{<br> private int side;</p>
<p> public Square(int side, string id)</p>
<pre><code>: base(id)
</code></pre><p> {</p>
<pre><code>this.side = side;
</code></pre><p> }</p>
<p> public override double Area<br> {</p>
<pre><code>get
{
    // Given the side, return the area of a square:
    return side * side;
}
</code></pre><p> }<br>}</p>
</li>
</ol>
<p>···</p>
<ol>
<li><p><code>is</code>的规则</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> <span class="title">Animal</span> &#123; &#125;</div><div class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span> &#123; &#125;</div><div class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; &#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></div><div class="line">&#123;</div><div class="line">    List&lt;Animal&gt; animals = <span class="keyword">new</span> List&lt;Animal&gt; &#123; <span class="keyword">new</span> Cat(), <span class="keyword">new</span> Dog() &#125;;</div><div class="line">    <span class="keyword">foreach</span> (Animal a <span class="keyword">in</span> animals)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (a <span class="keyword">is</span> Cat)</div><div class="line">            Console.WriteLine(<span class="string">"Miaow!"</span>);</div><div class="line">        <span class="keyword">if</span> (a <span class="keyword">is</span> Dog)</div><div class="line">            Console.WriteLine(<span class="string">"Woof!"</span>);</div><div class="line">        <span class="keyword">if</span> (a <span class="keyword">is</span> Animal)</div><div class="line">            Console.WriteLine(<span class="string">"Animal!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Console.ReadLine();</div><div class="line">    Console.ReadKey();</div><div class="line">&#125;<span class="comment">// Miaow Animal Woof Animal</span></div></pre></td></tr></table></figure>
</li>
<li><p>引用用类型,值类型比较</p>
</li>
</ol>
<p>引用类型:<br><code>ReferenceEquals(null, x)</code>比较是否是指向同一内存<br>虚函数<code>Equals</code></p>
<p>值类型:<br><code>==</code>运算符比较</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[EF Core Linq(252)]]></title>
      <url>https://xuecat.github.io/2020/03/29/252/</url>
      <content type="html"><![CDATA[<p>EF默认情况下对数据的访问都是启用模型跟踪</p>
<p>使用AsNoTracking方法查询返回无变动跟踪的Province的DbSet，由于是无变动跟踪，所以对返回的Province集中数据的任何修改，在SaveChanges()时，都不会提交到数据库中</p>
<ul>
<li>无跟踪查询而已，也就是说查询出来的对象不能直接做修改。所以，我们在做数据集合查询显示，而又不需要对集合修改并更新到数据库的时候，一定不要忘记加上AsNoTracking。</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">using (<span class="built_in">var</span> context = <span class="literal">new</span> MyDbContext())</div><div class="line">&#123;</div><div class="line">   <span class="built_in">var</span> <span class="built_in">data</span> = context.Orders</div><div class="line">      .Include(c =&gt; c.OrderLines)</div><div class="line">      .<span class="keyword">Select</span>(c =&gt; <span class="literal">new</span> &#123; OrderObj = c, Lines = c.OrderLines&#125;)</div><div class="line">      .AsNoTracking()<span class="comment">//除非去掉这句不然不会更新</span></div><div class="line">      .FirstOrDefault();</div><div class="line"> </div><div class="line">   <span class="built_in">data</span>.OrderObj.Number = <span class="string">"#ABC123"</span>;</div><div class="line"> </div><div class="line">   context.SaveChanges();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果查询过程做了select映射就不需要加AsNoTracking。如：db.Students.Where(t=&gt;t.Name.Contains(“张三”)).select(t=&gt;new (t.Name,t.Age)).ToList();</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//导出部分属性列，提高效率</span></div><div class="line">.AsNoTracking()</div><div class="line">   .Select(item =&gt;</div><div class="line">   <span class="keyword">new</span> ProductViewModel</div><div class="line">   &#123;</div><div class="line">       Product = item,</div><div class="line"></div><div class="line">       NoOfProducts = item.Comments.Count</div><div class="line"></div><div class="line">  &#125;).ToListAsync());</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//同理</span></div><div class="line">  <span class="keyword">var</span> <span class="keyword">list</span> = context.Bloggers</div><div class="line">    .<span class="keyword">Include</span>(x =&gt; x.Posts)</div><div class="line">    .ToList();</div></pre></td></tr></table></figure>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//更新单列</span></div><div class="line"><span class="comment">//这个方法需要注意一点，就是禁止多个跟踪。假如前面用track方式`where`选出了一些对象，由于这些对象被跟踪了，再用这个方法`attach`添加跟踪就会异常。除非用同一个对象更新</span></div><div class="line">using (<span class="type">TestDBContext</span> testDBContext = <span class="function"><span class="keyword">new</span> <span class="title">TestDBContext</span>())</span></div><div class="line">&#123;</div><div class="line">    <span class="title">Person</span> <span class="title">person</span> = <span class="title">new</span> <span class="title">Person</span>() &#123; <span class="title">Code</span> = "<span class="title">A</span>" ,<span class="title">Name</span>="<span class="title">Tom</span>"&#125;;<span class="comment">//列Code是Key，声明Key属性列Code的值，及要修改的列Name的值</span></div><div class="line"></div><div class="line">    <span class="title">testDBContext</span>.<span class="title">Attach</span>(person);<span class="comment">//告诉EF Core开始跟踪person实体的更改，因为调用DbContext.Attach方法后，EF Core会将person实体的State值（可以通过testDBContext.Entry(person).State查看到）更改回EntityState.Unchanged，所以这里testDBContext.Attach(person)一定要放在下面一行testDBContext.Entry(person).</span></div><div class="line">    </div><div class="line">    <span class="title">Property</span>(p =&gt; p.<span class="type">Name</span>).<span class="title">IsModified</span> = <span class="title">true</span>的前面，否者后面的<span class="title">testDBContext</span>.<span class="title">SaveChanges</span>方法调用后，数据库不会被更新</div><div class="line">    <span class="title">testDBContext</span>.<span class="title">Entry</span>(person).<span class="title">Property</span>(p =&gt; p.<span class="type">Name</span>).<span class="title">IsModified</span> = <span class="title">true</span>;<span class="comment">//告诉EF Core实体person的Name属性已经更改。将testDBContext.Entry(person).Property(p =&gt; p.Name).IsModified设置为true后，也会将person实体的State值（可以通过testDBContext.Entry(person).State查看到）更改为EntityState.Modified，这样就保证了下面SaveChanges的时候会将person实体的Name属性值Update到数据库中。</span></div><div class="line">    <span class="title">testDBContext</span>.<span class="title">SaveChanges</span>();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="title">context</span>.<span class="title">Attach</span>(person);</div><div class="line"><span class="title">context</span>.<span class="title">Entry</span>(person).<span class="title">Property</span>("<span class="type">Name</span>").<span class="title">IsModified</span> = <span class="title">true</span>;</div><div class="line"><span class="title">context</span>.<span class="title">SaveChanges</span>();</div><div class="line"></div><div class="line"><span class="comment">//更新还有个mysql坑，那就是int主键默认是0。因为主键ID默认是不赋值的，只给其他项目赋值了 id是int类型，int类型如果不允许为空那么会被默认为0，所以插入第二条数据时，数据库中已经有了主键为0的数据</span></div><div class="line"></div><div class="line"><span class="comment">//modelBuilder.Entity&lt;Person&gt;(entity =&gt;</span></div><div class="line"><span class="comment">//&#123;</span></div><div class="line"><span class="comment">//    entity.Property(e =&gt; e.Id).ValueGeneratedOnAdd();//这句会用到的</span></div><div class="line"><span class="comment">//    entity.HasKey(e =&gt; e.Code);//声明列Code是实体的Key属性</span></div><div class="line"><span class="comment">//&#125;);</span></div></pre></td></tr></table></figure>
<h3 id="自定义标量函数"><a href="#自定义标量函数" class="headerlink" title="自定义标量函数"></a>自定义标量函数</h3><p> Entity Framework Core 有一个重要特性就是自定义标量函数。<br> 自定义标量函数可以将数据库中的标量函数映射到类中的方法，并且在使用 LINQ 查询时会用到</p>
<p> 我看例子他们还可以映射数据的函数<code>Average</code> <code>Max</code> <code>Min</code>等<br> ···</p>
<p> [DbFunction(FUNCTIONnAME=”sdf”,Schema=”dd”)]<br> public static string my()<br> {}</p>
<p> //调用<br> public int GetNextValId(string value)<br> {<br>   return Context.DbpTask.Select(x =&gt; IngestTaskDBContext.next_val(value)).FirstOrDefault();<br> }<br> ···</p>
<h3 id="显式编译查询"><a href="#显式编译查询" class="headerlink" title="显式编译查询"></a>显式编译查询</h3><p>一般的<code>NoTracking()</code>查询，此时要经过编译翻译阶段最终返回实际结果，比如在Web网站上这样的请求很频繁，此时将严重影响响应速度导致页面加载数据过慢。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;Blog&gt; GetBlogAsync(EFCoreDbContext context, <span class="built_in">int</span> id)</div><div class="line">&#123;</div><div class="line">   Func&lt;EFCoreDbContext, <span class="built_in">int</span>, Task&lt;Blog&gt;&gt; blog = EF.CompileAsyncQuery((EFCoreDbContext context, <span class="built_in">int</span> Id) =&gt;</div><div class="line">         context.Blogs.Include(c =&gt; c.Posts)</div><div class="line">                  .Where(c =&gt; c.Id == Id)</div><div class="line">                  .FirstOrDefault());</div><div class="line">   <span class="keyword">return</span> <span class="keyword">await</span> blog(context, id);</div><div class="line">&#125;</div><div class="line"><span class="comment">//提前把查询编译好，再直接返回查询结果的方式</span></div></pre></td></tr></table></figure>
<h3 id="延时加载技术"><a href="#延时加载技术" class="headerlink" title="延时加载技术"></a>延时加载技术</h3><p>用的时候才会加载</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Orleans新记录(251)]]></title>
      <url>https://xuecat.github.io/2020/02/02/251/</url>
      <content type="html"><![CDATA[<p><strong><em>Grain Identity</em></strong></p>
<ul>
<li>获取key有多样的（继承多样：<code>IGrainWithIntegerKey</code>）</li>
</ul>
<p><strong><em>Timers and Reminders</em></strong></p>
<ul>
<li><p><strong><em>Observers</em></strong></p>
</li>
<li>服务端<code>ObserverSubscriptionManager&lt;&gt;</code> <code>IGrainObserver</code>保持订阅列表，调相应接口来进行通知对应订阅</li>
<li>客户端<code>CreateObjectReference</code> <code>Subscribe</code>向服务器订阅</li>
</ul>
<p><strong><em>Reentrancy</em></strong></p>
<ul>
<li>grain类用<code>[Reentrant]</code>能完全异步，外部调它的方法顺序全是乱的。</li>
<li><code>[AlwaysInterleave]</code>单个方法异步</li>
<li>如果没有异步要注意方法里面出现<code>GetGrain</code>导致的<code>grain</code>之间互相调用会死锁</li>
<li>服务端可以写个属性来进行动态异步交错(感觉没啥用呢)</li>
</ul>
<p><strong><em>RequestContext</em></strong></p>
<ul>
<li>客户端<code>RequestContext.Set</code>，服务端<code>RequestContext.Get</code>它将与Orleans请求一起流向接收谷物;<br>应用程序元数据不会随响应一起流回<br>应用场景：请求从客户端到服务器跟踪流程用</li>
</ul>
<p><strong><em>JournaledGrain</em></strong><br>这个很有用，<code>event</code>和<code>state</code>绑定，通过事件更新状态，注意读写状态</p>
<p><strong><em>外部的任务和grain</em></strong><br>1） await，Task.Factory.StartNew，Task.ContinuewWith，Task.WhenAny，Task.WhenAll，Task.Delay都遵循当前的任务计划。这意味着以默认方式使用它们，无需传递不同的TaskScheduler，它们会在grain上下文中执行。</p>
<p>2）Task.Factory.FromAsync的Task.Run和endMethod委托，都不遵循当前的任务调度程序。它们都使用TaskScheduler.Default调度程序，即.NET线程池任务调度程序。</p>
<p><strong><em>拦截器</em></strong><br>1) 客户端调用<code>grain</code>用呼出，可以向<code>RequestContext</code>添加认证的东西<br>2} 服务端<code>grain</code>配置呼入,检查每个调用请求</p>
<p><strong><em>GrainServices</em></strong><br>GrainService是一种特殊的grain；它没有身份标识，并且在每个silo中运行，从silo的启动到关闭。</p>
<ul>
<li>如果可能，使GrainService可重入，以获得更好的性能</li>
<li>GrainService无法写入Orleans流，因为它不能在grain任务调度程序中工作</li>
</ul>
<p>有点像数据服务的代理，其他grain注入这个来访问数据啥的</p>
<p><strong><em>无状态grain</em></strong></p>
<ul>
<li>对无状态工作器grain的请求总是在本地执行，身份标识是 0或Guid.Empty</li>
</ul>
<p><strong><em>事务</em></strong><br>需要配合存储使用</p>
<p><strong><em>启动任务</em></strong><br>在许多情况下，一旦silo可用，就需要自动执行某些任务。启动任务提供此功能。</p>
<p>一些用例包括但不限于：</p>
<ul>
<li>启动后台计时器，以执行周期性的”家务”式的任务</li>
<li>使用从外部的后备存储下载的数据，预加载一些缓存的grain</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[for(;;)和while(true)(250)]]></title>
      <url>https://xuecat.github.io/2019/12/11/250/</url>
      <content type="html"><![CDATA[<p>比较结果<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">while(1)</div><div class="line"></div><div class="line">mov eax,1</div><div class="line"><span class="keyword">test </span>eax,eax</div><div class="line">je foo<span class="string">+23</span>h</div><div class="line">jmp foo<span class="string">+18</span>h</div><div class="line"></div><div class="line"></div><div class="line">for(;;)</div><div class="line"></div><div class="line">jmp foo<span class="string">+23</span>h</div></pre></td></tr></table></figure></p>
<p>总结:for (;;):1.指令少2.不占用寄存器3.没有判断跳转,并不是不能跳出</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[服务器记录(249)]]></title>
      <url>https://xuecat.github.io/2019/10/28/249/</url>
      <content type="html"><![CDATA[<p>  最近优化了些服务器做下记录</p>
<ol>
<li>httpclient的使用<blockquote>
<p>httpclient不能立即关闭，会占用资源，并发量一大就耗尽。所以.net core 会使用如下:</p>
</blockquote>
</li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GitHubClient</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> HttpClient Client &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GitHubClient</span>(<span class="params">HttpClient httpClient</span>)</span></div><div class="line">    &#123;</div><div class="line">        httpClient.BaseAddress = <span class="keyword">new</span> Uri(<span class="string">"https://api.github.com/"</span>);</div><div class="line">        httpClient.DefaultRequestHeaders.Add(<span class="string">"Accept"</span>, <span class="string">"application/vnd.github.v3+json"</span>);</div><div class="line">        httpClient.DefaultRequestHeaders.Add(<span class="string">"User-Agent"</span>, <span class="string">"HttpClientFactory-Sample"</span>);</div><div class="line">        Client = httpClient;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">GetData</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">await</span> _client.GetStringAsync(<span class="string">"/"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">services.AddHttpClient&lt;GitHubClient&gt;();</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValuesController</span> : <span class="title">BaseController</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> GitHubClient _gitHubClient;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValuesController</span>(<span class="params">GitHubClient gitHubClient</span>)</span></div><div class="line">    &#123;</div><div class="line">        _gitHubClient = gitHubClient;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [HttpGet]</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&gt; <span class="title">Get</span>(<span class="params"></span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">string</span> result = <span class="keyword">await</span> _gitHubClient.GetData();</div><div class="line">        <span class="keyword">return</span> Ok(result);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我的做法是使用全局static来控制。</p>
<ol>
<li><p>在异步方法中，不要使用 Thread.Sleep；在同步方法中，不要使用Task.Delay ，否则可能出现线程死锁，结果难出来。</p>
</li>
<li><p>吞吐量（TPS）、QPS（每秒查询率）、并发数、响应时间（RT）<br>当时为了增加qps，把所有webapi接口都改成异步请求</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[单元测试白盒(248)]]></title>
      <url>https://xuecat.github.io/2019/05/19/248/</url>
      <content type="html"><![CDATA[<p><em>昨天下雨了!好像！</em><br><blockquote><p>外面风雨琳琅，漫山遍野都是今天。</p>
</blockquote></p>
<h2 id="测试项目"><a href="#测试项目" class="headerlink" title="测试项目"></a>测试项目</h2><p>  vs支持的白盒测试项目的编写。一般用来测试接口的</p>
<ul>
<li>测试项目引用必须引用到实体项目</li>
<li>测试项目链接必须连接到实体项目中间文件: ../test/Debug/test.obj.</li>
<li>包含头文件 <code>#include &quot;../test/test.h&quot;</code></li>
</ul>
<hr>
<p>  c#的要简单点，直接引用项目，然后调用就可以了。<br>  唯一的问题在于dot net core的测试项目的创建。mstest,nunit,xunit这三个项目，好像社区用xunit来创建多些，还能跨平台。</p>
<hr>
<p>  <code>Assert.Equal</code>几乎都是用这个。</p>
<p><strong>然后看同步的测试项目：</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[资源问题(247)]]></title>
      <url>https://xuecat.github.io/2018/11/26/247/</url>
      <content type="html"><![CDATA[<p> 今天说给收录写个新功能来着，搞半天老是资源错误，”试图执行的操作不受支持”。气死人了。<br> 最后想起在DoDataExchange下个断点，一个一个的找资源控件问题，</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[高性能mysql(246)]]></title>
      <url>https://xuecat.github.io/2018/10/22/246/</url>
      <content type="html"><![CDATA[<p><strong>schema</strong></p>
<ul>
<li><p>尽量避免<code>NULL</code>, 可为<code>NULL</code>的列使得索引 索引统计和值比较都更为复杂，可为<code>NULL</code>的列会使用更多空间</p>
</li>
<li><p>整数类型, INT(11),并不会限制值的合法范围,只是规定MYSQL显示字符的个数;<code>DECIMAL</code>是浮点型</p>
</li>
<li><p>字符类型,<code>VARCHAR</code>存储变长字符串,比定长<code>CHAR</code>(md5等这种来存储)更省空间.会额外多1到2个字节来存储长度</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mysql(245)]]></title>
      <url>https://xuecat.github.io/2018/09/23/245/</url>
      <content type="html"><![CDATA[<ul>
<li><p>约束</p>
<ul>
<li>非空约束(not null)</li>
<li>唯一性约束(unique)</li>
<li>主键约束(primary key) PK</li>
<li>外键约束(foreign key) FK</li>
<li>检查约束(目前MySQL不支持、Oracle支持)</li>
</ul>
</li>
<li><p>非空约束</p>
<ul>
<li><code>name varchar(32) not null</code></li>
</ul>
</li>
<li><p>唯一约束 (表之间插入相同值会报错)</p>
<ul>
<li><code>email varchar(128) unique</code></li>
<li><code>email varchar(128), unique(name,email)</code></li>
<li><code>constraint t_user_email_unique unique(email)</code>给约束表起名,方便以后删除</li>
</ul>
</li>
<li><p>主键约束</p>
<ul>
<li><code>id int(10) primary key</code> 单一列级</li>
<li><code>constraint t_user_id_pk primary key(id)</code> 单一表级</li>
<li><code>primary key(id,name)</code> 符合表级</li>
<li>主键自增 <figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">reate table <span class="title">t_user</span>(<span class="params"></span></span></div><div class="line"> id <span class="keyword">int</span>(<span class="number">10</span>) primary key auto_increment,</div><div class="line"> name <span class="title">varchar</span>(<span class="params"><span class="number">32</span></span>) not <span class="literal">null</span></div><div class="line"> );</div><div class="line"></div><div class="line"><span class="function">insert <span class="keyword">into</span> <span class="title">t_user</span>(<span class="params">name</span>) <span class="title">values</span>(<span class="params"><span class="string">'jay'</span></span>)</span>;</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_user</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>外键约束</p>
</li>
</ul>
<ul>
<li><code>FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)</code></li>
</ul>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p><code>字段建立索引可以大大提升查询速度</code></p>
<ul>
<li><p>普通索引</p>
<ul>
<li><code>CREATE INDEX indexName ON mytable(username(length))</code></li>
<li><code>CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) )</code></li>
</ul>
</li>
<li><p>唯一索引<br>  它必须唯一,但允许有空值</p>
<ul>
<li><code>CREATE UNIQUE INDEX indexName ON mytable(username(length))</code></li>
<li><code>CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) )</code></li>
</ul>
</li>
<li><p>主键索引<br>  唯一且不允许空</p>
<ul>
<li><code>CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, PRIMARY KEY(ID) );</code></li>
</ul>
</li>
<li><p>组合索引</p>
<ul>
<li><code>ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);</code></li>
</ul>
</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>varchar最好在1024以内,虽然它能支持到6553;其它用blob和text来代替</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Xsum问题(243)]]></title>
      <url>https://xuecat.github.io/2018/09/04/243/</url>
      <content type="html"><![CDATA[<h3 id="xsum问题"><a href="#xsum问题" class="headerlink" title="xsum问题"></a>xsum问题</h3><ul>
<li><p>2sum</p>
<ul>
<li><p>map结构时间复杂度O(n)<br>map把那些离target有差距的都存起来，等target-nums[i]有对应值时，就表示达到了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">    <span class="keyword">int</span> len = nums.size();</div><div class="line">    <span class="keyword">if</span> ( len &lt; <span class="number">2</span>) </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line"></div><div class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len ; i++)&#123;</div><div class="line">        <span class="keyword">if</span> (mp[target - nums[i]] != <span class="number">0</span>)&#123;</div><div class="line">            res.push_back(mp[target - nums[i]] - <span class="number">1</span>);<span class="comment">//减去加的那个1</span></div><div class="line">            res.push_back(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            mp[nums[i]] = i + <span class="number">1</span>;<span class="comment">//故意加了1是为了防止为0,这样好判断这个键-值是否存在</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//sort(res.begin(), res.end());</span></div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>先对数据进行排序，如果用STL的sort快排，时间复杂度为O(nlogn)，然后设置两个指针，一个初始化为数组的头，一个初始化在数组的尾，然后两边向中间扫描，如果当前两个指针指向的数的和正好是target，那么就保存当前数对 (防止重复就跳过相同值)<br>这个方法找多个就很麻烦了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line">    <span class="keyword">int</span> len = nums.size();</div><div class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numsTmp = nums;</div><div class="line">    sort(nums.begin(), nums.end()); <span class="comment">//使得有序</span></div><div class="line"></div><div class="line">    <span class="comment">//收尾指针法</span></div><div class="line">    <span class="keyword">int</span> sta = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> end = len - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (sta &lt; end)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (nums[sta] + nums[end] == target)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">bool</span> f1 = <span class="literal">false</span>;</div><div class="line">            <span class="keyword">bool</span> f2 = <span class="literal">false</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)<span class="comment">//排序队列找到了，还要去原来队列找到对应的值序列号</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (f1 &amp;&amp; f2)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">if</span> (!f1 &amp;&amp; numsTmp[i] == nums[sta]) <span class="comment">// nums[sta] 可能等于 nums[end]</span></div><div class="line">                &#123;</div><div class="line">                    res.push_back(i);</div><div class="line">                    f1 = <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!f2 &amp;&amp; numsTmp[i] == nums[end]) <span class="comment">// 这里是else if 不是if</span></div><div class="line">                &#123;</div><div class="line">                    res.push_back(i);</div><div class="line">                    f2 = <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[sta] + nums[end] &lt; target)<span class="comment">//单方面递增或递减</span></div><div class="line">        &#123;</div><div class="line">            sta++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            end--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>3sum</p>
<ul>
<li>依次对数组中得每一个元素num[i]找和为target-num[i]的连个数，这样问题又回到了2Sum上</li>
</ul>
</li>
<li><p>4sum</p>
<ul>
<li><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;int&gt; &gt; fourSum(<span class="built_in">vector</span>&lt;int&gt; &amp;<span class="built_in">num</span>, int target) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;int&gt; &gt; ret;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">num</span>.size() == <span class="number">0</span>) <span class="built_in">return</span> ret;</div><div class="line"></div><div class="line">    <span class="built_in">sort</span>(<span class="built_in">num</span>.begin(), <span class="built_in">num</span>.end());</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (size_t a = <span class="number">0</span>; a &lt; <span class="built_in">num</span>.size(); ++a)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (a != <span class="number">0</span> &amp;&amp; <span class="built_in">num</span>[a] == <span class="built_in">num</span>[a-<span class="number">1</span>])</div><div class="line">            continue;</div><div class="line">    </div><div class="line">        <span class="keyword">for</span> (size_t b = a + <span class="number">1</span>; b &lt; <span class="built_in">num</span>.size(); ++b)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (b != a + <span class="number">1</span> &amp;&amp; <span class="built_in">num</span>[b] == <span class="built_in">num</span>[b-<span class="number">1</span>])</div><div class="line">                continue;</div><div class="line">        </div><div class="line">            size_t c = b + <span class="number">1</span>;</div><div class="line">            size_t d = <span class="built_in">num</span>.size() - <span class="number">1</span>;</div><div class="line">        </div><div class="line">            <span class="keyword">while</span> (c &lt; d)</div><div class="line">            &#123;</div><div class="line">                const int <span class="built_in">sum</span> = <span class="built_in">num</span>[a] + <span class="built_in">num</span>[b] + <span class="built_in">num</span>[c] + <span class="built_in">num</span>[d];</div><div class="line">            </div><div class="line">                <span class="keyword">if</span> (<span class="built_in">sum</span> &gt; target)</div><div class="line">                    --d;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sum</span> &lt; target)</div><div class="line">                    ++c;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (c != b + <span class="number">1</span> &amp;&amp; <span class="built_in">num</span>[c] == <span class="built_in">num</span>[c-<span class="number">1</span>])</div><div class="line">                    ++c;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (d != <span class="built_in">num</span>.size() - <span class="number">1</span> &amp;&amp; <span class="built_in">num</span>[d] == <span class="built_in">num</span>[d+<span class="number">1</span>])</div><div class="line">                    --d;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    <span class="built_in">vector</span>&lt;int&gt; result;</div><div class="line">                </div><div class="line">                    result.push_back(<span class="built_in">num</span>[a]);</div><div class="line">                    result.push_back(<span class="built_in">num</span>[b]);</div><div class="line">                    result.push_back(<span class="built_in">num</span>[c]);</div><div class="line">                    result.push_back(<span class="built_in">num</span>[d]);</div><div class="line">                </div><div class="line">                    ret.push_back(result);</div><div class="line">                </div><div class="line">                    ++c;</div><div class="line">                    --d;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[permutation(242)]]></title>
      <url>https://xuecat.github.io/2018/08/19/242/</url>
      <content type="html"><![CDATA[<p>排列算法<code>stl</code>里面的<code>next_permutation</code>和<code>prev_permutation</code></p>
<h4 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a><code>next_permutation</code></h4><ol>
<li>从尾部开始往前寻找两个相邻的元素,第1个元素i，第2个元素j（从前往后数的），且i&lt;j</li>
<li>在[j,end)中寻找一个最小的k使其满足A[i]&lt;A[k],将i与k交换</li>
<li>[j,last)范围的元素置逆（颠倒排列）</li>
</ol>
<blockquote>
<p>1,3,2-&gt; 2,1,3过程<br>i是1，j是3. k是3；互换后是3,1,2; 由于j是3，逆序就是2,1,3了</p>
</blockquote>
<h4 id="prev-permutation"><a href="#prev-permutation" class="headerlink" title="prev_permutation"></a><code>prev_permutation</code></h4><ol>
<li>从尾部开始往前寻找两个相邻的元素,第1个元素i，第2个元素j（从前往后数的），且i&gt;j</li>
<li>从最尾端开始往前寻找第一个小于i的元素，令它为k, 讲i和k对调</li>
<li>j之后颠倒</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c++的currying(241)]]></title>
      <url>https://xuecat.github.io/2018/08/09/241/</url>
      <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">partial</span><span class="params">(F f, Args... args)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> [=](<span class="keyword">auto</span>... rest) -&gt; <span class="keyword">auto</span> &#123;<span class="comment">//草这就是c++的lamda，和js c#的完全不同啊，我这个笨蛋第一时间居然没反应过来</span></div><div class="line">        <span class="keyword">return</span> f(args..., rest...);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> &amp; b, <span class="keyword">int</span> c, <span class="keyword">int</span> &amp; d)</span> </span>&#123;</div><div class="line">    b = b + <span class="number">1</span>;</div><div class="line">    d = d + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">11</span>, b = <span class="number">111</span>, c = <span class="number">1111</span>, d = <span class="number">11111</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a: "</span> &lt;&lt; a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; b &lt;&lt; <span class="string">" c: "</span> &lt;&lt; c &lt;&lt; <span class="string">" d: "</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    partial(demo, a, <span class="built_in">std</span>::ref(b))(c, <span class="built_in">std</span>::ref(d));</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a: "</span> &lt;&lt; a &lt;&lt; <span class="string">" b: "</span> &lt;&lt; b &lt;&lt; <span class="string">" c: "</span> &lt;&lt; c &lt;&lt; <span class="string">" d: "</span> &lt;&lt; d &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[stl排序(240)]]></title>
      <url>https://xuecat.github.io/2018/07/28/240/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center">以前有笔记，但忘了放哪了，再做一次吧</blockquote>

<p><img src="/picture/240.jpg" alt=""></p>
<ul>
<li>stable_sort</li>
<li>partial_sort</li>
<li>nth_element</li>
<li>partition和stable_partition</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> w&amp; l, <span class="keyword">const</span> w&amp; r)</span> </span>&#123;...&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ifunc</span><span class="params">(<span class="keyword">const</span> w&amp; c)</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure>
<h4 id="partial-sort"><a href="#partial-sort" class="headerlink" title="partial_sort"></a>partial_sort</h4><pre><code>只排一部分：`partial_sort(w.begin(),w.beging()+20,w.end(),func)`只对前20个元素排
</code></pre><h4 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h4><pre><code>只分界:`nth_element(w.begin(),w.beging()+20,w.end(),func)`
将最后的20个元素放前面，但它不会像前面那个函数，这个函数不会排序，只是单纯放前面
</code></pre><h4 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h4><pre><code>前面俩个只会比较元素，当判断元素属性时呢
`partition(w.begin(), w.end(), ifunc)`功能类似`partial_sort`但比较函数不同
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mysql检索(239)]]></title>
      <url>https://xuecat.github.io/2018/07/13/239/</url>
      <content type="html"><![CDATA[<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Å, å，这是丹麦的</div><div class="line">Ä ä，这是德语的</div><div class="line">A <span class="selector-tag">a</span> 这是英文得</div></pre></td></tr></table></figure>
<p>mysql里校对包含字符时有这些<code>like</code> <code>instr</code> <code>locate</code>,<br>但它们时建立在一个校对规则之上的,<br><code>_unicode_ci</code>不区分大小写<br><code>_general_ci</code>不区分大小写<br><code>*_cs</code>区分大小写<br><code>*_bin</code>用二进制存储</p>
<p>utf8_general_ci 校对速度快，但准确度稍差<br>utf8_unicode_ci 准确度高，但校对速度稍慢(所以最近那个sql问题我该改成这个)</p>
<p>utf8mb4字符集可以保存表情符号.</p>
<p>最后直接限定字符检索才成功，不明白为何改<code>_bin</code>也不成功。唉！<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbp_log_object <span class="keyword">as</span> a <span class="keyword">WHERE</span> <span class="keyword">locate</span>(<span class="string">'Ä'</span> <span class="keyword">collate</span> utf8_bin, a.objectname)&gt;<span class="number">0</span></div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[orleans(238)]]></title>
      <url>https://xuecat.github.io/2018/07/06/238/</url>
      <content type="html"><![CDATA[<p>这个亚马逊云素材同步代码是我至今最大坡度的代码<br>第一次有种想早点下班好回去恶补知识的感觉,可惜又不得不加班完成任务。</p>
<ol>
<li>silo 代表一个服务，可以是主节点也可以是副节点</li>
<li><p>grain 可以看作是一个单例进程，队列只有一个，会排队修改数据。相同类型的只要key不同，它们就互相独立</p>
</li>
<li><p>客户端一开始就会连接一个服务即silo.(GrainClient.Initialize)</p>
</li>
<li><p>StreamProvider订阅，无论是隐式还是显式，都要用this.stream.OnNextAsync(data)去分发<br>显式还是隐式都是一个grain，初始化注册订阅后才能使用</p>
</li>
</ol>
<ol>
<li><p>Orleans.Immutable 这个是由于和grain的方法调用传参是一次深拷贝<br>grain之间通信，silo之间通信也是深拷贝。<br>为了避免，所以用这个来控制，避免深拷贝。</p>
</li>
<li><p>Orleans永远不会在执行Task的中途创造另一个Task,所以要求程序代码在执行Task的中途,不要开辟多线程.不然会报错或者会破坏单线程机制.如果真的有需要创造额外的task.</p>
</li>
<li><p><code>StatelessWorker</code>的<code>grain</code>，状态无关类型；可以在集群的多个silo里,每一个silo都创造一个相同标识的Grain。 针对此类grain的请求,都只在第一个接受到请求的silo里执行。 Orleans会在所有此类grain忙的时候,自动增加一个</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[せいかつの日記(237)]]></title>
      <url>https://xuecat.github.io/2018/07/04/237/</url>
      <content type="html"><![CDATA[<p><img src="/picture/237.png" alt=""></p>
<hr>
<pre><code>見ないでくたさい、ただ馬鹿な話しです
</code></pre><hr>
<h2 id="2018-7-3"><a href="#2018-7-3" class="headerlink" title="2018/7/3"></a>2018/7/3</h2><p>やっと、reactのプロジェクトおわりました、少しごめなことあるですけれど。</p>
<p>も、次の仕事用意してる</p>
<p>Amazon cloud synchronization</p>
<p>ああ！！メチや　メチや、難しいです；頭もだめちや</p>
<h2 id="2018-7-6"><a href="#2018-7-6" class="headerlink" title="2018/7/6"></a>2018/7/6</h2><p>ああ！あ！　ついに、負け犬をなちゃた<br>残業中に食物をあげで、そんな事はまったく思わなかったです。<br>相手は強すぎる、俺は彼の前に全然駄目です。<br>ちょっとだけない。。。。。、悲しいです。<br>どうするつもり、僕もわからない。<br>せめて答えをもらう</p>
<h2 id="2018-7-9"><a href="#2018-7-9" class="headerlink" title="2018/7/9"></a>2018/7/9</h2><p>山なほと仕事<br>恋は雨上がりのように</p>
<h2 id="2018-7-10"><a href="#2018-7-10" class="headerlink" title="2018/7/10"></a>2018/7/10</h2><p>父さんと母さんがきちゃった、猫も</p>
<h2 id="2018-7-24"><a href="#2018-7-24" class="headerlink" title="2018/7/24"></a>2018/7/24</h2><p>誰でもいい、彼女の事欲しい、ときとぎそう思うた<br>きっと、俺は寂しくすぎた<br>大切にされたかったら　安売りするな。</p>
<h2 id="2018-8-6"><a href="#2018-8-6" class="headerlink" title="2018/8/6"></a>2018/8/6</h2><p>ごめんれ、きっと僕は狡いです、罪がある。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[decimal类型(236)]]></title>
      <url>https://xuecat.github.io/2018/06/30/236/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[js forin顺序(235)]]></title>
      <url>https://xuecat.github.io/2018/06/17/235/</url>
      <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/235.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<pre><code>平时根本没时间写着，只好全缓存，周末更新上来，唉！！
得找个时间再去看下markdown语法了，排版真特么丑。
</code></pre><p>装逼封装了excel读写的js，forin排序居然用到了，笔记下：</p>
<pre><code>js for in顺序，不会按照定义顺序输出；好像浏览器没按以前标准了;
它处理方式是先把当中的非负整数键提出来，排序好输出，然后将剩下的定义时的顺序输出。
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[stl的swap和(234)]]></title>
      <url>https://xuecat.github.io/2018/06/17/234/</url>
      <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/234.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<pre><code>去p站下图片越来越少了
</code></pre><h3 id="string和vector"><a href="#string和vector" class="headerlink" title="string和vector"></a>string和vector</h3><p>它们都是线性结构，只不过是堆而已。<br>它们都有reserve的概念，所以导致它们的预定义内存</p>
<p>释放内存的方法就是都是用<code>swap</code>, <code>string().swap(s)</code></p>
<p><code>swap</code>交换技巧实现内存释放思想：</p>
<p><strong><em><code>vector()</code>使用<code>vector</code>的默认构造函数建立临时<code>vector</code>对象，再在该临对象上调用<code>swap</code>成员，<code>swap</code>调用之后对象<code>myvector</code>占用的空间就等于一个默认构造的对象的大小，临时对象就具有原来对象v的大小，而该临时对象随即就会被析构，从而其占用的空间也被释放。</em></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c++CRTP和typename与class的区别233]]></title>
      <url>https://xuecat.github.io/2018/05/26/233/</url>
      <content type="html"><![CDATA[<p><code>Curiously Recurring Template Prattern</code>即人们称的静态多态<br>由于c++的多态不能将基类的虚函数定义为模板函数，所以出现的它</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> BaseClass</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> D&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(D t)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">static_cast</span>&lt;T&amp;&gt;(*<span class="keyword">this</span>).funcImpl(t);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">funcImpl</span><span class="params">(T f)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base class"</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Base : <span class="keyword">public</span> BaseClass&lt;Base&gt;</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Derive : <span class="keyword">public</span> BaseClass&lt;Derive&gt;</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">funcImpl</span><span class="params">(T f)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derive class"</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">	BaseClass&lt;Derive&gt; der;</div><div class="line">	der.Func(<span class="number">2</span>);<span class="comment">//base 2</span></div><div class="line"></div><div class="line">	BaseClass&lt;Base&gt; bas;</div><div class="line">	bas.Func(<span class="number">4</span>);<span class="comment">//derive 4</span></div><div class="line"></div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此，多态就能使用模板函数了</p>
<hr>
<p><strong>怕是最近js写多了，这个都忘了，羞愧啊！！</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class</span> MyClass&#123;</div><div class="line">    <span class="keyword">typename</span> T::SubType * ptr;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在这里，typename指出SubType是class T中定义的一个类别，因此ptr是一个指向T::SubType型别的指针。如果没有关键字typename，SubType会被当成一个static成员，于是<br>T::SubType * ptr<br>会被解释为型别T内的数值SubType与ptr的乘积。</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据库遇见的一个问题(232)]]></title>
      <url>https://xuecat.github.io/2018/05/06/232/</url>
      <content type="html"><![CDATA[<p>今天丹麦现场问题：<br>检索丹麦字符(长的像A,又不是A),出现英文A匹配和丹麦字符匹配。</p>
<p>最后发现是mysql的like语句，后面用locate语句精确才没把英文检索出来。<br>查了很久google和官方,并未给解释为啥like的模糊匹配是如此，大多讲locate比like高效。<br>所以写下记录，以后请问！！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c++记录(231)]]></title>
      <url>https://xuecat.github.io/2018/05/06/231/</url>
      <content type="html"><![CDATA[<h2 id="数组检测"><a href="#数组检测" class="headerlink" title="数组检测"></a><strong><strong>数组检测</strong></strong></h2><pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sizeof</span>(<span class="number">0</span>[t]);<span class="comment">//可以检测这个是数组还是类：对数组来说0[t] t[0]都是一样的。但是对类来说，这是个操作函数(一定要实现它的operator函数哦)</span></div></pre></td></tr></table></figure>
</code></pre><h2 id="类完整性判断"><a href="#类完整性判断" class="headerlink" title="类完整性判断"></a><strong><strong>类完整性判断</strong></strong></h2><pre><code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">typedef</span> <span class="keyword">char</span> tt_f[<span class="keyword">sizeof</span>(f) ? <span class="number">1</span> : <span class="number">-1</span>];</div><div class="line">(<span class="keyword">void</span>)<span class="keyword">sizeof</span>(tt_f);</div><div class="line">   <span class="comment">//要注意sizeof的执行是编译期间执行的</span></div><div class="line">   <span class="comment">//所以当类不完整 sizof(f)为0; char[-1]就会编译错误</span></div></pre></td></tr></table></figure>
</code></pre><p><strong><strong>循环删除</strong></strong><br>循环删除由于存在访问异常的情况,<br>有一种方法，即解决访问问题，又能删除想要的。</p>
<h2 id="所以尾部删除好点"><a href="#所以尾部删除好点" class="headerlink" title="所以尾部删除好点"></a>所以尾部删除好点</h2><pre><code><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (<span class="name">int</span> i = f.Count - <span class="number">1</span><span class="comment">; i &gt;= 0; i--)</span></div><div class="line">&#123;</div><div class="line">    if (<span class="name">f</span>[i] &gt; <span class="number">5</span>)</div><div class="line">    &#123;</div><div class="line">        f.RemoveAt(<span class="name">i</span>)<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c#杂项笔记(230)]]></title>
      <url>https://xuecat.github.io/2018/02/28/230/</url>
      <content type="html"><![CDATA[<h3 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h3><p> 同步函数执行到async时会同步执行,当在async里遇见await时，会跳出async函数到外部继续执行。<br> await执行完了后再执行async里面await之后的代码</p>
<p> async函数由于返回的是task类型，注意属性有同步类型</p>
<ol>
<li>函数参数不能有out ref，必须返回Task<ol>
<li>不应混合使用同步和异步代码，异步最好始终异步<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static class DeadlockDemo</div><div class="line">&#123;</div><div class="line">    private static async Task DelayAsync()</div><div class="line">    &#123;</div><div class="line">        await Task.Delay(1000);</div><div class="line">    &#125;</div><div class="line">    // This method causes a deadlock when called in a GUI or ASP.NET context.</div><div class="line">    public static void Test()</div><div class="line">    &#123;</div><div class="line">        //开始延迟函数</div><div class="line">        var delayTask = DelayAsync();</div><div class="line">        // 等待延迟完成</div><div class="line">        delayTask.Wait();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//test方法在gui和aps.net会出现死锁，控制台不会</div><div class="line">//这种死锁的根本原因是 await 处理上下文的方式</div><div class="line">//默认情况下，当等待未完成的 Task 时，会捕获当前“上下文”，在 Task 完成时使用该上下文恢复方法的执行</div><div class="line">//GUI 和 ASP.NET 应用程序具有 SynchronizationContext，它每次仅允许一个代码区块运行。 </div><div class="line">//当 await 完成时，它会尝试在捕获的上下文中执行 async 方法的剩余部分。 </div><div class="line">//但是该上下文已含有一个线程，该线程在（同步）等待 async 方法完成。它们相互等待对方，从而导致死锁。</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<ol>
<li><p>await不像Task.Run()，它并不会创建线程来执行，只会移交权限来继续执行。</p>
</li>
<li><p>我一开始想这玩意，不创建新线程咋个优化呢。后面他们说会挂起执行其它函数，这样并发的时候就能很好处理，不会卡住。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS札记——网上看的装逼写法(229)]]></title>
      <url>https://xuecat.github.io/2018/01/25/229/</url>
      <content type="html"><![CDATA[<p><img src="/picture/229.jpg" alt=""></p>
<h3 id="JS札记"><a href="#JS札记" class="headerlink" title="JS札记"></a>JS札记</h3><p> 数字取整:<br> <code>~~</code> 其实这是个按位非的运算符做了俩次<br> <code>2.33|0</code><br> <code>2.33&gt;&gt;0</code></p>
<p> 字符转数字:<br> <code>var a =&#39;1&#39;; +a;</code> 它用隐式转换来的</p>
<p> 类型判断:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> d == <span class="string">"string"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">d <span class="keyword">instanceof</span> Person;<span class="comment">//判断constructor.prototype是否存在于要检测对象的原型链上. 所以对number string boolean无效</span></div></pre></td></tr></table></figure></p>
<p> parseInt范围:<br> <code>parseInt(0.0000008)</code>//这个结果是8, 小数点后7位出错<br> <code>parseInt(10000000000023291)</code>//20位出错</p>
<p> 数组去重:<br> <code>[...new Set([1, &quot;1&quot;, 2, 1, 1, 3])]</code></p>
<p> 指定长度填充:<br> 以前就在想了，赶紧笔记: <code>let aa = Array(6).fill(8)</code> 长度6,填充8</p>
<p> 短路表达式:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = b&amp;&amp;<span class="number">1</span>; <span class="keyword">if</span> (b) a=<span class="number">1</span>; <span class="keyword">else</span> a=b;</div><div class="line"><span class="keyword">var</span> a = b||<span class="number">1</span>; <span class="keyword">if</span> (b) a=b; <span class="keyword">else</span> a=<span class="number">1</span>;</div></pre></td></tr></table></figure></p>
<p> 高逼格创建函数:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'a'</span>, <span class="string">'a++; return a+1;'</span>);</div><div class="line">f(<span class="number">1</span>)<span class="comment">//3</span></div><div class="line"><span class="comment">//函数字符化</span></div></pre></td></tr></table></figure></p>
<p> 立即执行函数:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;)();</div><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;();</div><div class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;();</div><div class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;();</div><div class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;();</div></pre></td></tr></table></figure></p>
<h3 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h3><ol>
<li>xss安全，对url和内容做过滤，防止嵌入js执行代码</li>
<li>csp, 通过服务器应答头或者html的<code>META</code>标签,限制请求源</li>
</ol>
<h3 id="浏览器Console命令"><a href="#浏览器Console命令" class="headerlink" title="浏览器Console命令"></a>浏览器Console命令</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log();</div><div class="line"><span class="built_in">console</span>.dir();<span class="comment">//显示一个对象所有属性和方法</span></div><div class="line"><span class="built_in">console</span>.dirxml();<span class="comment">//显示网页某节点所包含的html/xml</span></div><div class="line"><span class="built_in">console</span>.assert();<span class="comment">//弹框</span></div><div class="line"><span class="built_in">console</span>.trace();<span class="comment">//附带显示行数</span></div><div class="line"><span class="built_in">console</span>.time();<span class="built_in">console</span>.timeEnd();用来显示代码运行时间</div></pre></td></tr></table></figure>
<h3 id="浏览器其它"><a href="#浏览器其它" class="headerlink" title="浏览器其它"></a>浏览器其它</h3><p> 浏览器能设置条件语句断点<br> 左边可以直接启动手机模式,这样就能看手机状态下的浏览情况</p>
<h3 id="CSS黑魔法"><a href="#CSS黑魔法" class="headerlink" title="CSS黑魔法"></a>CSS黑魔法</h3><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p> 强缓存:</p>
<ul>
<li>当头的Cache-Control的max-age(最多有效时间)/s-maxage(代理最大有效时间) 被设置时, 用头的date和当前时间比对</li>
<li><p>当无 头的cache-control只有头的expires时,则用expires和当前时间对比</p>
<p>协商缓存:</p>
</li>
<li>头有last-modiied和etag,会向服务器请求是否失效,请求包加头if-modified-since和if-none-match.<br>服务器回应304浏览器就本地加载，否则重新发送数据</li>
</ul>
<h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h3><p> 这个属性来源于css3属性<br> 从里到外,margin-&gt;border-&gt;padding-&gt;content.</p>
<ul>
<li><p>content-box标准盒。height指content的高,width指content的宽</p>
</li>
<li><p>border-box怪异盒。height指content+padding+border的高,width指content+padding+border的高</p>
</li>
</ul>
<p>网上说在网页的顶部加上 doctype 声明。假如不加 doctype 声明，那么各个浏览器会根据自己的行为去理解网页。</p>
<h3 id="浏览器安全-1"><a href="#浏览器安全-1" class="headerlink" title="浏览器安全"></a>浏览器安全</h3><p> CSRF(跨站点请求伪造): 用户c打开网站a，未推出a之前，打开网站b。网站b发出请求要求访问网站a，来利用未销毁的cookie来达到攻击的目的</p>
<p> 防范方法:</p>
<ul>
<li>验证http referer字段，这个字段表示http请求来源地址</li>
<li>请求接口添加token验证</li>
<li><p>http添加自定义属性</p>
<p>XSS(跨站脚本攻击):调用web接口时，提交js代码进去，下次访问页面会执行js代码达到攻击</p>
<p>防范方法:</p>
</li>
<li>输入数据编码处理(HTML Entity)</li>
<li>输入数据过滤</li>
<li>矫正</li>
</ul>
<h3 id="JS技巧"><a href="#JS技巧" class="headerlink" title="JS技巧"></a>JS技巧</h3><p><code>[]+{}</code> 非primitive type(即值类型)的<code>+</code>运算,对于数组和<code>object</code>,其实都是在调用<code>toString</code>方法.<br>数组<code>[]</code>的<code>toString</code>其实就是调用<code>.join()</code>方法.<br><code>Object</code>转<code>String</code>就是<code>[object Object]</code>(用<code>String({})</code>测试)</p>
<p><code>[]+{}</code>相当于””+”[object Object]”<br><code>{}+[]</code> 会变成俩端<code>{}</code>和<code>+[]</code>,一个代码段一个执行语句,由于后面是空且被隐式转换了,所以结果是<code>0</code><br><code>{}+{}</code></p>
<h3 id="JS有6个假值-false-null-undefined-0-“”-NaN"><a href="#JS有6个假值-false-null-undefined-0-“”-NaN" class="headerlink" title="JS有6个假值:false null undefined 0 “” NaN"></a>JS有6个假值:false null undefined 0 “” NaN</h3><p> <strong>但是它们之间并非都相等</strong><br> 以下是相等的:<br> <code>false==0</code><br> <code>false==&#39;&#39;</code><br> <code>null==undefined</code><br> <code>0==&#39;&#39;</code></p>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//es5</span></div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> res = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = a.length; i &lt; len; i++) &#123;</div><div class="line">    <span class="keyword">var</span> item = a[i];</div><div class="line">    (res.indexOf(item) === <span class="number">-1</span>) &amp;&amp; res.push(item);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//es6</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(a));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="浏览器渲染和服务器渲染"><a href="#浏览器渲染和服务器渲染" class="headerlink" title="浏览器渲染和服务器渲染"></a>浏览器渲染和服务器渲染</h3><p> 浏览器端渲染，指的是用js去生成html，前端做路由。举例：React, Vue等等前端框架。适合单页面应用程序。</p>
<p> 服务器端渲染，指的是用后台语言通过一些模版引擎生成html。举例：PHP文件、JSP文件、Python的Flask配合Jinja引擎、Django框架、Java配合vm模版引擎、NodeJS配合Jade。适合多页面应用。</p>
<p> <strong>浏览器渲染过程</strong><br> DOM Tree：浏览器将HTML解析成树形的数据结构。<br> CSS Rule Tree：浏览器将CSS解析成树形的数据结构。<br> Render Tree: DOM和CSSOM合并后生成Render Tree。<br> layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。<br> painting: 按照算出来的规则，通过显卡，把内容画到屏幕上</p>
<p> 过程是异步的，下载多少内容，构建多少render树<br> （1）Reflow（回流）：浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染(要尽量避免它:操作dom 元素尺寸变化 css属性变化)。<br> （2）Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。 </p>
<p> <strong>浏览器优化</strong><br> 减少refow/repaint：</p>
<ul>
<li>不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className</li>
<li>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量</li>
<li>为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的</li>
<li><p>千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局</p>
<p><strong>CSS优化</strong><br>CSS选择符是从右到左进行匹配的。从右到左！所以，#nav li 我们以为这是一条很简单的规则，秒秒钟就能匹配到想要的元素，但是，但是，但是，是从右往左匹配啊，所以，会去找所有的li，然后再去确定它的父元素是不是#nav</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dom深度尽量浅</div><div class="line">减少inline javascript(<span class="keyword">script</span>嵌入那种)、css的数量</div><div class="line">不要为<span class="built_in">id</span>选择器指定类名或是标签，因为<span class="built_in">id</span>可以唯一确定一个元素</div><div class="line">避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;<span class="comment">#tp p&#123;&#125; 子选择符：#tp&gt;p&#123;&#125;</span></div><div class="line">避免使用通配符</div></pre></td></tr></table></figure>
<p><strong>js的下载和执行会阻塞Dom树的构建</strong></p>
</li>
</ul>
<h3 id="js数组"><a href="#js数组" class="headerlink" title="js数组"></a>js数组</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> tt = [<span class="string">"22"</span>, <span class="string">"55"</span>, <span class="string">"88"</span>];</div><div class="line">tt[<span class="number">7</span>] = <span class="number">3</span>;</div><div class="line">t.length<span class="comment">//8 是不是很惊讶，然而t[6]是undefined</span></div></pre></td></tr></table></figure>
<h3 id="js模块加载"><a href="#js模块加载" class="headerlink" title="js模块加载"></a>js模块加载</h3><p> commonjs:nodejs应用最多，它的require是同步的，运行时确定模块依赖关系，先加载整个模块，直接生产对象1<br> 再从对象上读取方法<br> amd:requirejs就实现了amd规范，异步，运行时加载<br> es6：编译时确定依赖关系，导出任意值</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[react插件(228)]]></title>
      <url>https://xuecat.github.io/2017/12/25/228/</url>
      <content type="html"><![CDATA[<h3 id="react-thunk"><a href="#react-thunk" class="headerlink" title="react-thunk"></a>react-thunk</h3><p> 我一开始觉得把<code>props.dispatch</code>当参数传总会异步的，但是当多个时就会分不清。</p>
<ol>
<li>只有<code>store</code>的<code>dispatch</code>后面才能跟<code>then</code>，其它都不能</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">tt</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">dis</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> tt = dis(addTodo(<span class="string">'wangqiu'</span>));<span class="comment">//函数出入的参数就是dispatch，所以以次来异步发action</span></div><div class="line">    <span class="keyword">return</span> dis(toggleTodo(tt));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">   &lt;TodoList</div><div class="line">          todos=&#123;visibleTodos&#125;</div><div class="line">          onTodoClick=&#123;index =&gt;</div><div class="line">            &#123;dispatch(test(index))&#125;<span class="comment">//普遍做法如此，给dispatch传个函数进去</span></div><div class="line">          &#125; /&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="immutable"><a href="#immutable" class="headerlink" title="immutable"></a>immutable</h3><p> <code>https://www.w3cplus.com/javascript/immutable-js.html</code></p>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p> 最近看<code>react-redux</code>,<br> <code>connect</code>中的参数有<code>mapStateToProps</code>和<code>mapDispatchToProps</code>,剩下俩个不说,<br> 他们第二个参数<code>ownProps</code>,指的是当前组件的属性<br> 它指的是<code>mapStateToProps</code>之外的属性(即通过xml属性传递的属性),state转prop后自己是能访问到的。</p>
<pre><code>connect的第二个参数,redux会给mapDispatchToProps传一个dispatch参数，拿到后可以自己做，它的返回值会被直接注入到组件的props里面。我喜欢直接返回dispatch
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mapDispatchToProps = dispatch =&gt; &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">            onTodoClick: id =&gt; &#123;</div><div class="line">            dispatch(toggleTodo(id))</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h4 id="redux-actions"><a href="#redux-actions" class="headerlink" title="redux-actions"></a>redux-actions</h4><p> createAction<br> 以前:<br> <code>const startAction = () =&gt; ({type:START})</code><br> 使用:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;createAction&#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span>;</div><div class="line"><span class="keyword">const</span> startAction = createAction(START);</div></pre></td></tr></table></figure></p>
<p> handleactions<br> 以前:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">state=defaultState, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span>(action.type) &#123;</div><div class="line">        <span class="keyword">case</span> START : &#123;<span class="keyword">return</span> &#123;...state, runStatus:<span class="literal">true</span>&#125;&#125;;<span class="comment">//es6的解构太方便了，会直接覆盖</span></div><div class="line">        <span class="keyword">case</span> STOP: &#123;<span class="keyword">return</span> &#123;...state, runStatus:<span class="literal">false</span>&#125;&#125;;<span class="comment">//同名属性覆盖</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 使用:<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;handleActions&#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span>;</div><div class="line"><span class="keyword">const</span> time = handleActions(&#123;</div><div class="line">    START:(state, action) =&gt; (&#123;...state, runStatus:<span class="literal">true</span>&#125;),</div><div class="line">    STOP:(state, action) =&gt; (&#123;...state, runStatus:<span class="literal">false</span>&#125;),</div><div class="line">&#125;, defaultState);</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c++11左右值 (226)]]></title>
      <url>https://xuecat.github.io/2017/12/18/226/</url>
      <content type="html"><![CDATA[<h3 id="C-左右值"><a href="#C-左右值" class="headerlink" title="C++左右值"></a>C++左右值</h3><p> 左值指即能出现等号左边，也能出现在右边的变量（通常指有变量名的值）<br> 右值值只能出现等号右边的值（通常指无变量名的值，函数返回和表达式，常量——不跟对象关联的常量）<br> c++11在上面右值多个将亡值<br><code>move</code>右转左 <code>forward</code>左转右</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">MyClass <span class="title">fun</span> <span class="params">()</span> </span>&#123;MyClass <span class="keyword">return</span> s;&#125;</div><div class="line">MyClass s= fun();</div><div class="line">MyClass&amp; s = fun();</div><div class="line">MyClass&amp;&amp; s = fun();<span class="comment">//这三个全是调用移动构造函数</span></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS继承和函数式编程的curry等(227)]]></title>
      <url>https://xuecat.github.io/2017/12/18/227/</url>
      <content type="html"><![CDATA[<p><img src="/picture/227.jpg" alt=""></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul>
<li>每个函数对象有个一个<code>prototype</code>(显式原型),指向<code>constructor</code>;但<code>constructor.prototype</code>指向本身.</li>
<li>实例只有<code>__proto__</code>(隐式原型)</li>
<li>所有实例需要共享的属性和方法,都可放在<code>prototype</code>;不需要则放在构造函数中</li>
<li>实例的<code>__proto__</code>指向构造该对象的构造函数的原型即<code>**.prototype</code></li>
</ul>
<h3 id="es5-6种继承"><a href="#es5-6种继承" class="headerlink" title="es5 6种继承"></a>es5 6种继承</h3><p><strong>来自原型对象的引用属性是所有实例共享的</strong></p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.val = <span class="number">1</span>;</div><div class="line">    <span class="keyword">this</span>.arr = [<span class="number">1</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;...&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>简单链</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Sub.prototype = <span class="keyword">new</span> Super();<span class="comment">//共享原型对象，arr是引用类型</span></div><div class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub();</div><div class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> Sub();</div><div class="line"></div><div class="line"><span class="comment">//1.无法构造函数传参</span></div><div class="line">sub1.val = <span class="number">2</span>;<span class="comment">//不会影响sub2</span></div><div class="line">sub1.arr.push(<span class="number">2</span>);<span class="comment">//会影响sub2</span></div></pre></td></tr></table></figure>
<p> <strong>补充</strong><br>  对继承的简单链原理补充<br>我一直在想那样的影响为何有,今天想通了,来做点笔记</p>
<p><strong>补充:</strong> <br></p>
<ul>
<li>call: 替换上下文,可以想象成替换<code>this</code></li>
<li>new:<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj  = &#123;&#125;;</div><div class="line">obj.__proto__ = Base.prototype;</div><div class="line">Base.call(obj);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在<code>call</code>替换后，它还会再调用一遍<code>Base</code>函数,保证有成员变量</p>
<p><strong>过程分析:</strong><br></p>
<ul>
<li>第一行的<code>new Super</code>直接导致<code>Sub.prototype</code>拥有了<code>val</code>和<code>arr</code></li>
<li>二三行的<code>new Sub</code>只是将<code>__proto__</code>指向了<code>Sub.prototype</code></li>
</ul>
<p>所以使用<code>sub.val</code> <code>sub.arr</code>却也只是访问<code>Sub.prototype</code>上面的东西而已</p>
<p>如此说来,大家都访问一个东西却为何<code>val</code>不影响呢?<br><br>因为在第6行里是个创建而不是修改</p>
<p>第六行是对<code>sub1</code>创建一个私有属性并赋值<br>第七行是访问<code>sub1</code>的<code>arr</code>,然而没有从原型链上拿去了</p>
<ul>
<li>简单链很好,就怕某地出错,记住它们是访问一个</li>
<li>借用构造函数这个太浪费了不考虑</li>
<li>new的数量不是很多倒是可以用用组合继承</li>
</ul>
</li>
<li><p>借用构造函数</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">val</span>) </span>&#123;...&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>, val); <span class="comment">//1.子类互不影响 2.但是复制了父类实例属性导致内存增加 3.call不会复制原型链</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub();</div></pre></td></tr></table></figure>
</li>
<li><p>组合继承</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">val</span>) </span>&#123;...&#125;</div><div class="line"></div><div class="line">Super.prototype.fun1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;<span class="comment">//函数全放入原型中，方便共享</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>, val);<span class="comment">//保留传参功能</span></div><div class="line">&#125;</div><div class="line">Sub.prototype = <span class="keyword">new</span> Super();<span class="comment">//1. 函数复用 2.构造函数传参 3.原型多余内存</span></div><div class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub(<span class="number">1</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>寄生组合继承</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">val</span>) </span>&#123;...&#125;</div><div class="line">Super.prototype.fun1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    Super.call(<span class="keyword">this</span>, val);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>) </span>&#123; <span class="comment">//构建只有原型链的空对象</span></div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    F.prototype = obj;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> proto = beget(Super.prototype);</div><div class="line">proto.constructor = Sub;</div><div class="line">Sub.prototype = proto;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();<span class="comment">//1.确实解决了以上所有问题 2.书写太麻烦了</span></div></pre></td></tr></table></figure>
</li>
<li><p>原型(感觉没意义)</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">beget</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">    F.prototype = obj;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sup = <span class="keyword">new</span> Super();</div><div class="line"><span class="keyword">var</span> sub = beget(sup);</div><div class="line">sub.v = v;</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="es6继承"><a href="#es6继承" class="headerlink" title="es6继承"></a>es6继承</h3><p>上面的<code>寄生组合继承</code>同，多个<code>static</code>定义静态属性</p>
<h3 id="Curry"><a href="#Curry" class="headerlink" title="Curry"></a>Curry</h3><p> 这个概念是存储传入参数，够了才执行函数<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fun = a=&gt; b=&gt; c=&gt; &#123;<span class="keyword">return</span> a+b+c&#125;<span class="comment">//注意return</span></div><div class="line"><span class="keyword">let</span> fun1 = fun(<span class="number">1</span>)<span class="comment">//存储函数</span></div><div class="line"><span class="keyword">let</span> fun2 = fun1(<span class="number">2</span>);</div><div class="line"><span class="keyword">let</span> fun3 = fun2(<span class="number">3</span>);<span class="comment">//6</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> fun1 = fun(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)<span class="comment">//6, 参数多了会报错</span></div></pre></td></tr></table></figure></p>
<h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>  这个es6并没有实现，但是很多库有这个函数<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> greeting = (firstName, lastName) =&gt; <span class="string">'hello, '</span> + firstName + <span class="string">' '</span> + lastName</div><div class="line"><span class="keyword">var</span> toUpper = str =&gt; str.toUpperCase()</div><div class="line"><span class="keyword">var</span> fn = compose(toUpper, greeting)</div><div class="line"><span class="built_in">console</span>.log(fn(<span class="string">'jack'</span>, <span class="string">'smith'</span>))</div><div class="line"><span class="comment">// ‘HELLO，JACK SMITH’</span></div></pre></td></tr></table></figure></p>
<ul>
<li>compose的参数是函数，返回的也是一个函数</li>
<li>因为除了第一个函数的接受参数，其他函数的接受参数都是上一个函数的返回值，所以初始函数的参数是多元的，而其他函数的接受值是一元的</li>
<li>compsoe函数可以接受任意的参数，所有的参数都是函数，且执行方向是自右向左的，初始函数一定放到参数的最右面</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c++函数指针模板又一次说明(225)]]></title>
      <url>https://xuecat.github.io/2017/10/26/225/</url>
      <content type="html"><![CDATA[<p><img src="/picture/225.jpg" alt=""></p>
<h3 id="函数指针又一次说明"><a href="#函数指针又一次说明" class="headerlink" title="函数指针又一次说明"></a>函数指针又一次说明</h3><p>今天看rapidjson的源码，看到一句默认操作符转换函数指针的代码懵逼了居然。。<br>好歹也是读了十来本c++的书了，还这么2。<br>顺便做笔记。</p>
<ul>
<li>按照effictive说法，结构体比函数指针快。所以用<code>operator()</code>代替函数指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//我按照它代码的写法，尝试了下。感觉默认指针函数只能用在if语句上来走个默认转换</span></div><div class="line"><span class="keyword">struct</span> Prs &#123;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(Prs::*Boolt)</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">bool</span> m_bR;</div><div class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">Boolt</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> !IsEr() ? &amp;Prs::IsEr : <span class="literal">NULL</span>;</div><div class="line">  &#125;;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsEr</span><span class="params">()</span> <span class="keyword">const</span> </span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> m_bR == <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ah</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Prs &amp;f, Prs::Boolt df)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> ((f.*df)())</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> a+b;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> a-b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Prs d;</div><div class="line">d.m_bR = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (d)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> f = ah(<span class="number">1</span>, <span class="number">2</span>, d, d);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调用函数指针这个看上去没有创建对象，其实是初始化了一个临时对象再来调用它的operator()函数</span></div><div class="line"><span class="comment">//感觉用这个方法方便点</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TR, <span class="keyword">typename</span> TP&gt;</div><div class="line"><span class="keyword">struct</span> PrsT &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function">TR <span class="title">operator</span><span class="params">()</span> <span class="params">(TP a, TP b)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> a+b;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TR, <span class="keyword">typename</span> TP, <span class="keyword">typename</span> Fun&gt;</div><div class="line"><span class="function">TR <span class="title">aht</span><span class="params">(TR a, TP b, Fun f)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> f(a, b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Prs &#123;</div><div class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(Prs::*Boolt)</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">bool</span> m_bR;</div><div class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">Boolt</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> !IsEr() ? &amp;Prs::IsEr : <span class="literal">NULL</span>;</div><div class="line">	&#125;;</div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">IsEr</span><span class="params">()</span> <span class="keyword">const</span> </span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> m_bR == <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> ff = aht(<span class="number">1</span>, <span class="number">2</span>, PrsT&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;());</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React再次学习(224)]]></title>
      <url>https://xuecat.github.io/2017/08/29/224/</url>
      <content type="html"><![CDATA[<p><img src="/picture/224.jpg" alt=""></p>
<h3 id="ref的使用"><a href="#ref的使用" class="headerlink" title="ref的使用"></a>ref的使用</h3><p>这是react对<code>render</code>中元素提供的一个属性，专门用来标志<code>mount</code>后的元素<br>这个回调属性会在组件安装后立即执行。</p>
<h4 id="ref字符"><a href="#ref字符" class="headerlink" title="ref字符"></a>ref字符</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">"theInput"</span>/&gt;</span> //通过这个属性来对一个dom设置标志符</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">React.findDOMNode(<span class="keyword">this</span>.refs.theInput).focus();<span class="comment">//再通过这个方法来达到访问实体化dom的效果</span></div></pre></td></tr></table></figure>
<h4 id="ref函数"><a href="#ref函数" class="headerlink" title="ref函数"></a>ref函数</h4><p>当它作为函数时，默认参数就是一个dom的对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">TextInput</span> <span class="attr">ref</span>=<span class="string">&#123;(c)</span> =&gt;</span> this._input = c&#125; /&gt;;//由于安装后立即执行，能得到对象</span></div><div class="line">&#125;,</div><div class="line">componentDidMount: function() &#123;</div><div class="line">   this._input.focus();//对对象操作</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<h3 id="bind和this"><a href="#bind和this" class="headerlink" title="bind和this"></a>bind和this</h3><p> 官方文档中react用bind很多;<br> 但看他们喜欢在构造函数如此： this.handleToggleClick = this.handleToggleClick.bind(this)</p>
<p> 我喜欢用箭头函数(es6特性，this指向定义处)直接调用</p>
<h3 id="JSX嵌入"><a href="#JSX嵌入" class="headerlink" title="JSX嵌入"></a>JSX嵌入</h3>  <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//jsx嵌入任何表达式</div><div class="line">&lt;div&gt;</div><div class="line">  &lt;h1&gt;Hello!&lt;/h1&gt;</div><div class="line">  &#123;unreadMessages.length &gt; 0 &amp;&amp;</div><div class="line">    &lt;h2&gt;</div><div class="line">      You have &#123;unreadMessages.length&#125; unread messages.</div><div class="line">    &lt;/h2&gt;</div><div class="line">  &#125;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">//三目运算符</div><div class="line">&lt;div&gt;</div><div class="line">  The user is &lt;b&gt;&#123;isLoggedIn ? 'currently' : 'not'&#125;&lt;/b&gt; logged in.</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> components = &#123;</div><div class="line">  photo: PhotoStory,</div><div class="line">  video: VideoStory</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Story</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="comment">// Correct! JSX type can be a capitalized variable.</span></div><div class="line">  <span class="keyword">const</span> SpecificStory = components[props.storyType];</div><div class="line">  <span class="keyword">return</span> &lt;SpecificStory story=&#123;props.story&#125; /&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//默认值</div><div class="line">&lt;MyTextBox autocomplete /&gt;//它会默认传true的，但是官方建议不要这么写</div><div class="line"></div><div class="line">//利用es6的解构</div><div class="line">function App1() &#123;</div><div class="line">  return &lt;Greeting firstName="Ben" lastName="Hector" /&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function App2() &#123;</div><div class="line">  const props = &#123;firstName: 'Ben', lastName: 'Hector'&#125;;</div><div class="line">  return &lt;Greeting &#123;...props&#125; /&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="html不接受字符"><a href="#html不接受字符" class="headerlink" title="html不接受字符"></a>html不接受字符</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//有以下俩种方式解决</span></div><div class="line">&lt;MyComponent message=<span class="string">"&amp;lt;3"</span> /&gt;</div><div class="line"></div><div class="line">&lt;MyComponent message=&#123;'&lt;3'&#125; /&gt;</div></pre></td></tr></table></figure>
<h4 id="jsx插入函数"><a href="#jsx插入函数" class="headerlink" title="jsx插入函数"></a>jsx插入函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这种用法太牛逼了，虽然不多见</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Repeat</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> items = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; props.numTimes; i++) &#123;</div><div class="line">    items.push(props.children(i));<span class="comment">//这里直接调用父类定义的函数，一个一个执行添加</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;items&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListOfTenThings</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Repeat</span> <span class="attr">numTimes</span>=<span class="string">&#123;10&#125;</span>&gt;</span></span></div><div class="line">      &#123;(index) =&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>This is item &#123;index&#125; in the list<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">Repeat</span>&gt;</span></div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="react-map组件时"><a href="#react-map组件时" class="headerlink" title="react map组件时"></a>react map组件时</h3><ul>
<li>一个元素的key最好是这个元素在<strong>列表</strong>中拥有的一个独一无二的字符串(所以不同数组列表可以用相同key)</li>
<li>元素的key只有在它和它的兄弟节点对比时才有意义(换句话说必须在map函数里面的组件里)</li>
<li>key只对react可见，要用其值，请将作为属性再加个传入</li>
</ul>
<h3 id="计算属性名"><a href="#计算属性名" class="headerlink" title="计算属性名"></a>计算属性名</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//多了个name属性，来对应绑定属性</span></div><div class="line"><span class="comment">//通过</span></div><div class="line"><span class="keyword">this</span>.setState(&#123;[name]: value&#125;);</div><div class="line"><span class="comment">//等同于如下</span></div><div class="line"><span class="keyword">var</span> partState = &#123;&#125;;</div><div class="line">partState[name] = value;</div><div class="line"><span class="keyword">this</span>.setState(partState);</div></pre></td></tr></table></figure>
<h3 id="控制多个元素"><a href="#控制多个元素" class="headerlink" title="控制多个元素"></a>控制多个元素</h3><p> 这个是看了官方的例子，感觉太好用了，笔记下来</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Reservation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      isGoing: <span class="literal">true</span>,</div><div class="line">      numberOfGuests: <span class="number">2</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.handleInputChange = <span class="keyword">this</span>.handleInputChange.bind(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  handleInputChange(event) &#123;</div><div class="line">    <span class="keyword">const</span> target = event.target;</div><div class="line">    <span class="keyword">const</span> value = target.type === <span class="string">'checkbox'</span> ? target.checked : target.value;</div><div class="line">    <span class="keyword">const</span> name = target.name;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.setState(&#123;</div><div class="line">      [name]: value</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;form&gt;</div><div class="line">        &lt;label&gt;</div><div class="line">          Is going:</div><div class="line">          &lt;input</div><div class="line">            name="isGoing"</div><div class="line">            type="checkbox"</div><div class="line">            checked=&#123;this.state.isGoing&#125;</div><div class="line">            onChange=&#123;this.handleInputChange&#125; /&gt;</div><div class="line">        &lt;/label&gt;</div><div class="line">        &lt;br /&gt;</div><div class="line">        &lt;label&gt;</div><div class="line">          Number of guests:</div><div class="line">          &lt;input</div><div class="line">            name="numberOfGuests"</div><div class="line">            type="number"</div><div class="line">            value=&#123;this.state.numberOfGuests&#125;</div><div class="line">            onChange=&#123;this.handleInputChange&#125; /&gt;</div><div class="line">        &lt;/label&gt;</div><div class="line">      &lt;/form&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ref用于子组件"><a href="#ref用于子组件" class="headerlink" title="ref用于子组件"></a>ref用于子组件</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Parent extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;CustomTextInput</div><div class="line">        inputRef=&#123;el =&gt; this.inputElement = el&#125;</div><div class="line">      /&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="突变数据"><a href="#突变数据" class="headerlink" title="突变数据"></a>突变数据</h3><p> 通过<code>shouldComponentUpdate</code>来判断是否渲染组件，有个<code>React.PureComponent</code>可提供继承，它默认填写了<code>shouldComponentUpdate</code>函数，但是里面只是一些浅比较(对像就算被添加属性,对象的地址还是没变,导致比较为true);<br> 深层数据则不行。<br> 所以官方建议是<code>Immutable</code>来配合使用</p>
<h3 id="老式的创建类和es6创建类"><a href="#老式的创建类和es6创建类" class="headerlink" title="老式的创建类和es6创建类"></a>老式的创建类和es6创建类</h3><p> <a href="https://reactjs.org/docs/react-without-es6.html" target="_blank" rel="external">https://reactjs.org/docs/react-without-es6.html</a></p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p> 这个特性在官方网站上被说明为不建议使用.<br> 优点:<br>  跨越组件层次传递，这简直太好了，不用像<code>props</code>那样一个一个传，直接跨代传都可以<br> 缺点:<br>  这也是官方举例，当state或者setState 被调用,getChildContext也会被调用,生成新的context;<br>  但<code>shouldComponentUpdate</code>返回的 false 会 block 住 context，导致没有更新</p>
<p>  另外context相当一个全局变量，难以追溯修改源.</p>
<p> 虽然官方不建议用，但看网上建议把它当个全局固定值用，避免修改来躲避状态更新失败.</p>
<h3 id="protals"><a href="#protals" class="headerlink" title="protals"></a>protals</h3><p> 当组件需要”跳出”容器(对话框,提示框,<code>overflow:hidden</code> <code>z-index</code>等),此时使用此属性</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js的数组(223)]]></title>
      <url>https://xuecat.github.io/2017/07/17/223/</url>
      <content type="html"><![CDATA[<p>Javascript中的数组对象是一种伪数组的”Array-like”对象，“它把数组的下标转变成字符串，用其作为属性”。<br>声明一个数组：<br>var arr=[1,2,3];<br>然后使用“负索引”<br>arr[-0.5]=100;<br>实际上arr.length值仍然是3，不过arr得到一个键值对为-0.5:100的属性，虽然不能使用小数点取这个属性和值，但方括号是可以用的 arr[-0.5]或arr[‘-0.5’]都可以得到100</p>
<p><code>负数和字符并不影响长度</code><br>数组对象其实是一个特殊对象，他拥有普通对象的全部特性，所以不止负索引，小数索引，连字符串索引都是可以的，只是用这些索引向数组添加属性时，数组的length不会增加罢了，而只有当索引是正整数或其对应数字串时，length才会增加，仅此而已。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js this/原型/pro(222)]]></title>
      <url>https://xuecat.github.io/2017/06/06/222/</url>
      <content type="html"><![CDATA[<p><img src="/picture/222.jpg" alt=""></p>
<p>今天看一代码把以前的知识又忘了，现专门记下笔记</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><blockquote>
<p>this的上下文环境永远在被调用函数的上下文环境</p>
</blockquote>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var someuser = &#123; </div><div class="line">    name: <span class="string">'byvoid'</span>, </div><div class="line">    <span class="function"><span class="keyword">func</span>: <span class="title">function</span><span class="params">()</span> &#123;</span></div><div class="line">        console.<span class="built_in">log</span>(this.name)<span class="comment">; </span></div><div class="line">    &#125;</div><div class="line">&#125;<span class="comment">; </span></div><div class="line">var foo = &#123; </div><div class="line">    name: <span class="string">'foobar'</span></div><div class="line">&#125;<span class="comment">;</span></div><div class="line"> </div><div class="line">someuser.<span class="keyword">func</span>()<span class="comment">; // 输出 byvoid (被调用函数func的上下文是someuser)</span></div><div class="line"> </div><div class="line">foo.<span class="keyword">func</span> = someuser.<span class="keyword">func</span><span class="comment">; </span></div><div class="line">foo.<span class="keyword">func</span>()<span class="comment">; // 输出 foobar (被调用函数func的上下文是foo)</span></div><div class="line"> </div><div class="line">name = <span class="string">'global'</span><span class="comment">;</span></div><div class="line"><span class="function"><span class="keyword">func</span> = <span class="title">someuser</span>.<span class="title">func</span>; </span></div><div class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span>; // 输出 <span class="title">global</span> <span class="params">(被调用函数fuc的上下文是全局)</span></span></div></pre></td></tr></table></figure>
<h3 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h3><p>lamda不同，它是在哪被定义，this的上下文就是被定义的地方<br>就算是嵌套箭头，也没有this上下文，默认最外层的上下文</p>
<p>由于没有自己的this，所以bind call等函数也无效 </p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>js对象分俩种：普通对象和函数对象<br>函数对象： 函数的定义，匿名函数的赋值<br>普通对象：数组，结构体，new function()</p>
<p>一个函数对象可以访问到<code>prototype</code> <code>__proto__</code><br>普通对象只能访问到<code>__proto__</code></p>
<p><code>__proto__</code>指向构造函数的<code>prototype</code>,这形成了原型链(也是es5的继承，属性的访问当prototype没有就会通过<code>__proto__</code>去上级寻找)<br>所以函数对象的<code>__proto__</code>指向的是原型的<code>prototype</code></p>
<p><code>prototype</code>的来源: 1.原型的继承 2.自定义的赋值</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[WebApi(221)]]></title>
      <url>https://xuecat.github.io/2017/04/19/221/</url>
      <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/221.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<p>webvideo本地枚举文件太恶心了，算了写个服务器来读吧，顺便把avi和rmvb解包写了.</p>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul>
<li>这里的Controller继承于ApiController,</li>
<li>IE和Firefox发送了不同的Accept报头,导致返回的数据可以是JSON，也可以是XML（感觉太强大了，这都做好了。客户端请求的“application/json”中的Accept报头）</li>
</ul>
<p>路由：<code>/api/{controller}/{id}</code> 在<code>id = RouteParameter.Optional</code>情况下<br>controller匹配控制器名<br>{id} 匹配名称为id的方法参数（即函数的参数名叫id）</p>
<p><code>/api/products</code> <code>products</code>匹配名为ProductsController的控制器。该请求是一个GET请求，因此框架在ProductsController上查找一个名称以<code>GET…</code>开头的方法。</p>
<p>进一步地，这个URI不包含可选的{id}片段，因此，框架查找的是一个不带参数的方法。于是，ProductsController::GetAllProducts满足所有这些需求</p>
<p><strong>同理</strong> 如果是个<code>POST``Put</code>请求，会去找<code>POST``Put</code>开头的方法 以及<code>Delete</code></p>
<p><code>/api/products/1</code> 找到参数名叫id的函数，并把这个传入。<br><strong>同理</strong> <code>/api/products/abc</code>就不行，因为只有GetProductById有个叫id的参数，但是是int，无法转换为string</p>
<p><strong>Post</strong><br>js和c#的完美兼容，直接互相传对象，完全可以解析<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> response = Request.CreateResponse&lt;Product&gt;(HttpStatusCode.Created, item); </div><div class="line"><span class="built_in">string</span> uri = Url.<span class="keyword">Link</span>(<span class="string">"DefaultApi"</span>, <span class="literal">new</span> &#123; id = item.Id &#125;); <span class="comment">//当服务器创建一个资源时，它应当在响应的Location报头中包含新资源的URI。</span></div><div class="line">response.Headers.Location = <span class="literal">new</span> Uri(uri);</div></pre></td></tr></table></figure></p>
<h3 id="WebapiClient"><a href="#WebapiClient" class="headerlink" title="WebapiClient"></a>WebapiClient</h3><p>添加库，用<code>HttpClient</code>设置base uri，设置请求报头。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">HttpResponseMessage response = client.GetAsync(<span class="string">"api/products"</span>).Result;  <span class="comment">// Blocking call（阻塞调用）! </span></div><div class="line"><span class="keyword">if</span> (response.IsSuccessStatusCode) </div><div class="line">&#123; </div><div class="line">    <span class="comment">// Parse the response body. Blocking!</span></div><div class="line">    <span class="comment">// 解析响应体。阻塞！</span></div><div class="line">    <span class="keyword">var</span> products = response.Content.ReadAsAsync&lt;IEnumerable&lt;Product&gt;&gt;().Result; </div><div class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> p <span class="keyword">in</span> products) </div><div class="line">    &#123; </div><div class="line">        Console.WriteLine(<span class="string">"&#123;0&#125;\t&#123;1&#125;;\t&#123;2&#125;"</span>, p.Name, p.Price, p.Category); </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">//异步和阻塞注意</span></div><div class="line"><span class="comment">//自动构造结构数据很智能：比如Product有个属性和服务器的不对应，那那个属性将不被赋值，只赋值对应的属性</span></div><div class="line"></div><div class="line">---</div><div class="line"><span class="comment">//post的时候</span></div><div class="line"><span class="comment">// 创建JSON格式化器。</span></div><div class="line">MediaTypeFormatter jsonFormatter = <span class="keyword">new</span> JsonMediaTypeFormatter(); </div><div class="line"></div><div class="line"><span class="comment">// Use the JSON formatter to create the content of the request body.</span></div><div class="line"><span class="comment">// 使用JSON格式化器创建请求体内容。</span></div><div class="line">HttpContent content = <span class="keyword">new</span> ObjectContent&lt;Product&gt;(product, jsonFormatter); </div><div class="line"></div><div class="line"><span class="comment">// Send the request.</span></div><div class="line"><span class="comment">// 发送请求。</span></div><div class="line"><span class="keyword">var</span> resp = client.PostAsync(<span class="string">"api/products"</span>, content).Result;</div><div class="line"><span class="comment">//或者client.PostAsJsonAsync("api/products", gizmo).Result;</span></div></pre></td></tr></table></figure></p>
<p>上面讲了<code>client.GetAsync(&quot;api/products&quot;).Result</code> 是阻塞函数，并不会把控制返回给调用者，这导致一直阻塞（ui线程阻塞）。<br>给出2个解决方法：</p>
<ol>
<li><p><code>async</code>和<code>await</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">GetProducts</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>) </span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">try</span> </div><div class="line">    &#123; </div><div class="line">        btnGetProducts.IsEnabled = <span class="literal">false</span>; </div><div class="line"></div><div class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> client.GetAsync(<span class="string">"api/products"</span>); </div><div class="line">        response.EnsureSuccessStatusCode(); <span class="comment">// Throw on error code（有错误码时报出异常）.</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> products = <span class="keyword">await</span> response.Content.ReadAsAsync&lt;IEnumerable&lt;Product&gt;&gt;(); </div><div class="line">        _products.CopyFrom(products); </div><div class="line"></div><div class="line">    &#125; </div><div class="line">    <span class="keyword">catch</span> (Newtonsoft.Json.JsonException jEx) </div><div class="line">    &#123; </div><div class="line">        <span class="comment">// This exception indicates a problem deserializing the request body.</span></div><div class="line">        <span class="comment">// 这个异常指明了一个解序列化请求体的问题。</span></div><div class="line">        MessageBox.Show(jEx.Message); </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">catch</span> (HttpRequestException ex) </div><div class="line">    &#123; </div><div class="line">        MessageBox.Show(ex.Message); </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">finally</span> </div><div class="line">    &#123; </div><div class="line">        btnGetProducts.IsEnabled = <span class="literal">true</span>; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>安装<code>Async Targeting Pack</code> </p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">client.GetAsync(<span class="string">"api/products/2"</span>).ContinueWith((t) =&gt; </div><div class="line">    &#123; </div><div class="line">        if (t.IsFaulted) </div><div class="line">        &#123; </div><div class="line">            MessageBox.<span class="keyword">Show(t.Exception.Message); </span></div><div class="line">            <span class="keyword">btnGetProducts.IsEnabled </span>= true<span class="comment">; </span></div><div class="line">        &#125; </div><div class="line">        else </div><div class="line">        &#123; </div><div class="line">            var response = t.Result<span class="comment">; </span></div><div class="line">            if (response.IsSuccessStatusCode) </div><div class="line">            &#123; </div><div class="line">                response.Content.ReadAsAsync&lt;IEnumerable&lt;Product&gt;&gt;(). </div><div class="line">                    ContinueWith(<span class="built_in">t2</span> =&gt; </div><div class="line">                        &#123; </div><div class="line">                            if (<span class="built_in">t2</span>.IsFaulted) </div><div class="line">                            &#123; </div><div class="line">                                MessageBox.<span class="keyword">Show(t2.Exception.Message); </span></div><div class="line">                                <span class="keyword">btnGetProducts.IsEnabled </span>= true<span class="comment">; </span></div><div class="line">                            &#125; </div><div class="line">                            else </div><div class="line">                            &#123; </div><div class="line">                                var products = <span class="built_in">t2</span>.Result<span class="comment">; </span></div><div class="line">                                _products.CopyFrom(products)<span class="comment">; </span></div><div class="line">                                <span class="keyword">btnGetProducts.IsEnabled </span>= true<span class="comment">; </span></div><div class="line">                            &#125; </div><div class="line">                        &#125;, TaskScheduler.FromCurrentSynchronizationContext())<span class="comment">; </span></div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">    &#125;, TaskScheduler.FromCurrentSynchronizationContext())<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="HttpClient消息处理器"><a href="#HttpClient消息处理器" class="headerlink" title="HttpClient消息处理器"></a>HttpClient消息处理器</h3><p>通过这个我可以把自定义的头处理掉</p>
<h3 id="路由变异"><a href="#路由变异" class="headerlink" title="路由变异"></a>路由变异</h3><p><code>id = RouteParameter.Optional</code>情况下</p>
<p>当路由为 <code>api/{controller}/{action}/{id}</code> 时，<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductsController</span> : <span class="title">ApiController</span> </div><div class="line">&#123; </div><div class="line">    [HttpGet] <span class="comment">//需要显式的指定映射</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Details</span>(<span class="params"><span class="keyword">int</span> id</span>)</span>; <span class="comment">//api/products/details/1</span></div><div class="line"></div><div class="line">    [HttpPost] </div><div class="line">    [ActionName(<span class="string">"Thumbnail"</span>)] <span class="comment">//覆盖动作，这样就转到api/products/thumbnail/id</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddThumbnailImage</span>(<span class="params"><span class="keyword">int</span> id</span>)</span>; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//除此外还有个： [NonAction]属性可以修饰动作，这样框架就不会映射到那个函数</span></div><div class="line"><span class="comment">//[AcceptVerbs("GET", "HEAD")] 允许此方法对get和head的http方法（put/delete等同理）</span></div></pre></td></tr></table></figure></p>
<p>###　异常处理<br>总而言之（exception和error都用最好）：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="keyword">string</span>.Format(<span class="string">"Product with id = 0 not found"</span>);</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpResponseException(</div><div class="line">    Request.CreateErrorResponse(HttpStatusCode.NotFound, message));</div></pre></td></tr></table></figure></p>
<h3 id="自定义消息过滤"><a href="#自定义消息过滤" class="headerlink" title="自定义消息过滤"></a>自定义消息过滤</h3><p>这个要继承<code>DelegatingHandler</code>,服务器在config.MessageHandlers加，客户端在HttpClient加。</p>
<p>唯一的注意http头的加法，客户端随便加，服务器一般如此<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">return</span> <span class="selector-tag">base</span><span class="selector-class">.SendAsync</span>(request, cancellationToken)</div><div class="line"><span class="selector-class">.ContinueWith</span>( (task) =&gt; &#123;</div><div class="line">    HttpResponseMessage response = task<span class="selector-class">.Result</span>;</div><div class="line">    response<span class="selector-class">.Headers</span><span class="selector-class">.Add</span>(_header, <span class="string">"Server"</span>);</div><div class="line">    return response;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Post数据"><a href="#Post数据" class="headerlink" title="Post数据"></a>Post数据</h3><p>有俩种，复合类型和简单类型</p>
<ul>
<li>复合类型(传和接受都是自定义的结构体)</li>
</ul>
<p>服务器对对这类型没啥要求，传入参数是自定义类或结构体就好。</p>
<p>客户端代码必须传<code>application/json</code>格式数据(我用postman测试了下，选raw，传json字符串可以的)</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">string <span class="attr">seri</span> = JsonConvert.SerializeObject(</div><div class="line">                new Product &#123; <span class="attr">Id</span> = <span class="number">1</span>, <span class="attr">Name</span> = <span class="string">"Tomato Soup"</span>, <span class="attr">Category</span> = <span class="string">"Groceries"</span> &#125;);</div><div class="line">HttpResponseMessage <span class="attr">response</span> = client.PostAsync(</div><div class="line">    <span class="string">"api/products/PostPro1/"</span></div><div class="line">    , new StringContent(seri, </div><div class="line">    Encoding.Unicode, <span class="string">"application/json"</span>)).Result;</div></pre></td></tr></table></figure>
<ul>
<li>简单类型(服务器接收的是string int这种类型)</li>
</ul>
<p>服务器要求用<code>[FromBody]</code>修饰参数</p>
<p>客户端要求发送<code>=value</code>的数据（代码和测试真心发俩种数据）</p>
<p>客户端代码,不知道为何必须用<code>{ &quot;&quot;: [&quot;update one&quot;, &quot;update two&quot;, &quot;update three&quot;] }</code>格式数据 且<code>x-www-form-urlencoded</code>它才认同</p>
<p>ajax只需要传上面的格式就好了<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> conte = <span class="keyword">new</span> FormUrlEncodedContent(</div><div class="line">    <span class="keyword">new</span>[]</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">new</span> KeyValuePair&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;(<span class="string">""</span>, <span class="string">"login"</span>)</div><div class="line">    &#125;</div><div class="line">    );</div><div class="line">HttpResponseMessage response = client.PostAsync(</div><div class="line">    <span class="string">"api/products/PostPro1/"</span></div><div class="line">    , conte).Result;</div></pre></td></tr></table></figure></p>
<p>然而我用<code>postman</code>选<code>raw</code>，传<code>=rety</code>就可以传入<code>rety</code>字符进去。<br><strong>angular的js没试过，放以后把</strong> </p>
<h3 id="Upload-Form-Data"><a href="#Upload-Form-Data" class="headerlink" title="Upload Form Data"></a>Upload Form Data</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;HttpResponseMessage&gt; <span class="title">PostFormData</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!Request.Content.IsMimeMultipartContent())</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpResponseException(</div><div class="line">            System.Net.HttpStatusCode.UnsupportedMediaType</div><div class="line">            );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">string</span> root = HttpContext.Current.Server.MapPath(<span class="string">"~/App_Data"</span>);</div><div class="line">    <span class="keyword">var</span> provider = <span class="keyword">new</span> MultipartFormDataStreamProvider(root);</div><div class="line"></div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">await</span> Request.Content.ReadAsMultipartAsync(provider);<span class="comment">//读取后，会自动在根目录保存临时文件</span></div><div class="line"></div><div class="line">        <span class="keyword">foreach</span> (MultipartFileData file <span class="keyword">in</span> provider.FileData)</div><div class="line">        &#123;</div><div class="line">            Trace.WriteLine(file.Headers.ContentDisposition.FileName);</div><div class="line">            Trace.WriteLine(<span class="string">"Server file path: "</span> + file.LocalFileName);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> key <span class="keyword">in</span> provider.FormData.AllKeys)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> val <span class="keyword">in</span> provider.FormData.GetValues(key))</div><div class="line">            &#123;</div><div class="line">                Trace.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;: &#123;1&#125;"</span>, key, val));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        HttpContext.Current.Request.Files[<span class="number">0</span>].SaveAs(root+<span class="string">"//webservertt.txt"</span>);<span class="comment">//重新按文件名保存</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> Request.CreateResponse(HttpStatusCode.OK);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (System.Exception e)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> Request.CreateErrorResponse(HttpStatusCode.InternalServerError, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="限制数据"><a href="#限制数据" class="headerlink" title="限制数据"></a>限制数据</h3><p>如下对结构进行限制<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</div><div class="line"></div><div class="line">    [Required]</div><div class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">decimal</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</div><div class="line"></div><div class="line">    [Range(<span class="number">0</span>,<span class="number">999</span>)]</div><div class="line">    <span class="keyword">public</span> <span class="keyword">double</span> Weight &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//当webapi对一复合类型进行自动转换时，可以用此来判断结构体是否符合限制</span></div><div class="line"><span class="function"><span class="keyword">public</span> HttpResponseMessage <span class="title">Post</span>(<span class="params">Product product</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (ModelState.IsValid)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Do something with the product (not shown).</span></div><div class="line">        <span class="comment">// 用product做一些事（未表示出来）</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpResponseMessage(HttpStatusCode.OK);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpResponseMessage(HttpStatusCode.BadRequest);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Under-Posting和Over-Posting"><a href="#Under-Posting和Over-Posting" class="headerlink" title="Under-Posting和Over-Posting"></a>Under-Posting和Over-Posting</h3><p><code>Under-Posting</code> 当客户端提交时遗漏某些属性，json格式化器会默认给缺失赋值（0）<br><code>Over-Posting</code> 当客户端提交时属性过多时，格式化器会忽略多余的属性</p>
<h3 id="NuGet和Self-Host"><a href="#NuGet和Self-Host" class="headerlink" title="NuGet和Self-Host"></a>NuGet和Self-Host</h3><ol>
<li><code>Microsoft.AspNet.WebApi.OwinSelfHost</code>是自驻留服务安装的</li>
<li>controller接口一定要<code>public</code>，这个搞了我好久哦。</li>
</ol>
<p>单个webapi自己的话(<code>weapi.core</code>是必须的)，要加<code>Microsoft.AspNet.WebApi.WebHost</code><br>这个模式下直接用<code>Global.asax</code>做入口是可以的.(遇见403不怕，只是页面没添加，api接口还是好的)</p>
<p>后来翻资料，还有其它方法可以用<code>Microsoft.Owin.Host.SystemWeb and Microsoft.AspNet.WebApi.Owin</code>;建立<code>Startup</code>入口是可以的。<br>(完全想不明白，为何俩台电脑反应如此不同)</p>
<p>self的要加<code>Microsoft.AspNet.WebApi.OwinSelfHost</code> (这个官方介绍是有俩种方式的，我个人喜欢用owin)<br><code>xcopy /y &quot;$(TargetDir)$(ProjectName).*&quot; &quot;$(ProjectDir)\..\WebHostServerC\bin\Debug&quot;</code></p>
<h4 id="content-root和web-root"><a href="#content-root和web-root" class="headerlink" title="content root和web root"></a>content root和web root</h4><p>要用content root要安装<code>Microsoft.AspNetCore.StaticFiles</code> (<code>Microsoft.AspNetCore.Hosting</code>里面有PhysicalFileProviderd的类)</p>
<h3 id="路由属性和重定向"><a href="#路由属性和重定向" class="headerlink" title="路由属性和重定向"></a>路由属性和重定向</h3><p>一直看他们用<code>Route</code>和<code>RoutePrefix</code>来指定路由,发现调用 <code>MapHttpAttributeRoutes</code>就可以使用了。</p>
<p><a href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2" target="_blank" rel="external">https://docs.microsoft.com/en-us/aspnet/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2</a></p>
<p>路由属性的好处是，可以使用匹配路由([Route(“~/api/authors/{authorId:int}/books”)]public IEnumerable<book> GetByAuthor(int authorId) { … })和父路由</book></p>
<p>先把重定向代码贴了。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span>[Route(<span class="string">""</span>), HttpGet]</div><div class="line"><span class="regexp">//</span>[ApiExplorerSettings(IgnoreApi = true)]</div><div class="line"><span class="regexp">//</span>public HttpResponseMessage RedirectToSwaggerUi()</div><div class="line"><span class="regexp">//</span>&#123;</div><div class="line"><span class="regexp">//</span>    var httpResponseMessage = new HttpResponseMessage(HttpStatusCode.Found);</div><div class="line"><span class="regexp">//</span>    httpResponseMessage.Headers.Location = new Uri(<span class="string">"/app"</span>, UriKind.Relative);</div><div class="line"><span class="regexp">//</span>    return httpResponseMessage;</div><div class="line"><span class="regexp">//</span>&#125;</div></pre></td></tr></table></figure></p>
<h3 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h3><p><code>Microsoft.Owin.StaticFiles</code><br><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/static-files" target="_blank" rel="external">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/static-files</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Bootstrap(218)]]></title>
      <url>https://xuecat.github.io/2017/03/22/218/</url>
      <content type="html"><![CDATA[<p><img src="/picture/218.jpg" alt=""></p>
<p>bootstrap语法太丰富了，完全可以把很多js代码去掉。所以记录下来</p>
<p><a href="http://v3.bootcss.com/components/" target="_blank" rel="external">http://v3.bootcss.com/components/</a><br><a href="http://getbootstrap.com/javascript/#modals-examples" target="_blank" rel="external">http://getbootstrap.com/javascript/#modals-examples</a></p>
<h3 id="ui-bootstrap"><a href="#ui-bootstrap" class="headerlink" title="ui-bootstrap"></a>ui-bootstrap</h3><p>bootstrap的TPLS版本里面有所有组件的html代码.angular最好用这个.<br>然后对于angular使用的是ui-boostrap，这个只是定义了控件，还是要去bootstrap官网去下载bootstrap的源码来。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>它主要是自己的<code>data</code>语法太多了:</p>
<ul>
<li><p><code>data-dismiss=&quot;modal&quot;</code> 如果在<code>modal</code>弹窗加上，那么点击则会关闭弹窗</p>
</li>
<li><p><code>data-toggle=&quot;modal&quot; data-target=&quot;.bs-example-modal-lg&quot;</code>  这样点击按钮就会弹出<code>modal</code>窗口，由于<code>data-target</code>具有css的选择器功能(<code>#id</code>也可以)，所以选择的是class为bs-exampl-modal-lg的元素。</p>
<p>  如：<code>&lt;div class=&quot;modal fade bs-example-modal-sm&quot; tabindex=&quot;-1&quot;&gt;</code> <strong>加上fade类有淡入淡出的特效</strong></p>
</li>
<li><p><code>data-whatever=&quot;&quot;</code> 当一堆按钮要使用同一个模态框时，用这个来传入分别的数据。然而对angular来说完全没必要，毕竟数据绑定了。</p>
</li>
<li><p><code>data-toggle=&quot;dropdown&quot;</code> angular感觉用处不大没细看</p>
</li>
<li><p><code>data-spy=&quot;scroll&quot; data-target=&quot;#navbar-example&quot;</code> 滚动时顺便修改选项</p>
</li>
<li><p><code>data-toggle=&quot;tab&quot;</code> </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;a href="#ejb" tabindex="-1" data-toggle="tab"&gt;//tab项</div><div class="line">&lt;/a&gt;</div><div class="line"></div><div class="line">&lt;div class="tab-pane fade" id="ios"&gt;...&lt;/div&gt;//tab内容</div></pre></td></tr></table></figure>
</li>
<li><p><code>data-toggle=&quot;tooltip&quot; data-placement=&quot;right&quot; title=&quot;Tooltip on right&quot;</code> //表示右边显示tooltip，可以左上下</p>
</li>
<li><p><code>data-container=&quot;body&quot; data-toggle=&quot;popover&quot; data-placement=&quot;left&quot; data-content=&quot;Vivamus sagittis lacus vel augue laoreet rutrum faucibus.&quot;</code> 点击弹出带指定箭头的属性窗口，点击再消失； 多个title=”…”的话弹出窗口会多个标题显示。</p>
</li>
<li><p><code>data-loading-text=&quot;Loading...&quot;</code> 这个我没写全，它展示的效果是点击后显示加载，鼠标禁止，加载完再恢复。</p>
</li>
<li><p><code>data-dismiss=&quot;alert&quot;</code> 这个用于页内嵌入提示框，由于提供各种可使用的格式 <code>alert-warning</code> <code>alert-success</code>。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myAlert"</span> <span class="attr">class</span>=<span class="string">"alert alert-success"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"close"</span> <span class="attr">data-dismiss</span>=<span class="string">"alert"</span>&gt;</span>&amp;times;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">strong</span>&gt;</span>成功！<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>结果是成功的。</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>点关闭也确实能(不能也可以加个ng-hide)，但是动画效果不知道咋实现</p>
<ul>
<li><p><code>data-loading-text</code>好是好就是没法配合angular使用，只能自己写.</p>
</li>
<li><p><code>data-toggle=&quot;collapse&quot;</code> 折叠显示内容</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> <span class="attr">role</span>=<span class="string">"button"</span> <span class="attr">data-toggle</span>=<span class="string">"collapse"</span> <span class="attr">href</span>=<span class="string">"#collapseExample"</span> <span class="attr">aria-expanded</span>=<span class="string">"false"</span> <span class="attr">aria-controls</span>=<span class="string">"collapseExample"</span>&gt;</span></div><div class="line">  Link with href</div><div class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">data-toggle</span>=<span class="string">"collapse"</span> <span class="attr">data-target</span>=<span class="string">"#collapseExample"</span> <span class="attr">aria-expanded</span>=<span class="string">"false"</span> <span class="attr">aria-controls</span>=<span class="string">"collapseExample"</span>&gt;</span></div><div class="line">  Button with data-target</div><div class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"collapse"</span> <span class="attr">id</span>=<span class="string">"collapseExample"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"well"</span>&gt;</span></div><div class="line">    ...</div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>由于这俩个button链接的是一个折叠内容，点击展开，再点折叠。 里么href和data-target达到了相同效果，我想angular估计只能用data-target</p>
<p>一般 aria-*是识别属性，但是这里<code>aria-expanded=&quot;true&quot;</code>会默认展开内容</p>
<ul>
<li><code>data-ride=&quot;carousel&quot;</code>这是个轮播控件来达到相册的效果，<code>.carousel-caption</code>添加标题显示</li>
</ul>
<h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>12网格式<br><code>.col-xs-*</code> Extra small devices (<768px) `.col-sm-*`="" small="" devices="" tabllets(="">=768px)<br><code>.col-md-*</code> Medium devices(&gt;=922px)<br><code>.col-lg-*</code> Large devices(&gt;=1200px)</768px)></p>
<p><code>*-offset-*</code>表示偏移</p>
<p>强制换行用<code>&lt;div class=&quot;row&quot;&gt;</code> 这样即使内部元素也会强制换行</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js好用代码(217)]]></title>
      <url>https://xuecat.github.io/2017/02/28/217/</url>
      <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/picture/217b.jpg" alt=""></div><div class="group-picture-column" style="width: 50%;"><img src="/picture/217a.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<h3 id="js-判断俩对象属性是否相同"><a href="#js-判断俩对象属性是否相同" class="headerlink" title="js(判断俩对象属性是否相同)"></a>js(判断俩对象属性是否相同)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsPropertyEqual</span>(<span class="params">obj1, obj2</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (obj1 === obj2) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!(obj1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>) || !(obj2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> obj1) &#123;</div><div class="line">    <span class="keyword">if</span> (obj1.hasOwnProperty(p) &amp;&amp; !obj2.hasOwnProperty(p)) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (p <span class="keyword">in</span> obj2) &#123;</div><div class="line">    <span class="keyword">if</span> (obj1.hasOwnProperty(p) &amp;&amp; !obj2.hasOwnProperty(p)) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsStructer</span>(<span class="params">data, obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> IsPropertyEqual(obj, <span class="built_in">JSON</span>.parse(data));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="angular-文件选取"><a href="#angular-文件选取" class="headerlink" title="angular(文件选取)"></a>angular(文件选取)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;input type=<span class="string">"file"</span> fileread=<span class="string">"app.js"</span> /&gt;</div><div class="line"></div><div class="line">.directive(<span class="string">"fileread"</span>, [<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        scope: &#123;</div><div class="line">            fileread: <span class="string">"="</span></div><div class="line">        &#125;,</div><div class="line">        link: <span class="function"><span class="keyword">function</span> (<span class="params">scope, element, attributes</span>) </span>&#123;</div><div class="line">            element.bind(<span class="string">"change"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">changeEvent</span>) </span>&#123;</div><div class="line">                scope.$apply(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                    scope.fileread = changeEvent.target.files[<span class="number">0</span>];</div><div class="line">                &#125;);</div><div class="line">                <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</div><div class="line">                reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">etc</span>) </span>&#123;</div><div class="line">                etc.target.result;</div><div class="line">                <span class="comment">//reader.readAsText(scope.fileread);</span></div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;]);</div></pre></td></tr></table></figure>
<h3 id="文件下载（超好用，本地下载类型的）"><a href="#文件下载（超好用，本地下载类型的）" class="headerlink" title="文件下载（超好用，本地下载类型的）"></a>文件下载（超好用，本地下载类型的）</h3><p><a href="http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js" target="_blank" rel="external">http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js</a> </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AngularJS(216)]]></title>
      <url>https://xuecat.github.io/2017/02/23/216/</url>
      <content type="html"><![CDATA[<h2 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h2><p>provider的关系 <a href="https://segmentfault.com/a/1190000003096933" target="_blank" rel="external">https://segmentfault.com/a/1190000003096933</a></p>
<h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><p>no-repeat是所有内置指令中优先级最高的。</p>
<p><code>ng-app</code> 指定AngularJS脚步执行作用域<br><code>ng-model</code> 绑定html元素到数据<br><code>ng-init</code> 初始化数据<br><code>ng-if</code>从dom删除元素<br><code>ng-switch</code> 如同switch适用于多个例子，有ngSwitchCase ngSwitchDefault<br><code>ng-hide</code> 从dom隐藏元素<br><code>ng-options</code> 这个有点多，放下面单独列一项<br><code>ng-disabled</code> 绑定数据到html的disabled属性<br><code>ng-show</code> <code>ng-hide</code><br><code>ng-bind</code>  是指定数据，和<code></code>差不多<br><code>ng-cloak</code> 加载时防止代码未加载完而发生的闪烁<br><code>ng-model</code> 是双向绑定, 在<code>ng-repeat</code>中<code>ng-model</code>必须和<code>ng-change</code>连用<br><code>ng-class</code> 绑定css:</p>
<ol>
<li>ng-class=”name” css类绑定变量name</li>
<li>ng-class=”{true: ‘active’, false: ‘inactive’}[isActive]” 变量isActive为true时绑定active，为false时绑定inactive</li>
<li>ng-class=”{‘sty1’: active, ‘sty2’: inactive}” active为true增加sty1,inactive为true增加sty2</li>
<li>ng-class=”[sty1, sty2]”</li>
</ol>
<p><code>ng-include</code>用于包含外部的html文件，包含的内容将作为知指定元素的子节点<br><code>&lt;div ng-include=&quot;&#39;myfile.html&#39;&quot;&gt;</code> 注意：它是一个双引号和一个单引号<br><code>element ng-include=&quot;&#39;filename&#39;&quot; onload=&quot;&quot; autoscroll=&quot;&quot;</code><br><code>&lt;ng-include src=&quot;finelname&quot; onload=&quot;&quot; autoscroll=&quot;&quot;&gt;</code><br>onload 文件载入后执行的表达式<br>autoscroll 是否指定视图的可滚动</p>
<p><code>ng-repeat</code> 它里面有几个属性可以直接放html使用:<br>$index 序列号<br>$first 第一个元素是它是true,其它false ($last同理)<br>$middle 是否在中间<br>$even $index的值是否是偶数<br>$odd $index的值是否是奇数</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-app</span>=<span class="string">""</span> <span class="attr">ng-init</span>=<span class="string">"qu=1;pr=5"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">ng-model</span>=<span class="string">"qu"</span>&gt;</span><span class="tag">&lt;/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>angular.module(name,[requires],[configfn])</code> 一个参数是获取，一个以上是创建。</p>
<p>先用<code>ng-app</code>指定模块名，再用<code>angular.module</code>创建对应angular的模型。模型是当前元素拥有的作用域。<br>再用<code>ng-controller</code>指定控制名，再用<code>模型名.controller</code>创建对应angular的控制器。控制器是当前元素的控制器<br>最后用<code>$scope</code>来添加要控制的属性</p>
<p>每个模型有个<code>$rootScope</code>是根，是各个controller中scope的桥梁。</p>
<h3 id="angular-extend"><a href="#angular-extend" class="headerlink" title="angular.extend"></a>angular.extend</h3><p>对象第一层拷贝，如果第一层有属性则引用属性，返回结果<br><code>angular.extend(a, b, c) //依次将c和b的第一层属性拷贝给a，如果有属性则引用拷贝过去，返回a</code></p>
<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p><code>angular.module(&#39;phonecatApp&#39;, [&#39;phoneList&#39;]);</code> 这个表示<code>phonecatApp</code>是依赖<code>phoneList</code>的；可以引用里面的服务和组件等。<br>但是有个问题就是，在<code>html</code>它会被定义到后面的<code>DOM</code>元素覆盖。</p>
<h3 id="错误认识"><a href="#错误认识" class="headerlink" title="错误认识"></a>错误认识</h3><p><code>ng-repeat</code>和<code>ng-controller</code>不能放到同一元素(这个纠结了好久)，如果放都要用奇淫技巧。</p>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;lastName|lowercase&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>//小写转换</div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;lastName|uppercase&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>//大写转换</div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;lastName|currency&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> //数字格式化为货币格式</div><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">ng-repeat</span>=<span class="string">"x in names | orderBy:'country'"</span> /&gt;</span>//x是结构体有country属性。先按国家排序，再遍历 (angular-phonecat step-6就有个很好的例子，它按照选择来排序)</div><div class="line"></div><div class="line">#### 自定义过滤</div><div class="line">$scope.myfilter = function(item) &#123;return bool&#125;; //这个过滤必须返回bool类型，来表示此元素是否要被过滤掉。更注意的是它只能配合filter</div><div class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">ng-repeat</span>=<span class="string">"x in names | filter:myfilter"</span> /&gt;</span> //自定义函数过滤</div><div class="line"></div><div class="line">////////此外当想用此来传俩个参数时有个问题</div><div class="line">1.4版本的只能如此</div><div class="line">$scope.myfilter = function(a) &#123;</div><div class="line">    return function(x) &#123; return a==x;&#125;;//这里参数x很关键，返回的必须是`repeat`里面的循环变量,执行时才能访问到它,达到俩个数的效果</div><div class="line">&#125;</div><div class="line"></div><div class="line">1.6版本是支持多个参数的</div><div class="line">直接filter:myfilter(a, b);</div><div class="line">///////</div><div class="line"></div><div class="line">myApp.filter('replace', function() &#123;</div><div class="line">    return function(input, n1, n2) &#123; return datas;&#125;//这个过滤中则必须返回整个的数据。更注意它只能用于指令时，必须返回多个才行。</div><div class="line">&#125;);</div><div class="line">Result: &#123;&#123; yourinput | replace:3:'b' &#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>它封装了很多浏览器东西，来作为自己的内建服务。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">app.service(<span class="string">"customerserver"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.myFunc = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;&#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.controller(<span class="string">'customers'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope, $location, $http, $interval, customerserver</span>) </span>&#123;</div><div class="line">    $location.absUrl();<span class="comment">//当前页面的url</span></div><div class="line">    $http.get(<span class="string">""</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>));//请求数据</span></div><div class="line">    <span class="title">$interval</span>(<span class="params">function(</span>)&#123;&#125;, <span class="number">1000</span>);<span class="comment">//定时器</span></div><div class="line">    customerserver.myFunc(<span class="number">3</span>);<span class="comment">//自定义服务</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//自定义过滤使用自定义服务,注意传入的服务那块的代码</span></div><div class="line"><span class="keyword">var</span> app = angular.module(<span class="string">'myApp'</span>, []);</div><div class="line">app.service(<span class="string">'hexafy'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.myFunc = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">app.filter(<span class="string">'myFormat'</span>,[<span class="string">'hexafy'</span>, <span class="string">'$location'</span> ,<span class="function"><span class="keyword">function</span>(<span class="params">hexafy,$location</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> $location.absUrl();</div><div class="line">        <span class="keyword">return</span> hexafy.myFunc(x);</div><div class="line">    &#125;;</div><div class="line">&#125;]);</div><div class="line"></div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;255|myFormat&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>感觉里面的<code>$odd</code>等是内部的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;table&gt;</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">ng-repeat</span>=<span class="string">"x in names"</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">ng-if</span>=<span class="string">"$odd"</span> <span class="attr">style</span>=<span class="string">"background-color:#f1f1f1"</span>&gt;</span></div><div class="line">    &#123;&#123; x.Name &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">ng-if</span>=<span class="string">"$even"</span>&gt;</span></div><div class="line">    &#123;&#123; x.Name &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">ng-if</span>=<span class="string">"$odd"</span> <span class="attr">style</span>=<span class="string">"background-color:#f1f1f1"</span>&gt;</span></div><div class="line">    &#123;&#123; x.Country &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">ng-if</span>=<span class="string">"$even"</span>&gt;</span></div><div class="line">    &#123;&#123; x.Country &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">&lt;<span class="regexp">/table&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>必须先建个前缀代码自己的命名空间, 如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myApp.directive(<span class="string">'ddDrie'</span>, <span class="function"><span class="keyword">function</span> )  =&gt;  &lt;<span class="title">div</span> <span class="title">dd</span>-<span class="title">drie</span>...&gt; //以大写字符为界，前缀必须是小写，命名必须只有一个大写字符。</span></div></pre></td></tr></table></figure></p>
<p>一般属性:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'myApp'</span>, [])</div><div class="line">    .directive(<span class="string">'myDirective'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            restrict: <span class="string">'EA'</span>, <span class="comment">//E标签指令 A属性指令（默认） M注释 Cclass指令</span></div><div class="line">            priority: <span class="number">3</span>,<span class="comment">//优先级</span></div><div class="line">            terminal: <span class="literal">true</span>,<span class="comment">//执行此指令是否停止其它指令</span></div><div class="line">            template: <span class="string">'&lt;h2 class="head"&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;'</span>,<span class="comment">//输出类型</span></div><div class="line">            replace: <span class="literal">true</span>,<span class="comment">//是否替换，就上面的输出类型是否替换上html上的元素。否-html就包含</span></div><div class="line">            scope: <span class="literal">true</span>,<span class="comment">//这个属性传入bool时。默认false，true时会从父作用域创建一个自己的作用域</span></div><div class="line">            controllerAs: <span class="string">'ctrl'</span>,<span class="comment">//这个属性牛逼了。下面的scope例子中，controller自定义的变量只能在template或其他用 ctrl.name 来访问</span></div><div class="line">            bindToController: <span class="literal">true</span>,<span class="comment">//这个组件的属性都被绑定到controller上了而不是scope上面。可以视为继承到了父controller的同名的指定属性</span></div><div class="line">            scope: &#123;</div><div class="line">                <span class="comment">//这些属性要注意，头最好加上命名前缀</span></div><div class="line">                mytest1: <span class="string">'@'</span>, <span class="comment">//解析普通字符，即传入数据当字符处理</span></div><div class="line">                mytest2: <span class="string">'='</span>, <span class="comment">//解析数据，传入数据当数据处理</span></div><div class="line">                mytest3: <span class="string">'&amp;'</span>, <span class="comment">//解析函数, 传入数据当函数</span></div><div class="line">            &#125;,</div><div class="line">        &#125;;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="comment">////////////////scope例子</span></div><div class="line">&lt;body ng-app=<span class="string">"myApp"</span>&gt;</div><div class="line">	<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"mycc"</span>&gt;</span></span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">runoob-directive</span> <span class="attr">runoobst1</span>=<span class="string">"ww"</span> <span class="attr">runoobst2</span>=<span class="string">"name"</span> <span class="attr">runoobst3</span>=<span class="string">"show(3)"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">&lt;script&gt;</div><div class="line"><span class="keyword">var</span> app = angular.module(<span class="string">"myApp"</span>, []);</div><div class="line">app.controller(<span class="string">'mycc'</span>,[<span class="string">'$scope'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>)</span>&#123;</div><div class="line">    $scope.name = <span class="string">'xiecg'</span>;</div><div class="line">    $scope.show = <span class="function"><span class="keyword">function</span>(<span class="params">vvv</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> vvv;</div><div class="line">    &#125;;</div><div class="line">&#125;]);</div><div class="line">app.directive(<span class="string">"runoobDirective"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">		scope: &#123;</div><div class="line">			runoobst1: <span class="string">'@'</span>,</div><div class="line">			runoobst2: <span class="string">'='</span>,</div><div class="line">			runoobst3: <span class="string">'&amp;'</span></div><div class="line">		&#125;,</div><div class="line">		controller : [<span class="string">'$scope'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</div><div class="line">            $scope.name = <span class="string">'this is a xiecg'</span>;<span class="comment">//这个添属性,只能内部访问（想要访问只能用controllerAs属性）。不能当数据传入给runoobst2</span></div><div class="line">            $scope.hehe = <span class="string">"hehe"</span>;</div><div class="line">        &#125;],</div><div class="line">        template : <span class="string">'&lt;p&gt;&#123;&#123;runoobst1&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;runoobst2&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;  &lt;p&gt;&#123;&#123;runoobst3()&#125;&#125;&lt;/p&gt;'</span></div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h3><p>angular.isString();<br>angular.isNumber();</p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建 value 对象 "defaultInput" 并传递数据</span></div><div class="line">mainApp.value(<span class="string">"defaultInput"</span>, <span class="number">5</span>);</div><div class="line"><span class="comment">// 将 "defaultInput" 注入到控制器</span></div><div class="line">mainApp.controller(<span class="string">'CalcController'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope, CalcService, defaultInput</span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">mainApp.factory(<span class="string">'MathService'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">...</span>) </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</div><div class="line"></div><div class="line">mainApp.service(<span class="string">'CalcService'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">...</span>) </span>&#123; <span class="keyword">this</span>...=...; &#125;</div><div class="line"></div><div class="line">mainApp.constant(<span class="string">"configParam"</span>, <span class="string">"constant value"</span>);</div><div class="line"></div><div class="line">mainApp.config(<span class="function"><span class="keyword">function</span>(<span class="params">$provide</span>) </span>&#123;</div><div class="line">    $provide.provider(<span class="string">'Mprovider'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.$get = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> &#123;&#125;;&#125;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的注入，除了<code>config</code>有点特殊，其它都可以互相随意注入放置.</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>router的url：<a href="https://github.com/angular-ui/ui-router/wiki/URL-routing" target="_blank" rel="external">https://github.com/angular-ui/ui-router/wiki/URL-routing</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">url: <span class="string">"/contacts/:contactId"</span></div><div class="line">$stateParams.contactId = <span class="number">42</span>;</div></pre></td></tr></table></figure>
<hr>
<h3 id="module-run"><a href="#module-run" class="headerlink" title="module.run"></a>module.run</h3><p>config执行后就run，然后才是后面的</p>
<p>run可以直接注入config和provided，和controller差不多</p>
<h3 id="resource"><a href="#resource" class="headerlink" title="resource"></a>resource</h3><p>它封装了http，使的webapi连续等。<br>/:resource_id.:format 遇见<code>.</code>它会默认跳过,如:<code>/:resid/:fo.json</code></p>
<ul>
<li>第一个参数是url</li>
<li>第二个是为参数设置默认值；<ul>
<li><ol>
<li>url参数默认值，多余的会被添加到<code>?</code>后，即当做api参数 <code>e.g.给定模板/path/:verb与参数{verb:’greet’,salutation:’Hello’}，将得到URL/path/greet?salutation=Hello</code></li>
</ol>
</li>
<li><ol>
<li>参数以<code>@</code>为前缀,表示此属性的值，从调用第三个参数的结果对象中取对应的属性值。</li>
</ol>
</li>
</ul>
</li>
<li>第三个参数; {action: {method, params, isArray, headers…..}}</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> CreditCard = $resource(<span class="string">'/user/:userId/card/:cardId'</span>,</div><div class="line"> &#123;userId:<span class="number">123</span>, cardId:<span class="string">'@id'</span>&#125;, &#123;</div><div class="line">  charge: &#123;method:<span class="string">'POST'</span>, params:&#123;charge:<span class="literal">true</span>&#125;&#125;</div><div class="line"> &#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> cards = CreditCard.query(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//由于query是get数组，初始url是默认的</span></div><div class="line">  <span class="comment">// GET: /user/123/card</span></div><div class="line">  <span class="comment">// server returns: [ &#123;id:456, number:'1234', name:'Smith'&#125; ];</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> card = cards[<span class="number">0</span>];</div><div class="line">  card.name = <span class="string">"J. Smith"</span>;</div><div class="line">  card.$save();</div><div class="line">  <span class="comment">//上面返回结果了，直接用返回结果继续匹配</span></div><div class="line">  <span class="comment">// POST: /user/123/card/456 &#123;id:456, number:'1234', name:'J. Smith'&#125;</span></div><div class="line">  <span class="comment">// server returns: &#123;id:456, number:'1234', name: 'J. Smith'&#125;;</span></div><div class="line"></div><div class="line">  card.$charge(&#123;amount:<span class="number">9.99</span>&#125;);</div><div class="line">  <span class="comment">// POST: /user/123/card/456?amount=9.99&amp;charge=true &#123;id:456, number:'1234', name:'J. Smith'&#125;</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="modal的用法"><a href="#modal的用法" class="headerlink" title="$modal的用法"></a>$modal的用法</h3><ol>
<li>新版本的angular-ui-bootstrap, 是<code>$uimodal</code>和<code>$uimodalInstance</code></li>
<li>为了传递数据请多用resolve，scope属性会多建一个</li>
<li>注意下面代码中弹出类的三个参数传入</li>
</ol>
<p>angular弹出窗口，使用：<br>templateUrl: 模态窗口地址, 相应html用<code>id</code>标志<br>template：用于显示html标签<br>scope：一个作用域为模态的内容使用（事实上，$modal会创建一个当前作用域的子作用域）默认为$rootScope<br>controller：为$modal指定的控制器，初始化$scope，该控制器可用$modalInstance注入<br>resolve：定义一个成员并将他传递给$modal指定的控制器，相当于routes的一个reslove属性，如果需要传递一个objec对象，需要使用angular.copy()<br>backdrop：控制背景，允许的值：true（默认），false（无背景），“static” - 背景是存在的，但点击模态窗口之外时，模态窗口不关闭<br>keyboard：当按下Esc时，模态对话框是否关闭，默认为ture<br>windowClass：指定一个class并被添加到模态窗口中<br>open方法返回一个实例，该实例具有如下属性：<br>close(result)：关闭模态窗口并传递一个结果<br>dismiss(reason)：撤销模态方法并传递一个原因<br>result：一个契约，当模态窗口被关闭或撤销时传递<br>opened：一个契约，当模态窗口打开并且加载完内容时传递的变量</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/ng-template"</span> <span class="attr">id</span>=<span class="string">"myModalContent.html"</span> /&gt;</span><span class="handlebars"><span class="xml">  <span class="comment">&lt;!--这一段html对应templateUrl属性，注意--&gt;</span></span></span></div><div class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-header"</span>&gt;</span>  </div><div class="line">       <span class="tag">&lt;<span class="name">h3</span>&gt;</span>I'm a modal!<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>  </div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </div><div class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-body"</span>&gt;</span>  </div><div class="line">       <span class="tag">&lt;<span class="name">ul</span>&gt;</span>  </div><div class="line">           <span class="tag">&lt;<span class="name">li</span> <span class="attr">ng-repeat</span>=<span class="string">"item in items"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>  </span></div><div class="line">               <span class="attr">ng-click</span>=<span class="string">"selected.item = item"</span>&gt;<span class="template-variable">&#123;&#123; item &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>  </span></div><div class="line">       <span class="tag">&lt;/<span class="name">ul</span>&gt;</span>  </div><div class="line">       Selected: <span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="template-variable">&#123;&#123; selected.item &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span>  </span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </div><div class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-footer"</span>&gt;</span>  </div><div class="line">       <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> <span class="attr">ng-click</span>=<span class="string">"ok()"</span>&gt;</span>OK<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </div><div class="line">       <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-warning"</span> <span class="attr">ng-click</span>=<span class="string">"cancel()"</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </div><div class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">ng-click</span>=<span class="string">"open()"</span>&gt;</span>Open me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'ui.bootstrap.demo'</span>).controller(<span class="string">'ModalInstanceCtrl'</span>, </div><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">$scope,$modal, $modalInstance, items</span>) </span>&#123;<span class="comment">// 注意在这里的三个参数和 父类的resolve对应属性</span></div><div class="line">          $scope.items= items;<span class="comment">//这里必须要赋值，才能被html访问</span></div><div class="line">          $scope.selected = &#123;</div><div class="line">            item: items[<span class="number">0</span>] </div><div class="line">          &#125;;</div><div class="line">          $scope.ok = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            $modalInstance.close($scope.selected);</div><div class="line">          &#125;;</div><div class="line">          $scope.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            $modalInstance.dismiss(<span class="string">'cancel'</span>);</div><div class="line">          &#125;;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">$scope.open = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">        <span class="keyword">var</span> modalInstance = $modal.open(&#123;  </div><div class="line">            templateUrl : <span class="string">'myModalContent.html'</span>,  </div><div class="line">            controller : ModalInstanceCtrl,  </div><div class="line">            resolve : &#123;  </div><div class="line">                items : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">                    <span class="keyword">return</span> $scope.items;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;);  </div><div class="line">       </div><div class="line">        modalInstance.result.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;  </div><div class="line">            <span class="built_in">console</span>.log(result);  </div><div class="line">        &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;  </div><div class="line">            <span class="built_in">console</span>.log(reason);<span class="comment">// 点击空白区域，总会输出backdrop  </span></div><div class="line">            <span class="comment">// click，点击取消，则会暑促cancel  </span></div><div class="line">            $log.info(<span class="string">'Modal dismissed at: '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());  </div><div class="line">        &#125;);  </div><div class="line">    &#125;;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h4><p><code>ui-router</code>和<code>modal</code>都用到它，我就仔细看了下。<br>路由弹出也好，窗口弹出也是。为了让界面显示前准备好数据而使用这个属性(网络数据获取等)<br>它会在之前被设定好，再注入到控制器中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">resolve:&#123;</div><div class="line">    user:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            name:<span class="string">"perter"</span>,</div><div class="line">            email:<span class="string">"826415551@qq.com"</span>,</div><div class="line">            age:<span class="string">"18"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">app.controller(<span class="string">'myController'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$scope,user</span>)</span>&#123;</div><div class="line">    $scope.name=user.name;</div><div class="line">    $scope.age=user.age;</div><div class="line">    $scope.email=user.email;</div><div class="line">    $scope.user=user;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><h3 id="ng-options"><a href="#ng-options" class="headerlink" title="ng-options"></a>ng-options</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">ng-model</span>=<span class="string">"selectedItem"</span> <span class="attr">ng-options</span>=<span class="string">"item.name for item in items"</span>&gt;</span><span class="comment">&lt;!--从items选出item,把item.namee作为选项--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">ng-model</span>=<span class="string">"selectedItem"</span> <span class="attr">ng-options</span>=<span class="string">"item.age as item.name for item in items"</span>&gt;</span><span class="comment">&lt;!--从items选出item,把item.namee作为选项；然后绑定的selectedItem值,绑定到item.age上面（比如selectedItem = 2,它会自动替换到age为2的item的name上去）--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">ng-model</span>=<span class="string">"selectedItem"</span> <span class="attr">ng-options</span>=<span class="string">"item.name group by item.age for item in items"</span>&gt;</span><span class="comment">&lt;!--ng对选择多个分组属性。从items选出item,把item.age作为分组标准，把item.namee作为选项--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">ng-model</span>=<span class="string">"selectedItem"</span> <span class="attr">ng-options</span>=<span class="string">"color.name group by color.type disable when color.disabled for color in colors"</span>&gt;</span><span class="comment">&lt;!--同上，只是多了个禁用判断--&gt;</span></div><div class="line"></div><div class="line">$scope.countries = &#123;</div><div class="line">    CN: '中国China',</div><div class="line">    US: '美国United States',</div><div class="line">    UK: '英国United Kingdom',</div><div class="line">    GR: '德国Germany'</div><div class="line">&#125;;</div><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">ng-model</span>=<span class="string">"selectedItem"</span> <span class="attr">ng-options</span>=<span class="string">"k as v for (k, v) in countries"</span>&gt;</span><span class="comment">&lt;!--这个允许对象来选择。(k,v)表示这是个k-v类型，k做绑定 v做显示--&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">ng-model</span>=<span class="string">"selectedItem"</span> <span class="attr">ng-options</span>=<span class="string">"k as v for (k, v) in countries"</span>&gt;</span><span class="comment">&lt;!----&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">ng-model</span>=<span class="string">"selectedItem"</span> <span class="attr">ng-options</span>=<span class="string">"k as v for (k, v) in countries"</span>&gt;</span><span class="comment">&lt;!----&gt;</span></div></pre></td></tr></table></figure>
<h3 id="track-by"><a href="#track-by" class="headerlink" title="track by"></a>track by</h3><p>单独放一项是因为它和<code>ngoptions</code>/<code>ngrepeat</code>都相关。<br>但是我认为如果有个id我<code>ngoptions</code>何必用这个再去筛选，就没看。<br>主要说下<code>ngrepeat</code></p>
<ul>
<li><ol>
<li><code>&lt;div ng-repeat=&quot;link in links&quot; &gt;&lt;/div&gt;</code>当links=[“1”, “1”, “4”,”4”]时angular会报错，不允许重复<br>这时要么给这些加个属性id用来标志，”link in links track by link.id”<br>要么懒惰的用 “link in links track by $index”</li>
</ol>
</li>
<li><ol>
<li>还是上面的例子，当links发生变化时。必然会让删除已有dom，再重新添加新的。1.2添加的新机制会修改已有的不会重新创建。但是这个就只能用第一种方法了，不能再<code>$index</code>偷懒了。</li>
</ol>
</li>
</ul>
<h3 id="查找dom"><a href="#查找dom" class="headerlink" title="查找dom"></a>查找dom</h3><p><code>jqLite</code>太难用了，返回的还是它的对象。算了。</p>
<p>用这个，正好还可以找到属性对应的dom<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dd = angular.element(<span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>));</div><div class="line"><span class="keyword">var</span> dd = angular.element(<span class="built_in">document</span>.querySelector(<span class="string">'[id="ew"]'</span>));<span class="comment">//id="ew"的dom</span></div><div class="line"></div><div class="line"><span class="comment">//我才发现既然angular.element支持 css的选择器，那就可以用 `.modal-body input`这种css语法来选择呀。。。。。。晕！！太笨了。。</span></div></pre></td></tr></table></figure></p>
<h3 id="this和-scope"><a href="#this和-scope" class="headerlink" title="this和$scope"></a>this和$scope</h3><p>今天想起对比下这俩个：</p>
<ul>
<li><p>用<code>$scope</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dd</span>(<span class="params">$scope</span>) </span>&#123; $scope.test = <span class="string">"dd"</span>; &#125;</div><div class="line"></div><div class="line">&lt;div ng-controller=<span class="string">"dd"</span>&gt; &#123;&#123;test&#125;&#125; &lt;<span class="regexp">/div&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>用<code>this</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dd</span>(<span class="params"></span>) </span>&#123; <span class="keyword">var</span> vm = <span class="keyword">this</span>; <span class="keyword">this</span>.test = <span class="string">"dd"</span> ;&#125;</div><div class="line"></div><div class="line">&lt;div ng-controller=<span class="string">"dd as vm"</span>&gt; &#123;&#123;vm.test&#125;&#125;&lt;<span class="regexp">/div&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用起来一个麻烦js文件，一个麻烦html文件，但效果无异。</p>
<p><strong>但是区别在于</strong><br><code>$scope</code>可以访问到父类的<code>$scope</code>的属性和成员；但是当具有相同属性或成员时，<code>$scope</code>就拥有自己的空间，并不会覆盖。</p>
<p><em>angular思想</em><br><strong>Angular分俩个块儿：配置块和运行块(它更多的在于思想)</strong></p>
<p><strong>配置块</strong><br><code>angular.config</code> 这个会在配置块执行，然而上面的依赖注入只有<code>provider</code>才能在配置块被执行。<br>所以设计<code>provider</code>为初始化设置，<code>$get</code>返回一个对象，让所有注入</p>
<p><code>factory</code>要返回一个对象，所以一般被设为仅仅需要的是一个方法和数据的集合且不需要处理复杂的逻辑的时候<br><code>service</code>当使用在功能控制比较多的service里面</p>
<hr>
<h3 id="provide-decorator"><a href="#provide-decorator" class="headerlink" title="provide.decorator"></a>provide.decorator</h3><p>这个功能用于向已有的服务里面添加新的功能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Mail = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.receiver = <span class="string">''</span>;</div><div class="line">    <span class="keyword">this</span>.body = <span class="string">''</span>;</div><div class="line">    <span class="keyword">this</span>.cc = [];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Mail.prototype.setReceiver = <span class="function"><span class="keyword">function</span>(<span class="params">receiver</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.receiver = receiver;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Mail.prototype.setBody = <span class="function"><span class="keyword">function</span>(<span class="params">body</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.body = body;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">angular.module(<span class="string">'A'</span>, []).service(<span class="string">'Mail'</span>, Mail);</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'B'</span>, [<span class="string">'A'</span>]).config(<span class="function"><span class="keyword">function</span>(<span class="params">$provide</span>) </span>&#123;</div><div class="line">    $provide.decorator(<span class="string">'Mail'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$delegate</span>) </span>&#123;</div><div class="line">        $delegate.addCC = <span class="function"><span class="keyword">function</span>(<span class="params">cc</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.cc.push(cc);</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">return</span> $delegate;</div><div class="line">    &#125;);</div><div class="line">&#125;)</div><div class="line">.controller(<span class="string">'TestCtrl'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope, Mail</span>) </span>&#123;</div><div class="line">    Mail.addCC(<span class="string">'jack'</span>);<span class="comment">//这些mail服务就多了个调用函数</span></div><div class="line">    <span class="built_in">console</span>.log(Mail);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="provider笔记"><a href="#provider笔记" class="headerlink" title="provider笔记"></a>provider笔记</h4><p>初始化必须<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">angular.module()</div><div class="line">.provider(<span class="string">'linkAll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> l1 = <span class="string">''</span>;</div><div class="line">    <span class="keyword">var</span> l2 = <span class="string">''</span>;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.SetLinkTitle = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</div><div class="line">        l1 = v;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.SetLinkUrl = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</div><div class="line">        l2 = v;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.$get = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            linkTitle: l1,</div><div class="line">            linkUrl: l2,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在config对它访问和在控件对它访问是完全不一样的</span></div><div class="line">config ([<span class="string">'linkAllProvider'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">linkAllProvider</span>)</span>&#123; </div><div class="line">    linkAllProvider.SetLinkTitle(<span class="number">3</span>);</div><div class="line">    &#125;]);</div><div class="line"></div><div class="line">controller([<span class="string">'linkAll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">linkAll</span>) </span>&#123;linkAll.linkTitle;&#125;])</div></pre></td></tr></table></figure>
<h3 id="ocLazyLoad"><a href="#ocLazyLoad" class="headerlink" title="ocLazyLoad"></a>ocLazyLoad</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ocLazyLoadProvider.config(&#123;</div><div class="line">            debug: <span class="literal">true</span>, <span class="comment">//官方说这是为了oclazy向控制台输出信息</span></div><div class="line">            serie: <span class="literal">true</span>, <span class="comment">//当modules的多个模块文件全都互相依赖时，为了全部加载而在全局使用</span></div><div class="line">            modules: [&#123;</div><div class="line">                name: <span class="string">'kzts.modules.products.search'</span>,</div><div class="line">                files: [</div><div class="line">                    <span class="string">'/ts/modules/products/search/search.module.js'</span>,</div><div class="line">                    <span class="string">'/ts/modules/products/search/products-search.js'</span>,</div><div class="line">                    <span class="string">'/ts/modules/products/search/products-search-modal-controller.js'</span></div><div class="line">                ],</div><div class="line">                serie: <span class="literal">true</span> <span class="comment">//指定核心模块，当多个模块加载时，保证核心模块先被加载</span></div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                ... <span class="comment">//这些格式如上</span></div><div class="line">            &#125; ]</div><div class="line">        &#125;);</div><div class="line"></div><div class="line"><span class="comment">//.....</span></div><div class="line">         resolve: &#123;</div><div class="line">                loadModule: [<span class="string">'$ocLazyLoad'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$ocLazyLoad</span>) </span>&#123;</div><div class="line">                    <span class="keyword">return</span> $ocLazyLoad.load(<span class="string">'errorView'</span>);</div><div class="line">                &#125;]</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<h3 id="UI-Router"><a href="#UI-Router" class="headerlink" title="UI-Router"></a>UI-Router</h3><p>跳转方式<br>$state.go()<br>ng-href: 会<code>ng-href=&quot;/av/&quot;</code><br>ui-sref: 这个需要url那边配合 <a href="https://github.com/angular-ui/ui-router/wiki/URL-Routing#url-parameters" target="_blank" rel="external">https://github.com/angular-ui/ui-router/wiki/URL-Routing#url-parameters</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">url: <span class="string">'/users/:id/details/&#123;type&#125;/&#123;repeat:[0-9]+&#125;?from&amp;to'</span></div><div class="line"></div><div class="line"><span class="comment">// Then you navigated your browser to:</span></div><div class="line"><span class="string">'/users/123/details//0'</span></div><div class="line"></div><div class="line"><span class="comment">// Your $stateParams object would be</span></div><div class="line">&#123; id:<span class="string">'123'</span>, type:<span class="string">''</span>, repeat:<span class="string">'0'</span> &#125;</div></pre></td></tr></table></figure></p>
<p>href</p>
<ul>
<li><p>父子路由</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">.state(<span class="string">'blog'</span>, ...)</div><div class="line">.state(<span class="string">'blog.index'</span>, ...);</div><div class="line"><span class="comment">//通过名称中的一个`.` 来区分父子路由</span></div><div class="line"></div><div class="line">.state(<span class="string">'list'</span>, &#123;</div><div class="line">    parent: <span class="string">'contacts'</span>, <span class="comment">//指定父路由</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//子路由会继承父路由的依赖注入项</span></div><div class="line">resolve: &#123;rea:...&#125;</div><div class="line">resolve: &#123;reb:...&#125;</div><div class="line">conttroller: <span class="function"><span class="keyword">function</span>(<span class="params">rea, reb</span>) </span>&#123;...&#125;</div><div class="line"></div><div class="line"><span class="comment">//子路由会继承父路由的data属性，并可以重写</span></div><div class="line">$stateProvider.state(<span class="string">'parent'</span>, &#123;</div><div class="line">    data: &#123;...&#125;</div><div class="line">&#125;)</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ctrl</span>(<span class="params">$state</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log($state.current.data.customData1) <span class="comment">// outputs 5;</span></div><div class="line">    <span class="built_in">console</span>.log($state.current.data.customData2) <span class="comment">// outputs "blue";</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>abstract<br>官方说这个是为了方便定义虚拟的父，有段url是为所有子节点准备。<br>里面必须有<code>ui-view</code></p>
</li>
</ul>
<p><a href="https://github.com/angular-ui/ui-router/wiki/Nested-States-&amp;-Nested-Views" target="_blank" rel="external">https://github.com/angular-ui/ui-router/wiki/Nested-States-&amp;-Nested-Views</a></p>
<ul>
<li>views<br>当一个html出现多个<code>ui-view</code>时使用<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>=<span class="string">"filters"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>=<span class="string">"tabledata"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>=<span class="string">"graph"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">  .state(<span class="string">'report'</span>,&#123;</div><div class="line">    views: &#123;</div><div class="line">      <span class="string">'filters'</span>: &#123;</div><div class="line">        templateUrl: <span class="string">'report-filters.html'</span>,</div><div class="line">        controller: <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>)</span>&#123; ... controller stuff just <span class="keyword">for</span> filters view ... &#125;</div><div class="line">      &#125;,</div><div class="line">      <span class="string">'tabledata'</span>: &#123;</div><div class="line">        templateUrl: <span class="string">'report-table.html'</span>,</div><div class="line">        controller: <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>)</span>&#123; ... controller stuff just <span class="keyword">for</span> tabledata view ... &#125;</div><div class="line">      &#125;,</div><div class="line">      <span class="string">'graph'</span>: &#123;</div><div class="line">        templateUrl: <span class="string">'report-graph.html'</span>,</div><div class="line">        controller: <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>)</span>&#123; ... controller stuff just <span class="keyword">for</span> graph view ... &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<p>多视图的命名允许使用相对和绝对<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- index.html (root unnamed template) --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">ng-app</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!-- contacts.html plugs in here --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>=<span class="string">"status"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- contacts.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My Contacts<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>=<span class="string">"detail"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- contacts.detail.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Contacts Details<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>=<span class="string">"info"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">$stateProvider</div><div class="line">  .state(<span class="string">'contacts'</span>, &#123;</div><div class="line">    <span class="comment">// 根状态，对应的父模板则是index.html</span></div><div class="line">    <span class="comment">// 所以 contacts.html 将被加载到 index.html 中未命名的 ui-view 中</span></div><div class="line">    templateUrl: <span class="string">'contacts.html'</span>   </div><div class="line">    data: &#123;custom: <span class="number">5</span>&#125;</div><div class="line">  &#125;)</div><div class="line">  .state(<span class="string">'contacts.detail'</span>, &#123;</div><div class="line">    views: &#123;</div><div class="line">        <span class="comment">// 嵌套状态，对应的父模板是 contacts.html</span></div><div class="line"></div><div class="line">        <span class="comment">// 相对命名</span></div><div class="line">        <span class="comment">// contacts.html 中 &lt;div ui-view='detail'/&gt; 将对应下面</span></div><div class="line">        <span class="string">"detail"</span> : &#123; &#125;,   </div><div class="line">         </div><div class="line">        <span class="comment">// 相对命名</span></div><div class="line">        <span class="comment">// 对应 contacts.html 中的未命名 ui-view &lt;div ui-view/&gt;</span></div><div class="line">        <span class="string">""</span> : &#123; &#125;, </div><div class="line"></div><div class="line">        <span class="comment">// 绝对命名</span></div><div class="line">        <span class="comment">// 对应 contacts.detail.html 中 &lt;div ui-view='info'/&gt;</span></div><div class="line">        <span class="string">"info@contacts.detail"</span> : &#123; &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 绝对命名</span></div><div class="line">        <span class="comment">// 对应 contacts.html 中 &lt;div ui-view='detail'/&gt;</span></div><div class="line">        <span class="string">"detail@contacts"</span> : &#123; &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 绝对命名</span></div><div class="line">        <span class="comment">// 对应 contacts.html 中的未命名 ui-view &lt;div ui-view/&gt;</span></div><div class="line">        <span class="string">"@contacts"</span> : &#123; &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 绝对命名</span></div><div class="line">        <span class="comment">// 对应 index.html 中 &lt;div ui-view='status'/&gt; </span></div><div class="line">        <span class="string">"status@"</span> : &#123; &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 绝对命名</span></div><div class="line">        <span class="comment">// 对应 index.html 中 &lt;div ui-view/&gt;</span></div><div class="line">        <span class="string">"@"</span> : &#123; &#125; </div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">$state</span>) </span>&#123;</div><div class="line">      $state.current.data.custom;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>$urlRouterProvider</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$urlRouterProvider.when(<span class="string">''</span>, <span class="string">'/index'</span>);<span class="comment">// 把空路由重定向到 /index</span></div><div class="line">$urlRouterProvider.otherwise(<span class="string">'/index'</span>);<span class="comment">//重定向无效路由</span></div></pre></td></tr></table></figure>
<h2 id="最后给个api查询-：-https-github-com-angular-ui-ui-router-wiki-Quick-Reference"><a href="#最后给个api查询-：-https-github-com-angular-ui-ui-router-wiki-Quick-Reference" class="headerlink" title="最后给个api查询 ##： https://github.com/angular-ui/ui-router/wiki/Quick-Reference"></a>最后给个api查询 ##： <a href="https://github.com/angular-ui/ui-router/wiki/Quick-Reference" target="_blank" rel="external">https://github.com/angular-ui/ui-router/wiki/Quick-Reference</a></h2><h4 id="多个视图"><a href="#多个视图" class="headerlink" title="多个视图"></a>多个视图</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--main.html--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./angular.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./angular-ui-router.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./App2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">data-ng-app</span>=<span class="string">"myApp"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>多ui-view<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>=<span class="string">"chart"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>=<span class="string">"data"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myApp = angular.module(<span class="string">"myApp"</span>, [<span class="string">"ui.router"</span>]);</div><div class="line">myApp.config(<span class="function"><span class="keyword">function</span> (<span class="params">$stateProvider, $urlRouterProvider</span>) </span>&#123;</div><div class="line">    $urlRouterProvider.when(<span class="string">""</span>, <span class="string">"/home"</span>);</div><div class="line">    $stateProvider.state(<span class="string">"home"</span>, &#123;</div><div class="line">            url: <span class="string">"/home"</span>,</div><div class="line">            views: &#123;</div><div class="line">                <span class="string">""</span>: &#123;</div><div class="line">                    template: <span class="string">"&lt;h1&gt;HELLO!&lt;/h1&gt;"</span></div><div class="line">                &#125;,</div><div class="line">                <span class="string">"chart"</span>: &#123;</div><div class="line">                    template: <span class="string">"chart"</span></div><div class="line">                &#125;,</div><div class="line">                <span class="string">"data"</span>: &#123;</div><div class="line">                    template: <span class="string">"data"</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .state(<span class="string">"index"</span>, &#123;</div><div class="line">            url: <span class="string">"/index"</span>,</div><div class="line">            views: &#123;</div><div class="line">                <span class="string">""</span>: &#123;</div><div class="line">                    template: <span class="string">"&lt;h1&gt;HELLO!&lt;/h1&gt;"</span></div><div class="line">                &#125;,</div><div class="line">                <span class="string">"data"</span>: &#123;</div><div class="line">                    template: <span class="string">"data-index"</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;)   </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="多层视图"><a href="#多层视图" class="headerlink" title="多层视图"></a>多层视图</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--main.html--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./angular.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./angular-ui-router.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./App.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">data-ng-app</span>=<span class="string">"myApp"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>AngularJS Home Page (Ui-router Demonstration)<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// App.js</span></div><div class="line"><span class="keyword">var</span> myApp = angular.module(<span class="string">"myApp"</span>, [<span class="string">"ui.router"</span>]);</div><div class="line">myApp.config(<span class="function"><span class="keyword">function</span> (<span class="params">$stateProvider, $urlRouterProvider</span>) </span>&#123;</div><div class="line">     $urlRouterProvider.when(<span class="string">""</span>, <span class="string">"/PageTab"</span>); </div><div class="line">     $stateProvider</div><div class="line">        .state(<span class="string">"PageTab"</span>, &#123;       <span class="comment">//这个有个缺点，就是没有默认指定view的显示页。有俩种方法</span></div><div class="line">            url: <span class="string">"/PageTab"</span>,      <span class="comment">//1、 在PageTab里面加$state.transitionTo('PageTab.Page1');来显示指定显示页</span></div><div class="line">            templateUrl: <span class="string">"PageTab.html"</span><span class="comment">//2. 使用abstract,向父view添加abstract=true属性。但是要设置跳转页面when('', '/PageTab/Page1')，因为直接跳转到父页面是无法显示的。</span></div><div class="line">        &#125;)</div><div class="line">        .state(<span class="string">"PageTab.Page1"</span>, &#123;</div><div class="line">            url:<span class="string">"/Page1"</span>,</div><div class="line">            templateUrl: <span class="string">"Page1.html"</span></div><div class="line">        &#125;)</div><div class="line">        .state(<span class="string">"PageTab.Page2"</span>, &#123;</div><div class="line">            url:<span class="string">"/Page2"</span>,</div><div class="line">            templateUrl: <span class="string">"Page2.html"</span></div><div class="line">        &#125;)</div><div class="line">        .state(<span class="string">"PageTab.Page3"</span>, &#123;</div><div class="line">            url:<span class="string">"/Page3"</span>,</div><div class="line">            templateUrl: <span class="string">"Page3.html"</span></div><div class="line">        &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- PageTab.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"width:100px"</span> <span class="attr">ui-sref</span>=<span class="string">".Page1"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>Page-1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"width:100px"</span> <span class="attr">ui-sref</span>=<span class="string">".Page2"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>Page-2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"width:100px"</span> <span class="attr">ui-sref</span>=<span class="string">".Page3"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>Page-3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">ui-view</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- Page1.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Page 1 content goes here...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- Page2.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Page 2 content goes here...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- Page3.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Page 3 content goes here...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h3><p>可以作过滤使用<br>可以作属性使用<br>还可以指定参数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">VARBLE: <span class="string">'HI, &#123;name&#125;'</span> <span class="comment">//字典</span></div><div class="line"></div><div class="line">&lt;p translate=<span class="string">"VARBLE"</span> translate-values=<span class="string">"&#123;name:'wq'&#125;"</span> /&gt;<span class="comment">// HI, wq</span></div></pre></td></tr></table></figure></p>
<p><code>translations</code>注册<br><code>preferredLanguage</code>选择默认语言。 等同<code>use</code><br><code>fallbackLanguage</code> 动态切换语言时，先fall再use就好了。</p>
<p><code>useLocalStorage</code> 为了方便快速切换，提供storage来。localstorage依赖cookiestorage。</p>
<p><code>useStaticFilesLoader</code> 使用静态文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$translateProvider.useStaticFilesLoader(&#123;</div><div class="line">    files: [&#123;</div><div class="line">        prefix: <span class="string">'/locale/'</span>,</div><div class="line">        suffix: <span class="string">'tt.json'</span></div><div class="line">    &#125;, &#123;</div><div class="line">        prefix: <span class="string">'/absolute/path/to/locale-'</span>, <span class="comment">//locale-en locale-cn</span></div><div class="line">        suffix: <span class="string">'.json'</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">$translateProvider.preferredLanguage(<span class="string">'en'</span>);</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jquery215]]></title>
      <url>https://xuecat.github.io/2017/02/21/215/</url>
      <content type="html"><![CDATA[<h3 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h3><p>其它不说，hide和show的参数有个speed，可以动画执行显示。<br>toggle来切换元素显示和隐藏,和上面一样也有个speed。</p>
<h3 id="特效"><a href="#特效" class="headerlink" title="特效"></a>特效</h3><p>可以加特效：<br>fade类型的函数是淡入淡出（有透明度）<br>slide类型的函数是滑入滑出<br>animate类型函数。可以设height:’toggle’ (默认情况下，所有的 HTML 元素有一个静态的位置，且是不可移动的。 如果需要改变为，我们需要将元素的 position 属性设置为 relative, fixed, 或 absolute!)</p>
<h3 id="方法链"><a href="#方法链" class="headerlink" title="方法链"></a>方法链</h3><p>jquery方法链<code>$(&quot;#p1&quot;).css(&quot;color&quot;, &quot;red&quot;).slideUp(200).slideDown(&#39;fast&#39;);</code></p>
<h3 id="dom属性获取和设置"><a href="#dom属性获取和设置" class="headerlink" title="dom属性获取和设置"></a>dom属性获取和设置</h3><p>dom获取和设置。<br>text()设置和获取文本，获取会自动连接子文本、<br>html()设置和获取的文本包括html、<br>val()设置和获取value属性值、<br>attr()设置和获取属性对应值，感觉这个可以替换val</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $(<span class="string">"#runoob"</span>).attr(&#123;</div><div class="line">        <span class="string">"href"</span> : <span class="string">"http://www.runoob.com/jquery"</span>,</div><div class="line">        <span class="string">"title"</span> : <span class="string">"jQuery 教程"</span></div><div class="line">    &#125;);</div><div class="line">    $(<span class="string">"#runoob"</span>).attr(<span class="string">"href"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">i,origValue</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> origValue + <span class="string">"/jquery"</span>; </div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="添加新元素"><a href="#添加新元素" class="headerlink" title="添加新元素"></a>添加新元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendText</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> txt1=<span class="string">"&lt;p&gt;文本。&lt;/p&gt;"</span>;              <span class="comment">// 使用 HTML 标签创建文本</span></div><div class="line">    <span class="keyword">var</span> txt2=$(<span class="string">"&lt;p&gt;&lt;/p&gt;"</span>).text(<span class="string">"文本。"</span>);  <span class="comment">// 使用 jQuery 创建文本</span></div><div class="line">    <span class="keyword">var</span> txt3=<span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</div><div class="line">    txt3.innerHTML=<span class="string">"文本。"</span>;               <span class="comment">// 使用 DOM 创建文本 text with DOM</span></div><div class="line">    $(<span class="string">"body"</span>).append(txt1,txt2,txt3);        <span class="comment">// 追加新元素</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>remove()删除包括本身,接收参数css选择器<br>empty()删除不包括本身,接收参数css选择器</p>
<h3 id="css类设置"><a href="#css类设置" class="headerlink" title="css类设置"></a>css类设置</h3><p>addClass() 添加<br>removeClass()<br>toggleClass() 添加和删除切换<br>css() 设置和返回css <code>css({&quot;background-color&quot;:&quot;yellow&quot;,&quot;font-size&quot;:&quot;200%&quot;});</code></p>
<p>这里css好像只能用类<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"h1,h2,p"</span>).addClass(<span class="string">"blue"</span>);</div><div class="line">.blue</div><div class="line">&#123; ... &#125;</div></pre></td></tr></table></figure></p>
<h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><p>outerWidth(true) //包括margin及全部<br>outerWidth()     //不包括margin,包括border及剩下<br>innerWidth()     //不包括border,包括padding及剩下<br>width()          //只包括element<br>高度类似。</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>返回数组元素的函数都允许参数返回指定.<br>parent(); 单个元素<br>parents();数组元素,允许参数返回指定<code>parents(&quot;.hehe&quot;)</code><br>parentsUntil(); 数组元素, 返回介于俩个给定元素之间的所有祖先元素，如<code>parentsUntil(&quot;div&quot;);</code><br>children() 数组元素,允许参数返回指定<code>children(&quot;.hehe&quot;)</code><br>find(…) 单个元素,从后代元素寻找,包含自己<br>siblings(); 数组元素,返回被选元素的所有同胞元素，允许参数返回指定<br>next(); 单个元素,返回被选元素下一个同胞元素<br>nextAll(); 数组元素,返回接下来所有同胞元素<br>nextUntil(); 数组元素,返回参数指定元素之间所有接下来的同胞元素<code>nextUntil(&quot;h6&quot;)</code></p>
<p>first(); 返回被选元素第一个元素<br>last(); 返回被选元素最后一个元素<br>eq(); <code>eq(0)</code>就是第一个 <code>eq(1)</code>第二个<br>filter(); 再次过滤 <code>$(&quot;p&quot;).filter(&quot;.url&quot;);</code><br>not(); <code>$(&quot;p&quot;).not(&quot;.url&quot;);</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[css笔记214]]></title>
      <url>https://xuecat.github.io/2017/02/18/214/</url>
      <content type="html"><![CDATA[<h3 id="很多css属性，在IE8之前必须声明-lt-DOCTYPE-gt"><a href="#很多css属性，在IE8之前必须声明-lt-DOCTYPE-gt" class="headerlink" title="很多css属性，在IE8之前必须声明&lt;!DOCTYPE&gt;"></a>很多css属性，在IE8之前必须声明&lt;!DOCTYPE&gt;</h3><h3 id="css选择器构成"><a href="#css选择器构成" class="headerlink" title="css选择器构成"></a>css选择器构成</h3><p>css具有层叠特性，后面属性会掩盖前面属性</p>
<p>css构成：<br>选择器 {属性:值; 属性:值}</p>
<p>属性选择器: html的属性 h1/p 之类</p>
<p>id选择器：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#paral</div><div class="line">&#123;</div><div class="line">    text-align:center;</div><div class="line">    color:red;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;p id="paral"&gt;hello&lt;/p&gt;</div></pre></td></tr></table></figure></p>
<p>class选择器(类名第一个字符不能使用数字):<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.center </div><div class="line">&#123;</div><div class="line">    text-align:center;</div><div class="line">&#125;</div><div class="line">&lt;p class="center"&gt;标题&lt;/p&gt;</div><div class="line"></div><div class="line">p.center/*它还有个嵌套选择器与它长得很像，但完全不同。下面有讲*/</div><div class="line">&#123;</div><div class="line">    text-align:center;</div><div class="line">&#125;</div><div class="line">&lt;p class="center"&gt;这个要居中（且不能缺少class属性）&lt;/p&gt;</div><div class="line">&lt;h1 class="center"&gt;这个不居中&lt;/h1&gt;</div></pre></td></tr></table></figure></p>
<p><code>:</code>选择器:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>:red; <span class="attribute">text-decoration</span>:...&#125;     <span class="comment">/*所有未被访问的链接，一般用于&lt;a/&gt; 但也可用于其他dom，如: &lt;p/&gt;*/</span></div><div class="line"><span class="selector-pseudo">:visited</span>  <span class="comment">/*所有已被访问链接，同上*/</span></div><div class="line"><span class="selector-pseudo">:active</span>     <span class="comment">/*活动链接，同上*/</span></div><div class="line"><span class="selector-pseudo">:hover</span>     <span class="comment">/**/</span></div><div class="line"><span class="selector-pseudo">:focus</span>     <span class="comment">/**/</span></div></pre></td></tr></table></figure></p>
<p>其它选择器：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">/*后代选择器*/</div><div class="line">a p /*a子元素下的p*/</div><div class="line">&#123;</div><div class="line">    color: green;</div><div class="line">&#125;</div><div class="line">ul li /*ul子元素下的li*/</div><div class="line">&#123;</div><div class="line">    background-repeat: no-repeat;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*分组选择器*/</div><div class="line">h1, h2, p</div><div class="line">&#123;...&#125;</div><div class="line"></div><div class="line">table, th, td</div><div class="line">&#123;</div><div class="line">    border: 1px solid black;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*嵌套选择器*/</div><div class="line">.marked</div><div class="line">&#123; background-color: red; &#125;</div><div class="line">.marked p</div><div class="line">&#123; color: white; &#125;</div><div class="line"></div><div class="line">&lt;div class="marked"&gt;&lt;p&gt;ddd&lt;/p&gt;&lt;/div&gt;/*class为marked的元素，其子元素为p的会得到此css属性*/</div><div class="line"></div><div class="line">/*子元素选择器*/</div><div class="line">div&gt;p</div><div class="line">&#123; background-color: yellow; &#125; /*它会严格按照div&gt;p的层次顺序来找元素*/</div><div class="line"></div><div class="line">/*相邻兄弟选择器*/</div><div class="line">div+p+p</div><div class="line">&#123; background-color: yellow; &#125; /*它只会让div第二个相邻p元素的style改变*/</div><div class="line"></div><div class="line">/*普通相邻兄弟选择器*/</div><div class="line">div~p</div><div class="line">&#123; background-color: yellow; &#125; /*上面的选择器只能选择一个，这个会把所有具有此关系的元素选上*/</div><div class="line"></div><div class="line">/*属性选择器*/</div><div class="line">[title]</div><div class="line">&#123; color: blue; &#125; /*选择具有title属性的元素*/</div><div class="line"></div><div class="line">[title=runoob]</div><div class="line">&#123; color: blue; &#125; /*选择title属性的值为runoob的元素*/</div><div class="line"></div><div class="line">[title~=hello]</div><div class="line">&#123; color: blue; &#125; /*选择title属性的值包含有hello单词的元素,即hello有空格隔开就算包含*/</div><div class="line"></div><div class="line">[title|=hello]</div><div class="line">&#123; color: blue; &#125; /*选择title属性的值包含有hello的元素,只要有hello出现就行*/</div></pre></td></tr></table></figure></p>
<h3 id="插入样式表"><a href="#插入样式表" class="headerlink" title="插入样式表"></a>插入样式表</h3><p>外部插入样式表：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"mystyle.css"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>内部插入样式表：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-tag">hr</span> &#123;<span class="attribute">color</span>:sienna;&#125;</div><div class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>:<span class="number">20px</span>;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>内联样式：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:sienna;margin-left:20px"</span>&gt;</span>this is<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>多重样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h3</span></div><div class="line">&#123;</div><div class="line">    <span class="attribute">color</span>:red;</div><div class="line">    <span class="attribute">text-align</span>:left;</div><div class="line">    <span class="attribute">font-size</span>:<span class="number">8pt</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">h3</span></div><div class="line">&#123;</div><div class="line">    <span class="attribute">text-align</span>:right;</div><div class="line">    <span class="attribute">font-size</span>:<span class="number">20pt</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它们将会重叠成一个。</p>
<p>层叠次序：</p>
<p>内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器缺省设置<br>这些层叠会继续替换和补充。</p>
<p>###　属性<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">background-repeat: no-repeat|repeat-x|repeat-y;/*背景图片重复平铺的方向*/</div><div class="line">text-decoration: overline|line-through|underline;/*文字的横线位置(上方，中，下方)*/</div><div class="line">text-transform: uppercase|lowercase|capitalize;/*文字转换(大写，小写，首字母大写)*/</div><div class="line">text-indent: *px;/*文本第一行的缩进*/</div><div class="line">font-size: *em;/*为避免ie无法调整文本问题，使用em单位代替*/</div><div class="line">a: link &#123;color:#FF0000;text-decoration:underline;&#125;</div><div class="line">list-style-type: circle|square|upper-roman|lower-alpha;/*列表标题 无序和有序*/</div><div class="line">border: 25px solid green;</div><div class="line">border-style: dotted|dashed|solid|double|groove|ridge|inset|outset;/*电线框、虚线框、实线、俩个边界、3d沟(有四个重载函数：上、右、下、左；上、左右、下；上下、左右；四边)*/</div><div class="line">margin: /*重载：上、右、下、左；上、左右、下；上下、左右；四边;;auto中心对齐*/</div><div class="line">Padding: /*同上*/</div><div class="line">display: inline|block; /*只需要宽度，不强制换行；占用全部宽高，前后换行*/</div><div class="line">position: fixed|relative|absolute /*相对浏览器窗口；相对自己的定位；相对父元素的定位。配合z-index来重叠*/</div></pre></td></tr></table></figure></p>
<h3 id="盒子"><a href="#盒子" class="headerlink" title="盒子"></a>盒子</h3><p>从外到内： Margin  Border  Padding  Content</p>
<h3 id="隐藏元素"><a href="#隐藏元素" class="headerlink" title="隐藏元素"></a>隐藏元素</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">display</span>: <span class="selector-tag">none</span>;<span class="comment">/*隐藏某个元素，且元素不会占用任何空间*/</span></div><div class="line"><span class="selector-tag">visibility</span>: <span class="selector-tag">hidden</span>;<span class="comment">/*隐藏元素，但是隐藏的元素任占用与未隐藏前一样的空间*/</span></div></pre></td></tr></table></figure>
<h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>这个也是个选择器<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">p:first-child /*这个会指定到第一个p元素*/</div><div class="line">&#123; color: blue; &#125;</div><div class="line">p &gt; i:first-child /*第一个为p的子元素的i*/</div><div class="line">&#123; color: blue; &#125;</div><div class="line">&lt;p&gt;I am a &lt;i&gt;zhege&lt;/i&gt; man. I am a &lt;i&gt;strong&lt;/i&gt; man.&lt;/p&gt;</div><div class="line">&lt;p&gt;I am a &lt;i&gt;zhege&lt;/i&gt; man. I am a &lt;i&gt;strong&lt;/i&gt; man.&lt;/p&gt;</div></pre></td></tr></table></figure></p>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.button </div><div class="line">&#123;</div><div class="line">    background-color: #4caf50;</div><div class="line">&#125;</div><div class="line">.button2</div><div class="line">&#123;</div><div class="line">    color: white;</div><div class="line">&#125;</div><div class="line">&lt;button class="button button2" /&gt; /*这样就具有俩个属性了*/</div></pre></td></tr></table></figure>
<h3 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h3><p>这儿类名字限定了，必须如此。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.dropdown</span> &#123;&#125; <span class="comment">/* 容器 &lt;div&gt; - 需要定位下拉内容 */</span></div><div class="line"><span class="selector-class">.dropbtn</span> &#123;&#125; <span class="comment">/* 下拉按钮样式 */</span></div><div class="line"><span class="selector-class">.dropdown-content</span> &#123;&#125; <span class="comment">/* 下拉内容 (默认隐藏) */</span></div><div class="line"></div><div class="line"><span class="comment">/* 下拉菜单的链接 */</span></div><div class="line"><span class="selector-class">.dropdown-content</span> <span class="selector-tag">a</span> &#123;</div><div class="line">    <span class="attribute">color</span>: black;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">12px</span> <span class="number">16px</span>;</div><div class="line">    <span class="attribute">text-decoration</span>: none;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 鼠标移上去后修改下拉菜单链接颜色 */</span></div><div class="line"><span class="selector-class">.dropdown-content</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">background-color</span>: <span class="number">#f1f1f1</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 在鼠标移上去后显示下拉菜单 */</span></div><div class="line"><span class="selector-class">.dropdown</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.dropdown-content</span> &#123;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 当下拉内容显示后修改下拉按钮的背景颜色 */</span></div><div class="line"><span class="selector-class">.dropdown</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.dropbtn</span> &#123;</div><div class="line">    <span class="attribute">background-color</span>: <span class="number">#3e8e41</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>设置透明:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">img</span> &#123; <span class="attribute">opacity</span>: <span class="number">0.4</span>; <span class="attribute">filter</span>: <span class="built_in">alpha</span>(opcity=1)&#125; <span class="comment">/*一般是0.0-1.0,越小越透明。ie8和早期版本是0-100,越小越透明*/</span></div></pre></td></tr></table></figure></p>
<p>拼合:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">img</span><span class="selector-class">.home</span> </div><div class="line">&#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">46px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">44px</span>;<span class="comment">/*上面是指定显示图片的高宽*/</span></div><div class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(...) <span class="number">0</span> <span class="number">0</span>;<span class="comment">/*指定显示图片的路径和位置left top*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="图片廊"><a href="#图片廊" class="headerlink" title="图片廊"></a>图片廊</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"responsive"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">href</span>=<span class="string">"img_fjords.jpg"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.runoob.com/wp-content/uploads/2016/04/img_fjords.jpg"</span> <span class="attr">alt</span>=<span class="string">"Trolltunga Norway"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"desc"</span>&gt;</span>这里添加图片文本描述<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="css3"><a href="#css3" class="headerlink" title="css3"></a>css3</h2><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>圆角: border-radius<br>阴影：border-shadow<br>图片: border-image<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#round</span></div><div class="line">&#123;</div><div class="line">	<span class="attribute">-webkit-border-image</span>:<span class="built_in">url</span>(border.png) <span class="number">30</span> <span class="number">30</span> round; <span class="comment">/* Safari 5 and older */</span></div><div class="line">	<span class="attribute">-o-border-image</span>:<span class="built_in">url</span>(border.png) <span class="number">30</span> <span class="number">30</span> round; <span class="comment">/* Opera */</span></div><div class="line">	<span class="attribute">border-image</span>:<span class="built_in">url</span>(border.png) <span class="number">30</span> <span class="number">30</span> round;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DockPanelSuite213]]></title>
      <url>https://xuecat.github.io/2017/02/16/213/</url>
      <content type="html"><![CDATA[<p><img src="/picture/213.jpg" alt=""></p>
<p>深读了后，不得不说太佩服作者了。</p>
<p>1、 MainForm去掉SetSplashScreen函数，去掉开始的登录显示。</p>
<p>2、 Measures.cs 这里修改拖拽的最小边界</p>
<p>3、 DockPanel.DockDragHandler.cs里的DockIndicator就是拖拽显示的小坐标<br>这里面的TestDrop函数处理拖拽过程中小坐标的停靠，以及拖拽过程的阴影。<br>RefreshChanges处理是否显示停靠阴影。</p>
<p>4、 结构<br>panel是整个的大框架，里面由dockwindow构成；<br>dockwindow有6种：停靠，中间的docment，上，下，左，右。<br>dockwindow由dockpane构成，表示分布的窗口。</p>
<p>最后dockcontent整合所有的事件及pane被继承下去。</p>
<p>5、 <strong>一开始的就可以设置。</strong> 我调试了很久，发现这个程序有另外个模式，把所有的DockAreas加上docment（即保证dockcontent.cs的DockAreas的set那）<br>这样中间那块就会被panel填充，就可以支持全布局了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c++日常(212)]]></title>
      <url>https://xuecat.github.io/2017/02/11/212/</url>
      <content type="html"><![CDATA[<h3 id="for循环写法"><a href="#for循环写法" class="headerlink" title="for循环写法"></a>for循环写法</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;)</div><div class="line">&#123; &#125;</div></pre></td></tr></table></figure>
<p> 常数级的循环只能这样写了，感觉还好吧。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> p[<span class="number">5</span>];</div><div class="line"><span class="function"><span class="keyword">for</span> <span class="title">each</span><span class="params">(<span class="keyword">int</span> i in p)</span></span></div></pre></td></tr></table></figure>
<p> 这个常数级的循环真心没法优雅，留着以后再试试吧。</p>
<h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> pa = <span class="number">4</span>;</div><div class="line"><span class="keyword">int</span> *p[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">p[<span class="number">0</span>] = &amp;pa;</div><div class="line"><span class="keyword">int</span> **pp[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">pp[<span class="number">0</span>] = &amp;p[<span class="number">0</span>];</div></pre></td></tr></table></figure>
<p> 这是数组，不是指针</p>
<h3 id="RVO和NRVO"><a href="#RVO和NRVO" class="headerlink" title="RVO和NRVO"></a>RVO和NRVO</h3><p>Return Value Optimization 返回值优化<br>Named Return Value Optimization 命名返回值优化</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BigObject</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function">BigObject <span class="title">foo</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">return</span> BigObject(); <span class="comment">// RVO </span></div><div class="line">   <span class="comment">//以前看effective的时候讲了这里要产生临时变量</span></div><div class="line">   <span class="comment">//然后再执行拷贝函数</span></div><div class="line">   <span class="comment">//现在编译器智能了，它会优化这一段，自动去掉临时变量，只会走一次构造函数 </span></div><div class="line">   <span class="comment">//即 BigObject tt = fOO(); 这个过程只会调用一次构造函数(vs2015 release debug都只走一次)</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">BigObject <span class="title">bar</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  BigObject localObj;</div><div class="line">  <span class="keyword">return</span> localObj; <span class="comment">// NRVO</span></div><div class="line">  <span class="comment">//同上，以前的技术只支持匿名变量的优化，现在高档了，支持实名变量的优化</span></div><div class="line">  <span class="comment">//即 BigObject tt = bar(); vs2015 release 下只走一次构造函数，debug下 走一次构造函数，走一次拷贝函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="变长参数传递"><a href="#变长参数传递" class="headerlink" title="变长参数传递"></a>变长参数传递</h3><p>  一开始我想用<code>va_list</code>，但是感觉一点都不酷就google了下.<br>  让我惊讶的是vs15支持三点运算符(和js不同，它的符号放后面)</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... arg&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">funa</span><span class="params">(T t, arg... ars)</span></span></div><div class="line">&#123;</div><div class="line">fuu(ars...);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fuu</span><span class="params">(<span class="keyword">int</span> t, ...)</span><span class="comment">//牛逼，自动解构，这里</span></span></div><div class="line">&#123;</div><div class="line">va_list <span class="built_in">list</span>;</div><div class="line">va_start(<span class="built_in">list</span>, t);</div><div class="line"><span class="keyword">int</span> arg = va_arg(<span class="built_in">list</span>, <span class="keyword">int</span>);<span class="comment">//这里是3 funa抢一个， t抢一个</span></div><div class="line"> va_end(<span class="built_in">list</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">funa(<span class="number">1</span>, <span class="number">2</span>, ,<span class="number">3</span> , <span class="string">"afdf"</span>);</div></pre></td></tr></table></figure>
<h3 id="c-11-decltype"><a href="#c-11-decltype" class="headerlink" title="c++11 decltype"></a>c++11 decltype</h3><p>  动态类型:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ci = <span class="number">3</span>， &amp;cj=ci;</div><div class="line"><span class="keyword">decltype</span>(ci) d;<span class="comment">//这是个int</span></div><div class="line"><span class="keyword">decltype</span>(cj) f = d;<span class="comment">//这是个int&amp;,必须初始化</span></div></pre></td></tr></table></figure></p>
<p>  他的动态类型已经可以和<code>auto</code>媲美了。但有点意思的是它对括号敏感<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">2</span>, f = <span class="number">3</span>;</div><div class="line"><span class="keyword">decltype</span>((a)) b = f; <span class="comment">//b是int&amp;类型</span></div><div class="line"><span class="keyword">decltype</span>(((a))) d = f;<span class="comment">//d也是int&amp;类型</span></div></pre></td></tr></table></figure></p>
<p>  <code>decltype(func())</code>并不会执行<code>func</code>函数,只是要它返回类型推导</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[effective javsscript(211)]]></title>
      <url>https://xuecat.github.io/2017/02/11/211/</url>
      <content type="html"><![CDATA[<h2 id="js的值类型和引用类型"><a href="#js的值类型和引用类型" class="headerlink" title="js的值类型和引用类型"></a>js的值类型和引用类型</h2><p>值类型：数值、布尔、null、undefined<br>引用类型：对象、数组、函数</p>
<h3 id="js的值类型和引用类型-1"><a href="#js的值类型和引用类型-1" class="headerlink" title="js的值类型和引用类型"></a>js的值类型和引用类型</h3><p>值类型：数值、布尔、null、undefined<br>引用类型：对象、数组、函数</p>
<h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><p><code>typeof</code> 返回字符串<br><code>instanceof</code> 后接类型，返回bool</p>
<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><ol>
<li>(1+2)+”3” //“33”</li>
<li><p>当多个运算符被重载时，js会盲目的选择valueOf; 所以要么明确重载一个，要么保证重载的俩个值相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"hh"</span>;</div><div class="line">    &#125;,</div><div class="line">    valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">12</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//或者 obj.prototype.toString = function () ...</span></div><div class="line"><span class="string">"object:"</span> + obj;<span class="comment">//"object:17"</span></div></pre></td></tr></table></figure>
</li>
<li><p>真值运算；if、|| 、&amp;&amp;需要布尔的运算<br>js有7个假值：false、0、-0、””、NaN、null、undefined；</p>
</li>
</ol>
<h3 id="的强制转换"><a href="#的强制转换" class="headerlink" title="== 的强制转换"></a>== 的强制转换</h3><table>
<thead>
<tr>
<th>Param1</th>
<th style="text-align:center">Param2</th>
<th style="text-align:right">Force Format</th>
</tr>
</thead>
<tbody>
<tr>
<td>null</td>
<td style="text-align:center">undefined</td>
<td style="text-align:right">不转换，总返回true</td>
</tr>
<tr>
<td>null or undefined</td>
<td style="text-align:center">非null、非undefined</td>
<td style="text-align:right">不转换，总返回false</td>
</tr>
<tr>
<td>原始类型</td>
<td style="text-align:center">Date对象、非Date对象</td>
<td style="text-align:right">原始类型转换为数字，Date对象（优先toString）、非Date对象(优先valueOf)转换为原始类型</td>
</tr>
<tr>
<td>原始类型</td>
<td style="text-align:center">原始类型</td>
<td style="text-align:right">将原始类型转换为数字</td>
</tr>
</tbody>
</table>
<h3 id="Unicode字符"><a href="#Unicode字符" class="headerlink" title="Unicode字符"></a>Unicode字符</h3><ol>
<li>js字符串由16位代码单元组成，而不是由unicode代码点组成。</li>
<li>js使用俩个代码单元表示16位以上的unicode代码点，称为代码对。</li>
<li>代码对甩开了字符串元素计数，length、charAt、charCodeAt方法以及正则表达式模式。</li>
</ol>
<h3 id="字符串Trick"><a href="#字符串Trick" class="headerlink" title="字符串Trick"></a>字符串Trick</h3><pre><code>它字符串的构造
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> tt= <span class="string">'as'</span>;</div><div class="line"><span class="keyword">let</span> at = <span class="string">`aa<span class="subst">$&#123;tt&#125;</span>`</span><span class="comment">//注意这不是单引号</span></div></pre></td></tr></table></figure>
</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeSandwich</span>(<span class="params">maigc</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">filling</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> maigc + <span class="string">" and "</span> + filling;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> make;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f = makeSandwich(<span class="string">"peanut butter"</span>);</div><div class="line">f(<span class="string">"jelly"</span>);<span class="comment">//"peanut butter and jelly"</span></div></pre></td></tr></table></figure>
<p>立即调用函数表达式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wara</span>(<span class="params">a</span>) </span>&#123;</div><div class="line"> <span class="keyword">var</span> result = [];</div><div class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, n = a.length; i &lt; n; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</div><div class="line">    result[j] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> a[j];&#125;;</div><div class="line">  &#125;)(i);</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="变量声明提升"><a href="#变量声明提升" class="headerlink" title="变量声明提升"></a>变量声明提升</h3><p>js对变量的作用域是函数级的，不是块级的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">trime</span>(<span class="params">header</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; n = header; i &lt; n; i++)</div><div class="line">    ...</div><div class="line">    for (<span class="keyword">var</span> i = <span class="number">0</span>; n = header; i &lt; n; i++)</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">//上面的i,n其实只申明了一次，剩下的都是同一个而已。js的变量提升可以视为会把声明自动放到函数开头。</span></div></pre></td></tr></table></figure></p>
<h3 id="命名函数"><a href="#命名函数" class="headerlink" title="命名函数"></a>命名函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) ...</span></div><div class="line"><span class="title">function</span> <span class="title">test</span>(<span class="params"></span>) &#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) ... //在此函数里访问<span class="title">f</span>，就只会是这个<span class="title">f</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以建议少用命名函数，多用匿名函数。</p>
<h3 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h3><ol>
<li>书上的建议是不要用它创建变量，同名变量会导致访问相同地址的变量</li>
<li>间接调用eval函数；<br><code>(0,eval)(src)</code> 0值无意义以达到强制使用间接调用的目的。src是传入给eval的参数。</li>
</ol>
<h3 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h3><p>obj.temprorary = f;<br>var result = obj.temprorary(arg1, arg2);<br>delete obj.temprorary;<br>当想使用其他对象的某个属性时，这种方法不仅别扭，而且相当危险。<br>所以有了call和apply</p>
<p>apply只是让数组变成多个参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> df = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="keyword">var</span> vf = <span class="function"><span class="keyword">function</span>(<span class="params">a1, a2, a3</span>) </span>&#123; <span class="keyword">return</span> (a1+a2+a3)/<span class="number">3</span>;&#125;</div><div class="line">vf.apply(vf, df)</div></pre></td></tr></table></figure></p>
<h3 id="js函数有个arguments的默认参数，也是数组。所以默认支持变长参数函数。"><a href="#js函数有个arguments的默认参数，也是数组。所以默认支持变长参数函数。" class="headerlink" title="js函数有个arguments的默认参数，也是数组。所以默认支持变长参数函数。"></a>js函数有个arguments的默认参数，也是数组。所以默认支持变长参数函数。</h3><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = &#123;</div><div class="line"> entries: [],</div><div class="line"> add: <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.entries.push(s);</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sourc = [<span class="string">"874"</span>, <span class="string">"-"</span>, <span class="string">"53443"</span>];</div><div class="line">sourc.forEach(buffer.add.bind(buffer)) <span class="comment">//保证buffer.add函数的接受者就是buffer对象</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">simple</span>(<span class="params">pro, dom, path</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> pro + <span class="string">"://"</span> + dom + <span class="string">"/"</span> + path;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> ul = apath.map(simple.bind(<span class="literal">null</span>, <span class="string">"http"</span>, <span class="string">"ff"</span>));<span class="comment">//["http://ff/we", "http://ff/er", "http://ff/rt"]</span></div><div class="line"><span class="comment">//bind第一个参数提供接受者的值，其余参数提供给给新函数的所有参数。</span></div></pre></td></tr></table></figure>
<h3 id="使构造函数与new无关"><a href="#使构造函数与new无关" class="headerlink" title="使构造函数与new无关"></a>使构造函数与new无关</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一般我们写构造函数时都喜欢，传入参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, password</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.password = password;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> x = User(<span class="string">"test"</span>, <span class="string">"demo"</span>);<span class="comment">//这样做虽然可以成功，但是也会产生多余的全局变量name和password</span></div><div class="line"></div><div class="line"><span class="comment">//避免有俩种方法，要么  var x = new User("test", "demo")</span></div><div class="line"><span class="comment">//所以要这么写函数，加不加new都可以</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, password</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> User))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(name, password);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.password = password;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="将状态存储到示例对象而不是原型对象"><a href="#将状态存储到示例对象而不是原型对象" class="headerlink" title="将状态存储到示例对象而不是原型对象"></a>将状态存储到示例对象而不是原型对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = x;</div><div class="line">&#125;</div><div class="line">Tree.prototype = &#123;</div><div class="line">    children: [],</div><div class="line">    addChild: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.children.push(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> left = <span class="keyword">new</span> Tree(<span class="number">2</span>);</div><div class="line">left.addChild(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> right = <span class="keyword">new</span> Tree(<span class="number">6</span>);</div><div class="line">right.addChild(<span class="number">4</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> top = <span class="keyword">new</span> Tree(<span class="number">7</span>);</div><div class="line">top.addChild(left);</div><div class="line">top.addChild(right);</div><div class="line">top.children; <span class="comment">//[1,4,left,right] 这样会多出俩个对象。所以把children放入成员变量是最好</span></div></pre></td></tr></table></figure>
<h3 id="this隐式绑定问题"><a href="#this隐式绑定问题" class="headerlink" title="this隐式绑定问题"></a>this隐式绑定问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">CSVReader</span>(<span class="params">sep</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.regexp = ...;</div><div class="line">&#125;</div><div class="line">CSVReader.prototype.read = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> lines = str.trim().split(<span class="regexp">/\n/</span>);</div><div class="line">    <span class="keyword">return</span> lines.map(<span class="function"><span class="keyword">function</span>(<span class="params">line</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> line.split(<span class="keyword">this</span>.regexp);<span class="comment">//此处本来是想访问CSVReader的regexp，但是实际访问的是lines的</span></div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">//改法加bind，或者 var self = this; .... self.regexp;</span></div></pre></td></tr></table></figure>
<h3 id="在子类的构造函数中调用父类的构造函数"><a href="#在子类的构造函数中调用父类的构造函数" class="headerlink" title="在子类的构造函数中调用父类的构造函数"></a>在子类的构造函数中调用父类的构造函数</h3><p>继承可以用Object.Create<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  Shape.call(<span class="keyword">this</span>); <span class="comment">//call super constructor.</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</div><div class="line">Rectangle.prototype.constructor = Rectangle;</div><div class="line"><span class="comment">//这样能创造新的链</span></div><div class="line"></div><div class="line"><span class="comment">//如果不想使用新链</span></div><div class="line"><span class="keyword">var</span> sp = <span class="keyword">new</span> Shape()</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(sp)<span class="comment">//b的链指向sp</span></div></pre></td></tr></table></figure></p>
<p><strong>注意不要让子类属性和父类属性重名，这样会导致冲突访问同一属性。</strong><br><strong>避免继承标准类</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">cls1</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">cls2</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    cls1.call(<span class="keyword">this</span>, name);<span class="comment">//感觉使用call来传递继承要比直接用prototype方便。 cls2.prototype = Object.create(cls1.prototype);</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> tt = <span class="keyword">new</span> cls2(<span class="string">"ss"</span>);</div><div class="line">tt.show();<span class="comment">//ss</span></div></pre></td></tr></table></figure></p>
<h3 id="猴子补丁"><a href="#猴子补丁" class="headerlink" title="猴子补丁"></a>猴子补丁</h3><p>由于平台的不同有些对属性的修改可能会导致覆盖,应该如此<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.map !== <span class="string">"function"</span>) &#123;</div><div class="line">    <span class="built_in">Array</span>.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params">f, thisArg</span>) </span>&#123;</div><div class="line">        ...;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用object实例直接构造轻量级字典"><a href="#使用object实例直接构造轻量级字典" class="headerlink" title="使用object实例直接构造轻量级字典"></a>使用object实例直接构造轻量级字典</h3><p>书上建议使用实例来增加属性，而不是原型的prototype.<br>这样保证for in的正确执行<br>不建议用for in来循环数组,（特别是数字类型的数组；即使用[]，但是遍历的变量是字符型）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dict = &#123;&#125;;</div><div class="line">dict.alice = <span class="number">23</span>;</div><div class="line">dict.bob = <span class="number">4</span>;</div><div class="line">dict.ttt = <span class="number">6</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> dict) &#123;</div><div class="line">    ...<span class="comment">//循环遍历dict的属性,字符类型</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用null原型防止原型污染"><a href="#使用null原型防止原型污染" class="headerlink" title="使用null原型防止原型污染"></a>使用null原型防止原型污染</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">c.prototype = <span class="literal">null</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> c();</div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(o) === <span class="literal">null</span><span class="comment">//false</span></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="number">0</span>) === <span class="built_in">Object</span>.prototype;<span class="comment">//true</span></div><div class="line"><span class="comment">//这个并不会成为真正的null，要如下设置</span></div><div class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="number">0</span>) === <span class="literal">null</span>;<span class="comment">//true</span></div></pre></td></tr></table></figure>
<h3 id="使用hasOwnProperty避免原型污染"><a href="#使用hasOwnProperty避免原型污染" class="headerlink" title="使用hasOwnProperty避免原型污染"></a>使用hasOwnProperty避免原型污染</h3><p>即使是个空的对象，也继承了大量属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dict = &#123;&#125;;</div><div class="line"><span class="string">"alice"</span> <span class="keyword">in</span> dict;   <span class="comment">//false</span></div><div class="line"><span class="string">"toString"</span> <span class="keyword">in</span> dict;<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>为了避免空对象的判断，可以使用hasOwnProperty<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dict.hasOwnProperty(<span class="string">"toString"</span>);<span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<h3 id="使用数组而不要用字典来存储有序集合"><a href="#使用数组而不要用字典来存储有序集合" class="headerlink" title="使用数组而不要用字典来存储有序集合"></a>使用数组而不要用字典来存储有序集合</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ht = [&#123;name:<span class="string">"q"</span>,number:<span class="number">1</span>&#125;,&#123;name:<span class="string">"w"</span>,number:<span class="number">2</span>&#125;,&#123;name:<span class="string">"e"</span>,number:<span class="number">3</span>&#125;];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> tn <span class="keyword">in</span> ht) &#123;</div><div class="line"> <span class="built_in">console</span>.log(tn);</div><div class="line"> <span class="built_in">console</span>.log(ht[tn]);</div><div class="line">&#125;</div><div class="line"><span class="comment">//当前平台的输出是：0 &#123;name:"q",number:1&#125; 1 &#123;name:"w",number:2&#125; 2 &#123;name:"e",number:3&#125;</span></div></pre></td></tr></table></figure>
<p>书上说，for…in 在此类数组中它由环境的不同可能会选择不同的顺序来枚举对象。<br>所以即使以上写法可以，也建议使用普通的循环。</p>
<h3 id="js的属性"><a href="#js的属性" class="headerlink" title="js的属性"></a>js的属性</h3><h4 id="属性点访问和方括号访问"><a href="#属性点访问和方括号访问" class="headerlink" title="属性点访问和方括号访问"></a>属性点访问和方括号访问</h4><p>属性允许字符和变量</p>
<blockquote>
<p>点访问只能访问字符属性<br>方括号访问访问字符时<strong>obj[‘pro’]</strong>,访问变量时<strong>obj[ele]</strong></p>
<p>一般属性的字符定义(括号定义必须是字符)：obj.pro = …; obj[‘pro’]=…<br>变量定义 obj[ele]= …</p>
</blockquote>
<h4 id="枚举性"><a href="#枚举性" class="headerlink" title="枚举性"></a>枚举性</h4><p>对于对象来说，属性有可枚举和不可枚举<br>默认从<code>prototype</code>来的是可枚举的<br>不可枚举一般用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">'sex'</span>, &#123;</div><div class="line">    value: <span class="string">'man'</span>,</div><div class="line">    enumerable: <span class="literal">false</span></div><div class="line">&#125;)<span class="comment">//给a对象加个sex属性，不能枚举</span></div></pre></td></tr></table></figure></p>
<p>当属性可枚举时：for…in能遍历出来。Object.keys()能遍历出来(数组非数字属性也能遍历出来)<br>当属性不可枚举: 只有Object.getOwnPropertyNames()能遍历出来, 和 …in语句</p>
<h4 id="创建位置"><a href="#创建位置" class="headerlink" title="创建位置"></a>创建位置</h4><p>属性明确创建:<br>构造函数<code>this.a=...</code><br>创建的对象obj定义属性<code>obj.a=...</code></p>
<p>原型创建:<br>创建的对象obj定义属性<code>obj.prototype.a=...</code><br>class体内定义的属性</p>
<p>由于依附在原型上，<code>hasOwnProperty</code>,<code>for...in</code>, <code>getOwnPropertyNames</code>都会无法返回对应属性，只有<code>...in</code>语句能返回</p>
<h3 id="不要在prototype中增加可枚举的属性"><a href="#不要在prototype中增加可枚举的属性" class="headerlink" title="不要在prototype中增加可枚举的属性"></a>不要在prototype中增加可枚举的属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.allkey = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</div><div class="line">        result.push(key);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;<span class="comment">//这样会导致多个属性allkey ["allkey", "a", "b", "c"]</span></div></pre></td></tr></table></figure>
<p>书上解决方法是封装成函数，如果实在要封装成属性，要如下写。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">"allKeys"</span>, &#123;</div><div class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> result = [];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</div><div class="line">            result.push(key);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;,</div><div class="line">    writable: <span class="literal">true</span>,</div><div class="line">    enumerable: <span class="literal">false</span>,</div><div class="line">    configurable: <span class="literal">true</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我感觉这样写又会污染原型，还是写成函数好点。</p>
<h3 id="避免枚举期间修改对象"><a href="#避免枚举期间修改对象" class="headerlink" title="避免枚举期间修改对象"></a>避免枚举期间修改对象</h3><p>直接引用书上：</p>
<ol>
<li>当使用for…in循环枚举一个对象的属性时，确保不要修改对象。</li>
<li>当迭代一个对象是，如果该对象可能会在循环期间被改变，应该使用while或for来代替for…in</li>
</ol>
<h3 id="迭代方法优于循环"><a href="#迭代方法优于循环" class="headerlink" title="迭代方法优于循环"></a>迭代方法优于循环</h3><p>书上建议多用 forEach/map/every 这些本身的迭代方法来代替循环。</p>
<h3 id="函数默认值"><a href="#函数默认值" class="headerlink" title="函数默认值"></a>函数默认值</h3><p>es5上没有默认值得设定<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Element</span>(<span class="params">w, h</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.w = w || <span class="number">1</span>;</div><div class="line">    <span class="keyword">this</span>.h = h || <span class="number">2</span>;</div><div class="line">&#125;<span class="comment">//如上确实在Element(),会返回默认值。但是在Element(0, 0)时就不会。</span></div><div class="line"></div><div class="line"><span class="comment">//所以该如下写法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Element</span>(<span class="params">w, h</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.w = w === <span class="literal">undefined</span> ? <span class="number">1</span> : w;</div><div class="line">    <span class="keyword">this</span>.h = h === <span class="literal">undefined</span> ? <span class="number">2</span> : h;</div><div class="line">&#125;<span class="comment">//如上在Element(0, 0)页可以正常运行</span></div></pre></td></tr></table></figure></p>
<h3 id="编写方法支持方法链"><a href="#编写方法支持方法链" class="headerlink" title="编写方法支持方法链"></a>编写方法支持方法链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeBasic</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</div><div class="line">              .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</div><div class="line">              .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>)</div><div class="line">              .replace(<span class="regexp">/"/g</span>, <span class="string">"&amp;quot;"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="不要阻塞I-O事件队列"><a href="#不要阻塞I-O事件队列" class="headerlink" title="不要阻塞I/O事件队列"></a>不要阻塞I/O事件队列</h3><p>如下代码会一直等待下载文件完成才继续执行下去，会导致卡死情况。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = downloadSync(<span class="string">"http://example.com/file.txt"</span>);</div><div class="line"><span class="built_in">console</span>.log(text);</div></pre></td></tr></table></figure></p>
<p>如下代码就不会阻塞了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = downloadSync(<span class="string">"http://example.com/file.txt"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(text);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="对异步循环使用递归"><a href="#对异步循环使用递归" class="headerlink" title="对异步循环使用递归"></a>对异步循环使用递归</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params">urls</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (...) &#123;</div><div class="line">        ...<span class="comment">//下载文件，异步代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>循环的代码会等待下载执行完成。用递归函数在时间循环的单独轮次中执行迭代。</p>
<h3 id="js递归函数同步调用太多次会导致失败（承受力各不同，几百次以上）"><a href="#js递归函数同步调用太多次会导致失败（承受力各不同，几百次以上）" class="headerlink" title="js递归函数同步调用太多次会导致失败（承受力各不同，几百次以上）"></a>js递归函数同步调用太多次会导致失败（承受力各不同，几百次以上）</h3><h3 id="私有公有静态属性的访问"><a href="#私有公有静态属性的访问" class="headerlink" title="私有公有静态属性的访问"></a>私有公有静态属性的访问</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">user</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> name = name;<span class="comment">//私有属性</span></div><div class="line">  <span class="keyword">this</span>.name = name; <span class="comment">//公有属性</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> name; &#125;<span class="comment">//私有方法</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getHName</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> name; &#125;<span class="comment">//私有方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">user.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.name;&#125;<span class="comment">//公有方法</span></div><div class="line">user.name = <span class="string">'ss'</span>; <span class="comment">//静态属性</span></div><div class="line">user.sname = <span class="string">'ss'</span>; <span class="comment">//静态属性</span></div><div class="line">user.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.name&#125;<span class="comment">//静态方法</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> user(<span class="string">'cats'</span>);</div></pre></td></tr></table></figure>
<ul>
<li><p>调用公有方法、公有属性，必须先实例化对象。公有方法不能调用私有方法和静态方法。<br>(即：ws.sname 不可以 user.sanme可以; )</p>
</li>
<li><p>静态方法和静态属性无需示例化可访问 (user.name可以)</p>
</li>
<li>私有方法和属性外部无法访问 (user.getHName() 不可以 user().getHName() 不可以)</li>
</ul>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'cat'</span>);&#125;</div><div class="line">getName();<span class="comment">//cat</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'dog'</span>); &#125;</div><div class="line">getName();<span class="comment">//dog</span></div></pre></td></tr></table></figure>
<ul>
<li>js解释器会把声明提升到作用域（函数作用域）的最前面（即使写代码时放在最后也会被提升）</li>
</ul>
<h3 id="new的优先级"><a href="#new的优先级" class="headerlink" title="new的优先级"></a>new的优先级</h3><p>用上面现成的代码做例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> user.getName();</div><div class="line"><span class="comment">//由于点运算优先级大于new无参数列表 这个就可视为 new (user.getName)();</span></div><div class="line"><span class="comment">//这下就成了将getName作为了构造函数来创建对象</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> user().getName();</div><div class="line"><span class="comment">//new有参数列表和点运算同级，所以可视为 (new user()).getName();</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div><div class="line">foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">3</span>);&#125;</div><div class="line">foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">4</span>);&#125;</div><div class="line"><span class="keyword">new</span> foo.getName();<span class="comment">//3</span></div><div class="line"><span class="keyword">new</span> foo().getName();<span class="comment">//4</span></div></pre></td></tr></table></figure>
<h3 id="import的括号"><a href="#import的括号" class="headerlink" title="import的括号"></a>import的括号</h3><p> 未加括号是默认引用：<code>import A from &#39;./A&#39;</code> <code>import Mya from &#39;./A&#39;</code>;这样引用的都是<code>A</code>文件里的<code>export default</code></p>
<p> 加了括号是指定引用：<br>  <code>import {Som} from &#39;./A&#39;</code>,<code>A</code>文件里必须有个<code>export Som ...</code>导出</p>
<p>  <code>import A, { Mya, Som} from &#39;./A&#39;</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C#文件和其它(210)]]></title>
      <url>https://xuecat.github.io/2017/01/21/210/</url>
      <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/210.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>File和FileInfo<br>Directory和DirectoryInfo<br>如果执行单一调用使用静态类<br>如果执行一系列调用使用Info类</p>
<p><code>new FileInfo(@&quot;C:\Log.txt&quot;)</code>使用<code>@</code>前缀表示字符按字面意义解释，没有的话就要用<code>\\</code>代替<code>\</code>了。</p>
<p><code>FileStream</code>读写的是字节数组<br><code>StreamReader</code> <code>StreamWriter</code>读写的是字符数组<br>字符和数组的转换用<code>Decoder</code>和<code>Encoder</code></p>
<h3 id="文本格式"><a href="#文本格式" class="headerlink" title="文本格式"></a>文本格式</h3><ol>
<li><p>XPath 用于检索xml的节点。</p>
</li>
<li><p>创建xml的话，我绝对linq的XDocument要比XmlDocument好用多了。</p>
</li>
</ol>
<h3 id="LINQ"><a href="#LINQ" class="headerlink" title="LINQ"></a>LINQ</h3><p>它的实现是基于<code>IEnumerable&lt;T&gt;</code>接口,所以下面俩句是等效的。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">string</span>[] name = &#123;<span class="string">"n1"</span>, <span class="string">"n2"</span>, <span class="string">"n3"</span>, <span class="string">"n4"</span> &#125;;</div><div class="line"><span class="keyword">var</span> dd = name.Where(n =&gt; n.StartsWith(<span class="string">"n"</span>));</div><div class="line"><span class="keyword">var</span> hh = <span class="keyword">from</span> n <span class="keyword">in</span> name <span class="keyword">where</span> n.StartsWith(<span class="string">"n"</span>) <span class="keyword">select</span> n;</div></pre></td></tr></table></figure></p>
<h4 id="orderby"><a href="#orderby" class="headerlink" title="orderby"></a>orderby</h4><p>暂时就个字母，其它排列再看看吧<br><code>var hh = from n in name where n.StartsWith(&quot;n&quot;) orderby n select n;</code>升序排列结果<br><code>var hh = from n in name where n.StartsWith(&quot;n&quot;) orderby n descending select n;</code>降序排列结果</p>
<h5 id="多级排序，并返回新建立的对象。"><a href="#多级排序，并返回新建立的对象。" class="headerlink" title="多级排序，并返回新建立的对象。"></a>多级排序，并返回新建立的对象。</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> queryResults = from <span class="built_in">c</span> <span class="keyword">in</span> customers</div><div class="line"> orderby <span class="built_in">c</span>.<span class="type">Region</span>, <span class="built_in">c</span>.<span class="type">Country</span> descending, <span class="built_in">c</span>.<span class="type">City</span></div><div class="line"> select new &#123; <span class="built_in">c</span>.<span class="type">ID</span>, <span class="built_in">c</span>.<span class="type">Region</span>, <span class="built_in">c</span>.<span class="type">Country</span>, <span class="built_in">c</span>.<span class="type">City</span> &#125;;</div></pre></td></tr></table></figure>
<h4 id="查找不重复"><a href="#查找不重复" class="headerlink" title="查找不重复"></a>查找不重复</h4><p>会按照Region属性选出所有，Distinct来排除重复。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">qu</span> = name.Select(c =&gt; c.Region).<span class="keyword">Distinct</span>();</div><div class="line"><span class="keyword">var</span> <span class="keyword">qu</span> = (from c <span class="keyword">in</span> name select c.Region).<span class="keyword">Distinct</span>();</div></pre></td></tr></table></figure></p>
<h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>书上的例子是，按照国家来比较销量<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> q =</div><div class="line"> from c <span class="keyword">in</span> customers</div><div class="line"> <span class="keyword">group</span> c <span class="keyword">by</span> c.Region <span class="keyword">into</span> cg</div><div class="line"> <span class="keyword">select</span> <span class="literal">new</span> &#123; TotalSaleds = cg.<span class="keyword">Sum</span>(c =&gt; c.Sales), Region = cg.Key&#125;</div><div class="line"></div><div class="line"> <span class="comment">//第二句by后面指定重组使用的Key，再重新组合成cg（即后面cg.Key）</span></div><div class="line"> <span class="comment">//第三句</span></div></pre></td></tr></table></figure></p>
<h4 id="join查询"><a href="#join查询" class="headerlink" title="join查询"></a>join查询</h4><p>书上的例子是把客户列表(customers)和订单列表(orders)中，id相同的找出重组合<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> q =</div><div class="line"> <span class="keyword">from</span> c <span class="keyword">in</span> customers</div><div class="line"> <span class="keyword">join</span> o <span class="keyword">in</span> orders <span class="keyword">on</span> c.ID <span class="keyword">equals</span> o.ID</div><div class="line"> <span class="keyword">select</span> <span class="keyword">new</span> <span class="comment">&#123;c.ID, c.City&#125;</span>;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Windows编译器对异常的处理(207)]]></title>
      <url>https://xuecat.github.io/2017/01/12/207/</url>
      <content type="html"><![CDATA[<p><img src="/picture/207.jpg" alt=""></p>
<p>c/c++ 配置属性 代码生成 启用c++异常</p>
<p>2013版本讲解要详细点：<br><a href="https://msdn.microsoft.com/zh-cn/library/1deeycx5(v=vs.120).aspx" target="_blank" rel="external">https://msdn.microsoft.com/zh-cn/library/1deeycx5(v=vs.120).aspx</a></p>
<p>编译器会对异常捕获进行优化。</p>
<p>使用<code>/EHs</code> <code>EHsc</code> catch(…) 是不会捕获异步结构化异常、访问冲突和 System.Exception 异常。只会捕获c++异常<br>当必须要捕获这些异常时，就只能用 <strong>try, </strong>except 和 __finally 语法</p>
<p>使用<code>/EHa</code> catch(…)会捕获所有的异常。<br>但是引用官方的话<code>指定 /EHa 并尝试使用 catch(...) 处理所有异常可能很危险。 在大多数情况下，异步异常是不可恢复的，因而被认为是致命的。 捕获它们并继续可能导致进程损坏并使 Bug 难以发现和修复。</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[加锁问题(206)]]></title>
      <url>https://xuecat.github.io/2016/12/27/206/</url>
      <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/206.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<p>今天加临界区时讨论了下。<br>一开始觉得迭代器，写的地方加锁就好了。<br>但是后来发现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_VTRUploadTaskList.size(); i++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(m_VTRUploadTaskList[i]<span class="number">._</span>nTaskID == nTaskID)</div><div class="line">&#125;</div><div class="line"><span class="comment">//这样，如果外部对这个clear的话，再走操作函数就会挂的。</span></div><div class="line"><span class="comment">//所以，结论是有关写的整块都要加锁</span></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gen2项目学习(205)]]></title>
      <url>https://xuecat.github.io/2016/12/15/205/</url>
      <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/picture/u1.jpg" alt=""></div><div class="group-picture-column" style="width: 50%;"><img src="/picture/u2.jpg" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/u3.jpg" alt=""></div></div></div></div>
<h4 id="LoggingDBService"><a href="#LoggingDBService" class="headerlink" title="LoggingDBService"></a>LoggingDBService</h4><p>212失联后，为了配置这个服务，也是伤神死了。</p>
<p>1、服务是否正确。启动LoggingDBService，在网页上输入相应网址访问；再看看<code>asmx</code>访问是否成功，成功的话就表示服务是好的。</p>
<p>2、数据库配置是否正确。进入数据库，对比相应数据库名、用户名、和密码。</p>
<p>3、本地<code>webService.ini</code>是配置正确。要注意的是里面的ip地址必须是c类ip；回环ip和localhost之类的是不行的。</p>
<h3 id="logging的webservice"><a href="#logging的webservice" class="headerlink" title="logging的webservice"></a>logging的webservice</h3><p>他们用的是<code>asp.net webservice</code>工程。vs10以后，就全是<code>wcf</code>了。<br>如果要强制建，可以<code>空asp</code>再建个<code>web服务程序</code></p>
<p>类继承<code>MarshalByRefObject, IRegisteredObject</code>后，再访问<code>asmx</code>文件。就达到了服务程序，随winform程序启动的假象。<br>实际就是iis服务器。<br>不然就自己配置到iis服务器。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[WPF学习(204)]]></title>
      <url>https://xuecat.github.io/2016/12/07/204/</url>
      <content type="html"><![CDATA[<p><img src="/picture/y2.jpg" alt=""></p>
<h3 id="wpf和winform"><a href="#wpf和winform" class="headerlink" title="wpf和winform"></a>wpf和winform</h3><p>winform -&gt; 新建windows窗体程序<br>控件的描述全在一个<code>Designer</code>的cs文件中，控件事件则在对应的cs文件里。</p>
<p>wpf -&gt; 新建wpf程序</p>
<p>感觉winform就是基于mfc再封装了一层c#，界面设计等还是wpf吧</p>
<h3 id="代码隐藏文件"><a href="#代码隐藏文件" class="headerlink" title="代码隐藏文件"></a>代码隐藏文件</h3><p>界面描述放在<code>xaml</code>文件里的<br>为界面增加功能（事件呀等）的cs代码，就放入<code>.xaml.cs</code>文件中<br>隐藏文件默认是放入xaml文件同一个目录中的。</p>
<p>界面第一句：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Window</span> <span class="attr">x:Class</span>=<span class="string">"WpfApplication1.MainWindow"</span>&gt;</span></div><div class="line">//第一句就指定了，对应隐藏文件的类</div></pre></td></tr></table></figure></p>
<h3 id="路由事件"><a href="#路由事件" class="headerlink" title="路由事件"></a>路由事件</h3><p>路由事件有点想mfc的common，但是它要多点。<br>lbutondown这些事件是标准事件，它只会发给被显示订阅的控件。</p>
<p>像keydown这种路由事件它会：<br>先走下钻事件（Preview开头的事件），再走上钻事件（正常开头的事件）；<br>pre的Window事件-&gt;pre的Grid网格事件-&gt;pre的焦点控件事件-&gt;焦点控件事件-&gt;Grid网格事件-&gt;Window事件</p>
<p>如需要停止路由，直接<code>e.Handled = true;</code></p>
<h3 id="布局控件"><a href="#布局控件" class="headerlink" title="布局控件"></a>布局控件</h3><p>把这几个基本的布局控件搞了，就直接干代码了。太麻烦了！！</p>
<h4 id="Canvas控件"><a href="#Canvas控件" class="headerlink" title="Canvas控件"></a>Canvas控件</h4><p>书上说这个可以完全自由地对控件的位置进行安排，且<code>HorizontalAligment</code>和<code>VerticalAlignment</code>并不能改变这些元素位置</p>
<p>测试发现，窗口的变大变小如果是Grid则会跟随变化里面子控件的大小；而Canvas则不会，里面的子控件大小位置被固定了似的。</p>
<p>可以用<code>Canvas.Top</code>等这些属性来限定子控件在<code>Canvas</code>里面的布局，但我估计实际应用慢慢看吧。。。。</p>
<h4 id="DockPanel控件"><a href="#DockPanel控件" class="headerlink" title="DockPanel控件"></a>DockPanel控件</h4><p>它会从上往下（越接近顶层，越优先）。布局子控件，除非有限制（height、width），不然会尽量布满布局。</p>
<p>它是从剩余空间来进行计算(<code>DockPanel.Dock=&quot;Top&quot;</code>以剩余的上半部分为基础)</p>
<h4 id="StackPanel控件"><a href="#StackPanel控件" class="headerlink" title="StackPanel控件"></a>StackPanel控件</h4><p>它的设置更多的设置本身，它来控制内部子控件的堆叠方向，不会占满布局。</p>
<p>用<code>Orientaion、VerticalAlignment、HorizontalAlignment</code>来设置内部控件的堆叠方向、内部控件对齐方向。</p>
<h4 id="WrapPanel控件"><a href="#WrapPanel控件" class="headerlink" title="WrapPanel控件"></a>WrapPanel控件</h4><p>是StackPanel的扩展版本；容纳不下的控件会被安排到下一行</p>
<h4 id="Grid控件"><a href="#Grid控件" class="headerlink" title="Grid控件"></a>Grid控件</h4><h3 id="透明窗口"><a href="#透明窗口" class="headerlink" title="透明窗口"></a>透明窗口</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//窗口透明</span></div><div class="line">WindowStyle=<span class="string">"None"</span></div><div class="line">AllowsTransparency=<span class="string">"True"</span></div><div class="line">Background=<span class="string">"Transparent"</span><span class="comment">//这个属性感觉很智能，它还可以设置窗体的透明色。</span></div><div class="line"></div><div class="line"><span class="comment">//控件透明</span></div><div class="line"><span class="comment">//另外控件的透明度用 Opacity</span></div></pre></td></tr></table></figure>
<h3 id="控件标题内容换行"><a href="#控件标题内容换行" class="headerlink" title="控件标题内容换行"></a>控件标题内容换行</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">Content</span>=<span class="string">"wrewrwere&amp;#13;wrewrewrwe"</span></div><div class="line"><span class="attr">Text</span>=<span class="string">"oiomlkljoijlo&amp;#x0a;klklkkjkjjk"</span></div></pre></td></tr></table></figure>
<p>如上，很方便。但还是纠结了，本来Windows换行符是<code>\r\n</code>的，c#代码换行也是如此。<br>于是有下：<br>空格 (&#x0020;)<br>Tab (&#x0009;)<br>回车 (&#x000D;) 难怪上面是13<br>换行 (&#x000A;)</p>
<h3 id="高宽百分比设置"><a href="#高宽百分比设置" class="headerlink" title="高宽百分比设置"></a>高宽百分比设置</h3><p>今天试了下，发现 Height和Width 不仅可以用数字表示，还可以 <code>30*</code>这种百分比表示。</p>
<p>这样的话就会把所有子控件的加上，再除以相应数字。得出百分比，进行布局设置。</p>
<h3 id="grid跨行跨列"><a href="#grid跨行跨列" class="headerlink" title="grid跨行跨列"></a>grid跨行跨列</h3><p>对于grid可以分区：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//行的使用</div><div class="line"><span class="tag">&lt;<span class="name">Grid.RowDefinitions</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">RowDefinition</span> <span class="attr">Height</span>=<span class="string">"34"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">RowDefinition</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">RowDefinition</span> <span class="attr">Height</span>=<span class="string">"24"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Grid.RowDefinitions</span>&gt;</span></div><div class="line">//子控件使用 Grid.Row="0" 等语法就可以放置到相应区里面</div></pre></td></tr></table></figure></p>
<p>但是当有个控件比较特殊，需要占多个行或列时（上面grid划分好了的行和列）<br>就可以使用<code>Grid.RowSpan（列同理）</code> 它会从 <code>Grid.Row（列同理）</code>开始，占满接下来几个的行（列）</p>
<h3 id="x命名空间"><a href="#x命名空间" class="headerlink" title="x命名空间"></a>x命名空间</h3><h3 id="tab控件使用"><a href="#tab控件使用" class="headerlink" title="tab控件使用"></a>tab控件使用</h3><p>注意TabItem子控件只能有一个，所以一般用布局控件来代替。</p>
<h3 id="x-Name和Name"><a href="#x-Name和Name" class="headerlink" title="x:Name和Name"></a>x:Name和Name</h3><p>所有的Type在xaml中都能使用x:Name,即使这个type 没有定义一个叫着Name的Property。<br>因为xmal会在后台为其分配一个field来存储，以便在Binding等里面使用。</p>
<p>像FrameworkElement, VisualStateGroup的某些type，我们在xaml中可以使用Name来代替x:Name，<br>因为它们定义了Name Property，但是最关键的是在type上声明了一个Attribute，[RuntimeNameProperty(“Name”)]，<br>正是这个attribute把Name映射到了x:Name上，所以让Name可以做到x:Name的功能。</p>
<p>正因为如此，name属性超级好用，在xaml给个name属性，相应的隐藏文件就可以直接使用此name来代表此控件</p>
<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p><a href="https://www.tutorialspoint.com/wpf" target="_blank" rel="external">https://www.tutorialspoint.com/wpf</a><br><a href="https://msdn.microsoft.com/zh-cn/library/ms752347(v=vs.110).aspx" target="_blank" rel="external">https://msdn.microsoft.com/zh-cn/library/ms752347(v=vs.110).aspx</a></p>
<p><code>Content=&quot;{Binding}&quot;</code> <a href="https://technet.microsoft.com/zh-cn/subscriptions/index/system.windows.controls.contentcontrol.contenttemplate(v=vs.95" target="_blank" rel="external">默认关联属性</a>.aspx)</p>
<h4 id="本地对象绑定"><a href="#本地对象绑定" class="headerlink" title="本地对象绑定"></a>本地对象绑定</h4><p>如上所说，绑定和<code>Name</code>相关。</p>
<p>先看本地对象绑定：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">CheckBox</span> <span class="attr">Name</span>=<span class="string">"ee"</span> <span class="attr">Content</span>=<span class="string">"Play against computer"</span> <span class="attr">HorizontalAlignment</span>=<span class="string">"Left"</span> <span class="attr">VerticalAlignment</span>=<span class="string">"Top"</span> <span class="attr">Margin</span>=<span class="string">"8,2,0,0"</span> /&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">Label</span> <span class="attr">Content</span>=<span class="string">"Number"</span> <span class="attr">Margin</span>=<span class="string">"8,28,0,0"</span> <span class="attr">HorizontalAlignment</span>=<span class="string">"Left"</span> <span class="attr">VerticalAlignment</span>=<span class="string">"Top"</span> <span class="attr">IsEnabled</span>=<span class="string">"</span></span><span class="template-variable">&#123;Binding ElementName=ee, Path=IsChecked&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> /&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">ComboBox</span> <span class="attr">x:Name</span>=<span class="string">"hhe"</span> <span class="attr">Width</span>=<span class="string">"86"</span> <span class="attr">Margin</span>=<span class="string">"180,28,0,0"</span> <span class="attr">HorizontalAlignment</span>=<span class="string">"Left"</span> <span class="attr">VerticalAlignment</span>=<span class="string">"Top"</span> <span class="attr">SelectedIndex</span>=<span class="string">"0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ComboBoxItem</span>&gt;</span>2<span class="tag">&lt;/<span class="name">ComboBoxItem</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ComboBoxItem</span>&gt;</span>3<span class="tag">&lt;/<span class="name">ComboBoxItem</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ComboBox</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">TextBox</span> <span class="attr">Text</span>=<span class="string">"</span></span><span class="template-variable">&#123;Binding ElementName=hhe, Path=SelectedItem.Content&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">Width</span>=<span class="string">"86"</span> <span class="attr">Margin</span>=<span class="string">"180,68,0,0"</span> <span class="attr">HorizontalAlignment</span>=<span class="string">"Left"</span> <span class="attr">VerticalAlignment</span>=<span class="string">"Top"</span> /&gt;</span></span></div><div class="line"></div><div class="line">//如下形式是同样的</div><div class="line"><span class="tag">&lt;<span class="name">ComboBox.IsEnabled</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">Binding</span> <span class="attr">ElementName</span>=<span class="string">"ee"</span> <span class="attr">Path</span>=<span class="string">"IsChecked"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ComboBox.IsEnabled</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>先看<code>Label</code>的绑定，<code>Binding</code>通过<code>ElementName</code>的<code>Name</code>属性找到了<code>CheckBox</code>对象，并绑定到它身上，再通过<code>IsChecked</code>属性来传值。实际效果：check选中，label就enable（相反同理）<br>再看<code>TextBox</code>绑定，<code>Binding</code>还是绑定到<code>ComboBox</code>上，且它文本绑定到了选中的内容上。实际效果：<code>ComboBox</code>选中哪项，<code>TextBox</code>就显示相应的选中内容。</p>
<h4 id="静态绑定到外部对象"><a href="#静态绑定到外部对象" class="headerlink" title="静态绑定到外部对象"></a>静态绑定到外部对象</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//静态资源的定义最好尽量放外面，不然识别不到外部类</span></div><div class="line">&lt;Grid.Resources&gt;</div><div class="line">    &lt;<span class="keyword">local</span>:ComBoxTests x:<span class="built_in">Key</span>=<span class="string">"com"</span>&gt;&lt;/<span class="keyword">local</span>:ComBoxTests&gt;</div><div class="line">&lt;/Grid.Resources&gt;</div><div class="line"></div><div class="line">&lt;ComboBox x:Name=<span class="string">"hhe"</span> Width=<span class="string">"86"</span> <span class="built_in">Margin</span>=<span class="string">"180,28,0,0"</span> HorizontalAlignment=<span class="string">"Left"</span> VerticalAlignment=<span class="string">"Top"</span> SelectedIndex=<span class="string">"0"</span> ItemsSource=<span class="string">"&#123;Binding Source=&#123;StaticResource com&#125;&#125;"</span>&gt;</div><div class="line">&lt;/ComboBox&gt;</div><div class="line">&lt;TextBox Text=<span class="string">"&#123;Binding ElementName=hhe, Path=SelectedItem&#125;"</span> Width=<span class="string">"86"</span> <span class="built_in">Margin</span>=<span class="string">"180,68,0,0"</span> HorizontalAlignment=<span class="string">"Left"</span> VerticalAlignment=<span class="string">"Top"</span> GotFocus=<span class="string">"TimeTextBox_GotFocus"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">//代码方面</span></div><div class="line">public class ComBoxTests : ObservableCollection&lt;<span class="keyword">string</span>&gt;</div><div class="line">&#123;</div><div class="line">    public ComBoxTests()</div><div class="line">        : base()</div><div class="line">    &#123;</div><div class="line">        Add(<span class="string">"str1"</span>);</div><div class="line">        Add(<span class="string">"str2"</span>);</div><div class="line">        Add(<span class="string">"str3"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/////再来个例子</span></div><div class="line">&lt;sys1:<span class="keyword">String</span> x:<span class="built_in">Key</span>=<span class="string">"Name"</span>&gt;sunji&lt;/sys1:<span class="keyword">String</span>&gt;</div><div class="line">&lt;TextBlock Name=<span class="string">"txtbName"</span> Text=<span class="string">"&#123;StaticResource Name&#125;"</span>/&gt;</div></pre></td></tr></table></figure>
<p>如上，向combobox添加了三个选项，但是<code>TextBox</code>的内部绑定却不得不改了，我也不知道。。想说绑定规则太多了。。。</p>
<h5 id="Mode的类型"><a href="#Mode的类型" class="headerlink" title="Mode的类型"></a>Mode的类型</h5><p>Mode = OneWay 就仅仅只是绑定，控件修改的数据也不会更新到绑定对象里面去<br>Mode = TwoWay 绑定后，若控件修改了数据也会更新到绑定的对象上面去。<br>Mode = OneWayToSource 依赖性只更新到绑定对象上面去。</p>
<p>详细看：<a href="https://www.tutorialspoint.com/wpf/wpf_data_binding.htm" target="_blank" rel="external">https://www.tutorialspoint.com/wpf/wpf_data_binding.htm</a></p>
<h4 id="动态绑定到外部对象"><a href="#动态绑定到外部对象" class="headerlink" title="动态绑定到外部对象"></a>动态绑定到外部对象</h4><p>对于双向绑定来说这个是必须的。<br>重写INotifyPropertyChanged接口</p>
<p><strong>来区分下INotifyPropertyChanged和mode</strong><br>如上，mode有三种模式不多讲了。<br>1、只重写INotifyPropertyChanged接口，确实能进行双向绑定。<br>2、只设置Mode = TwoWay也可以双向绑定。<br>但是它们有个区别。第二种情况，当数据更新时，它并不会立刻更新界面；要等界面再来取一次才行。第一种情况mode就默认了为TwoWay</p>
<p>所以mode和INotifyPropertyChanged配合才是最好的</p>
<h3 id="Menu控件"><a href="#Menu控件" class="headerlink" title="Menu控件"></a>Menu控件</h3><p>这个控件可以像其他控件那样，随便放哪个地方，然后自己设置menu内容。<br><code>Menu.Icon</code>设置单个选项的图标。<br><code>InputGestureText</code>只是个显示内容，不会和指令绑定。<br><code>Click</code>子项直接相应此属性的函数就好了。</p>
<h4 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h4><p>多说项:CanExecute返回false，会自动把控件设置为禁止状态。</p>
<p>先看下默认的，主要讲下：</p>
<p>Command，确实它能和指令绑定，但是默认只能和wpf能解析的指令绑定（自定义命令，下次再讲述吧）。<br>它设置命令后，如果想拦截命令的执行：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">...</span> <span class="attr">Command</span>=<span class="string">"Save"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">Window.CommandBindings</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">CommandBinding</span> <span class="attr">Command</span>=<span class="string">"Save"</span> <span class="attr">CanExecute</span>=<span class="string">"NewCommand_CanExecute"</span> <span class="attr">Executed</span>=<span class="string">"NewCommand_Executed"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Window.CommandBindings</span>&gt;</span></div><div class="line">//CanExecute 是开始展开menu时执行函数，以此来判断哪些项不允许点击和点击</div><div class="line">//Executed 是点击了menuitme是执行的函数</div></pre></td></tr></table></figure></p>
<p>自定义command主要有俩种：</p>
<ol>
<li><p>自定义<code>ICommand</code></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyCommand : ICommand</div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> event EventHandler CanExecuteChanged</div><div class="line">    &#123;</div><div class="line">        add &#123; CommandManager.RequerySuggested += value; &#125;</div><div class="line">        remove &#123; CommandManager.RequerySuggested -= value; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> CanExecute(object parameter)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> Execute(object parameter)</div><div class="line">    &#123;</div><div class="line">        MessageBox.Show(<span class="string">"www"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">调用时：</div><div class="line">要么：<span class="keyword">this</span>.btn.Command = <span class="keyword">new</span> MyCommand();或者&lt;Button Command=<span class="string">"&#123;Binding MyCommand&#125;</span></div><div class="line">要么：&lt;local:MyCommand x:Key="ww<span class="string">" /&gt; &lt;Button Command="</span>&#123;StaticResource ww&#125;<span class="string">" /&gt;</span></div><div class="line">这种`Command`信息比较少，适合默认执行类型。真要加信息也得加`CommandParameter`</div></pre></td></tr></table></figure>
</li>
<li><p>自定义<code>RoutedCommand</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> RoutedCommand RMyCommand =</div><div class="line">    <span class="keyword">new</span> RoutedCommand(<span class="string">"MYC"</span>, <span class="keyword">typeof</span>(ForTest));</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForTest</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">    InitializeComponent();</div><div class="line">    tc.Command = RMyCommand;</div><div class="line">    </div><div class="line">    CommandBinding comBind = <span class="keyword">new</span> CommandBinding();</div><div class="line">    comBind.Command = RMyCommand;</div><div class="line">    comBind.CanExecute += <span class="keyword">new</span> CanExecuteRoutedEventHandler(cb_CanExecute);</div><div class="line">    comBind.Executed += <span class="keyword">new</span> ExecutedRoutedEventHandler(cb_Execute);</div><div class="line"></div><div class="line">    gg.CommandBindings.Add(comBind);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cb_Execute</span>(<span class="params"><span class="keyword">object</span> sender, ExecutedRoutedEventArgs e</span>)</span></div><div class="line">&#123;</div><div class="line">    tb.Clear();</div><div class="line">    e.Handled = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cb_CanExecute</span>(<span class="params"><span class="keyword">object</span> sender, CanExecuteRoutedEventArgs e</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(tb.Text))</div><div class="line">    &#123;</div><div class="line">        e.CanExecute = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        e.CanExecute = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    e.Handled = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">如上，用`RoutedCommand`新建一个（第三个参数是快捷键）；</div><div class="line">大部分是多余的，和默认相比，中心思想就是新建一个command，添加到绑定。</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="渐变画刷"><a href="#渐变画刷" class="headerlink" title="渐变画刷"></a>渐变画刷</h3><h4 id="LinearGradientBrush"><a href="#LinearGradientBrush" class="headerlink" title="LinearGradientBrush"></a>LinearGradientBrush</h4><p>我在自定义控件界面时，想对背景色渐变。<br>这个是线性渐变，默认渐变线是对角线。<br>用startpoint endpoint来设置渐变线。<br>GradientStop 它表示渐变停止点，Offset来设置渐变线中百分比的偏移量（如：offset=”0.0” 这个点是从对角线左上开始的，有下个点它就停止在下个点的offset）</p>
<h4 id="RadialGradientBrush"><a href="#RadialGradientBrush" class="headerlink" title="RadialGradientBrush"></a>RadialGradientBrush</h4><p>这个是个圆形的渐变。<br>渐变线就是圆的各个半径。<br>Center书面说它是圆的中心（这个指的是圆形状的中心），可以想象它是控制所有圆的宽窄，通过它来控制所有圆心<br>GradientOrigin渐变色开始位置（可以从圆边，和圆心）<br>RadiusX、RadiusY这俩个是半径</p>
<h3 id="样式和模板"><a href="#样式和模板" class="headerlink" title="样式和模板"></a>样式和模板</h3><p>样式：<a href="http://www.wpf-tutorial.com/styles/using-styles/" target="_blank" rel="external">http://www.wpf-tutorial.com/styles/using-styles/</a><br>分层、显隐式（x:Key; Style=”{StaticResource HeaderStyle}”）<br>//可以同一设置控件的属性内容</p>
<h4 id="控件模板"><a href="#控件模板" class="headerlink" title="控件模板"></a>控件模板</h4><p>模板：<a href="http://www.cnblogs.com/dingli/archive/2011/07/20/2112150.html" target="_blank" rel="external">http://www.cnblogs.com/dingli/archive/2011/07/20/2112150.html</a><br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">Style</span> TargetType=<span class="string">"Button"</span>&gt;</div><div class="line">    &lt;<span class="keyword">Setter</span> <span class="keyword">Property</span>=<span class="string">"Template"</span>&gt;</div><div class="line">        &lt;<span class="keyword">Setter</span>.<span class="keyword">Value</span>&gt;</div><div class="line">            &lt;ControlTemplate TargetType=<span class="string">"Button"</span>&gt;</div><div class="line">            ...</div><div class="line"></div><div class="line">//通过ControlTemplate的VisualTree内容，可以重做控件外观模板</div><div class="line">//通过tigger，&lt;ControlTemplate.Triggers&gt; &lt;<span class="keyword">Trigger</span> <span class="keyword">Property</span>=<span class="string">"IsMouseOver"</span> <span class="keyword">Value</span>=<span class="string">"true"</span>&gt; ，可以对控件的事件作出响应</div><div class="line">//控件内容显示用ContentPresenter要比ContentControl轻量一些</div></pre></td></tr></table></figure></p>
<h3 id="转换接口"><a href="#转换接口" class="headerlink" title="转换接口"></a>转换接口</h3><p>对于静态绑定到内部对象太重要了，这个接口。<br>比如：通过输入<code>no</code>，来禁止控件；一个是字符一个是bool，绑定就不会成功，所以需要转换。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">local</span>:Convert x:<span class="built_in">Key</span>=<span class="string">"toconvert"</span>&gt;&lt;/<span class="keyword">local</span>:Convert&gt;</div><div class="line">&lt;RadioButton IsEnabled=<span class="string">"&#123;Binding ElementName=tbt, Path=Content, Converter=&#123;StaticResource toconvert&#125;&#125;"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">//上面是cs文件处理，代码上继承IValueConverter自己转换便好</span></div><div class="line"><span class="comment">//由于上面是单向绑定，所以实现Convert便好</span></div><div class="line"><span class="comment">//当面对双向绑定时，ConvertBack也需要同时实现</span></div></pre></td></tr></table></figure>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>使用的结构也比较多，简单说下：<br>动画必须放入模板里面<code>Storyboard</code>,这样一个模板可以包含多个动画可以同时触发。<br>触发方式有俩种：<br>1、放入EventTrigger进行触发，只是要多个<code>BeginStoryboard</code>这样才能表示为此事件发生，模板开始触发。<br>2、放入<code>Resources</code>内（这个时候只需要<code>Storyboard</code>就够了）。因为有name属性，代码里面直接：<code>name.Begin()</code>，模板开始触发。</p>
<h3 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h3><p>custom control有点没看透，直接讲user control。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">region</span> 属性</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> DependencyProperty ShowStringProperty =</div><div class="line">    DependencyProperty.Register(<span class="string">"ShowString"</span>, <span class="keyword">typeof</span>(<span class="keyword">string</span>), <span class="keyword">typeof</span>(UserTest),</div><div class="line">        <span class="keyword">new</span> PropertyMetadata(<span class="string">"默认值"</span>, <span class="keyword">new</span> PropertyChangedCallback(OnChangeShowString)));</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnChangeShowString</span>(<span class="params">DependencyObject obj, DependencyPropertyChangedEventArgs args</span>)<span class="comment">//设置属性被修改时的回调函数</span></span></div><div class="line">&#123;</div><div class="line">    UserTest tt = obj <span class="keyword">as</span> UserTest;</div><div class="line">    tt.t1.Text = (<span class="keyword">string</span>)args.NewValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">string</span> ShowString</div><div class="line">&#123;</div><div class="line">    <span class="keyword">set</span> &#123; SetValue(ShowStringProperty, <span class="keyword">value</span>); &#125;</div><div class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> (<span class="keyword">string</span>)GetValue(ShowStringProperty); &#125;</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endregion</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">region</span> 事件</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">readonly</span> RoutedEvent ShowStringEvent =</div><div class="line">    EventManager.RegisterRoutedEvent(<span class="string">"ShowEvent"</span>, RoutingStrategy.Bubble,</div><div class="line">        <span class="keyword">typeof</span>(RoutedPropertyChangedEventHandler&lt;<span class="keyword">object</span>&gt;), <span class="keyword">typeof</span>(UserTest));</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">event</span> RoutedPropertyChangedEventHandler&lt;<span class="keyword">object</span>&gt; ShowEvent</div><div class="line">&#123;</div><div class="line">    add &#123; AddHandler(ShowStringEvent, <span class="keyword">value</span>); &#125;</div><div class="line">    remove &#123; RemoveHandler(ShowStringEvent, <span class="keyword">value</span>); &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BtnClickme</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)<span class="comment">//这是自定义控件给button加了个事件，这样这个函数就会通知外面我的自定义事件</span></span></div><div class="line">&#123;</div><div class="line">    RoutedPropertyChangedEventArgs&lt;<span class="keyword">object</span>&gt; arg =</div><div class="line">        <span class="keyword">new</span> RoutedPropertyChangedEventArgs&lt;<span class="keyword">object</span>&gt;(sender, e, ShowStringEvent);</div><div class="line">    RaiseEvent(arg);</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endregion</span></span></div><div class="line">&lt;local:UserTest HorizontalAlignment=<span class="string">"Center"</span> VerticalAlignment=<span class="string">"Bottom"</span> ShowString=<span class="string">"wangqiu"</span> ShowEvent=<span class="string">"UserTest_ShowEvent"</span> &gt;&lt;/local:UserTest&gt;</div></pre></td></tr></table></figure>
<p>都是先注册静态变量创建，再编写属性设置。</p>
<h4 id="依赖属性"><a href="#依赖属性" class="headerlink" title="依赖属性"></a>依赖属性</h4><p>wpf的控件是有共享的内存的，所以上面属性注册全用依赖属性注册。<br>官方说转换的时候 DependencyProperty.UnsetValue 会清空当前属性值。null 传给依赖属性是不行的，会被寻找其它值。</p>
<h3 id="ControlTemplate和ContentTemplate"><a href="#ControlTemplate和ContentTemplate" class="headerlink" title="ControlTemplate和ContentTemplate"></a>ControlTemplate和ContentTemplate</h3><p>前者可以改变控件的外形。后者改变控件的内容。<br>比如你的button，想变成圆形，就用前者。你想<code>Content=&quot;asasas&quot;</code>这些内容圆形显示时就用后者。</p>
<p>由于强大的xaml，使的内容和形状都可以用控件表述。但是表述内容和DataTemplate联合无疑是好的选择: <a href="http://www.cnblogs.com/zhouhb/p/3284827.html" target="_blank" rel="external">http://www.cnblogs.com/zhouhb/p/3284827.html</a></p>
<h3 id="ZIndex"><a href="#ZIndex" class="headerlink" title="ZIndex"></a>ZIndex</h3><p>数字越小则层数越低，数字最大的在最前面</p>
<h3 id="RenderTransform"><a href="#RenderTransform" class="headerlink" title="RenderTransform"></a>RenderTransform</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Label.RenderTransform</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">RotateTransform</span> <span class="attr">Angle</span>=<span class="string">"180"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Label.RenderTransform</span>&gt;</span></div></pre></td></tr></table></figure>
<p>1、RotateTransform：元素旋转：</p>
<blockquote>
<p>Angle：旋转角度。<br>CenterX：旋转水平中心。<br>CenterY旋转的垂直中心}这两个是绝对定位坐标，<br>而RenderTransformOrigin是相对定位的</p>
</blockquote>
<p>2、ScaleTransform：会对元素水平，垂直方向上缩放。</p>
<blockquote>
<p>CenterX：缩放水平中心。CenterY缩放的垂直中心<br>ScaleX：水平缩放倍数 ScaleY：垂直缩放倍数。</p>
</blockquote>
<p>3、SkewTransform：元素倾斜：</p>
<blockquote>
<p>CenterX：倾斜水平中心。CenterY倾斜的垂直中心<br>AngleX：水平倾斜角度。AngleY：垂直倾斜角度。</p>
</blockquote>
<p>4、TranslateTransform：元素移动(只对RenderTransform有效果)</p>
<blockquote>
<p>X=水平移动像素，Y=垂直移动像素。</p>
</blockquote>
<h3 id="OpacityMask"><a href="#OpacityMask" class="headerlink" title="OpacityMask"></a>OpacityMask</h3><p>简单形状的渐变直接fill渐变画刷就好了（而且画刷颜色直接指定透明度）。<br>可是路径和图片也要渐变的改变透明度只能用<code>OpacityMask</code></p>
<p><code>Opacity</code>是指定控件的透明度</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Image.OpacityMask</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">LinearGradientBrush</span> <span class="attr">StartPoint</span>=<span class="string">"0,0"</span> <span class="attr">EndPoint</span>=<span class="string">"0,1"</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">GradientStop</span> <span class="attr">Color</span>=<span class="string">"#FFFFFFFF"</span> <span class="attr">Offset</span>=<span class="string">"0"</span>/&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">GradientStop</span> <span class="attr">Color</span>=<span class="string">"#00FFFFFF"</span> <span class="attr">Offset</span>=<span class="string">"1"</span>/&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">LinearGradientBrush</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">Image.OpacityMask</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>在 WPF 中绝大部分控件都继承自 DispatcherObject，<br>甚至包括 Application。这些继承自 DispatcherObject 的对象具有线程关联特征，<br>也就意味着只有创建这些对象实例，且包含了 Dispatcher 的线程(通常指默认 UI 线程)才能直接对其进行更新操作</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c#入门经典(3)(203)]]></title>
      <url>https://xuecat.github.io/2016/12/06/203/</url>
      <content type="html"><![CDATA[<p><img src="/picture/y1.jpg" alt=""></p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[DebuggerStepThrough]<span class="comment">//调试跳过下面方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DullMethod</span><span class="params">()</span> </span>&#123;...&#125;</div><div class="line"></div><div class="line">[DoesInterestingThings(<span class="number">1000</span>, WhatDoesItDo = <span class="string">"voodoo"</span>)]</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> DecoratedClass &#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> T Sum&lt;T&gt;(params T[] Args)</div><div class="line">&#123;</div><div class="line">    T sum = Args[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Args.Length; ++i)</div><div class="line">    &#123;</div><div class="line">         sum += Args[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;<span class="comment">//上面这一段代码并不会编译通过</span></div></pre></td></tr></table></figure>
<p>在C++中这是最最基本的函数模板，但是在C#中代码通不过，<br>因为泛型不是模板，它不会生成多份代码，T是当做object来处理的，<br>因此不能用来进行加法运算。</p>
<p>##所以c#又引入了动态类型的概念##<br>便可以如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> T Sum&lt;T&gt;(params T[] Args)</div><div class="line">&#123;</div><div class="line">    dynamic sum = Args[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Args.Length; ++i)</div><div class="line">    &#123;</div><div class="line">         sum += Args[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>C#编译器允许你通过dynamic对象调用任何方法，即使这个方法根本不存在，<br>编译器也不会在编译的时候报编译错误。只有在运行的时候，<br>它才会检查这个对象的实际类型</p>
<p>再看一段代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Duck</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">QQ</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(<span class="string">"qq"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">"qq"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Humen</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GG</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(<span class="string">"gg"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">"gg"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> Program</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">DoQG</span><span class="params">(dynamic dy)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">string</span> result = dy.GG();<span class="comment">//由于是dynamic，所以任何代码都是对的，编译器更不会报错</span></div><div class="line">        <span class="keyword">return</span> result ?? <span class="string">"hehe"</span>;<span class="comment">//但是执行的话，由于duck类是没有GG这个函数的。会直接抛出异常。</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(<span class="built_in">string</span>[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        Duck duck = <span class="keyword">new</span> Duck();</div><div class="line">        Humen hu = <span class="keyword">new</span> Humen();</div><div class="line"></div><div class="line">        Console.WriteLine(DoQG(hu));</div><div class="line">        Console.WriteLine(DoQG(duck));</div><div class="line">        Console.ReadKey();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="LINQ-Language-Integrated-Query"><a href="#LINQ-Language-Integrated-Query" class="headerlink" title="LINQ(Language Integrated Query)"></a>LINQ(Language Integrated Query)</h3><p>它使得查询语句可以像数据库那样执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int[] scores = new int[] &#123; 97, 92, 81, 60 &#125;;</div><div class="line">IEnumerable&lt;int&gt; sc = from score in scores where</div><div class="line">                        score &gt; 80 select score;</div><div class="line">//如果自定义类型要如此的话，必须重写IEnumerable&lt;T&gt;接口</div></pre></td></tr></table></figure></p>
<p>太多了，先跳过吧！</p>
<h3 id="释放非托管的资源"><a href="#释放非托管的资源" class="headerlink" title="释放非托管的资源"></a>释放非托管的资源</h3><p>c#的析构函数使用较少，释放的时机和位置由于不确定。<br>官方建议用<code>IDisposable</code>接口来代替析构函数(用于准确释放资源)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Myclass : IDisposable</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//其用法有俩种</span></div><div class="line"></div><div class="line">Myclass dd = null;</div><div class="line"><span class="keyword">try</span> </div><div class="line">&#123;</div><div class="line">    dd = <span class="keyword">new</span> Myclass();</div><div class="line">    ...</div><div class="line">    <span class="comment">//do something</span></div><div class="line">&#125;</div><div class="line">finally</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (dd)</div><div class="line">        dd.Dispose();</div><div class="line">&#125;</div><div class="line"><span class="comment">//以上做法保证了无论执行是否成功或异常，都要赶紧释放资源。唯一的确定就是写法太繁杂</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> (Myclass dd = <span class="keyword">new</span> Myclass())</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">//do something</span></div><div class="line">&#125;<span class="comment">//如此写法就可以到相同效果</span></div></pre></td></tr></table></figure></p>
<hr>
<p>再说明下：<br>托管资源：由CLR管理分配和释放的资源，即由CLR里new出来的对象；<br>非托管资源：不受CLR管理的对象，windows内核对象，如文件、数据库连接、套接字、COM对象、gdi对象等；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> SampleClass : IDisposable</div><div class="line">&#123;</div><div class="line">    <span class="comment">//演示创建一个非托管资源</span></div><div class="line">    <span class="keyword">private</span> IntPtr nativeResource = Marshal.AllocHGlobal(<span class="number">100</span>);</div><div class="line">    <span class="comment">//演示创建一个托管资源</span></div><div class="line">    <span class="keyword">private</span> AnotherResource managedResource = <span class="keyword">new</span> AnotherResource();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> disposed = <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/// &lt;summary&gt;</span></div><div class="line">    <span class="comment">/// 实现IDisposable中的Dispose方法</span></div><div class="line">    <span class="comment">/// &lt;/summary&gt;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">//必须为true</span></div><div class="line">        Dispose(<span class="literal">true</span>);</div><div class="line">        <span class="comment">//通知垃圾回收机制不再调用终结器（析构器）</span></div><div class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/// &lt;summary&gt;</span></div><div class="line">    <span class="comment">/// 不是必要的，提供一个Close方法仅仅是为了更符合其他语言（如C++）的规范</span></div><div class="line">    <span class="comment">/// &lt;/summary&gt;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Close</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        Dispose();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/// &lt;summary&gt;</span></div><div class="line">    <span class="comment">/// 必须，以备程序员忘记了显式调用Dispose方法</span></div><div class="line">    <span class="comment">/// &lt;/summary&gt;</span></div><div class="line">    ~SampleClass()</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//必须为false</span></div><div class="line">        Dispose(<span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/// &lt;summary&gt;</span></div><div class="line">    <span class="comment">/// 非密封类修饰用protected virtual</span></div><div class="line">    <span class="comment">/// 密封类修饰用private</span></div><div class="line">    <span class="comment">/// &lt;/summary&gt;</span></div><div class="line">    <span class="comment">/// &lt;param name="disposing"&gt;&lt;/param&gt;</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span><span class="params">(<span class="keyword">bool</span> disposing)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (disposed)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (disposing)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 清理托管资源</span></div><div class="line">            <span class="keyword">if</span> (managedResource != null)</div><div class="line">            &#123;</div><div class="line">                managedResource.Dispose();</div><div class="line">                managedResource = null;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 清理非托管资源</span></div><div class="line">        <span class="keyword">if</span> (nativeResource != IntPtr.Zero)</div><div class="line">        &#123;</div><div class="line">            Marshal.FreeHGlobal(nativeResource);</div><div class="line">            nativeResource = IntPtr.Zero;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//让类型知道自己已经被释放</span></div><div class="line">        disposed = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SamplePublicMethod</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (disposed)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ObjectDisposedException(<span class="string">"SampleClass"</span>, <span class="string">"SampleClass is disposed"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//省略</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重写Dispose接口为了及时释放非托管资源。<br>编写析构函数为了确保CLR的自动释放。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c#入门经典(2)(202)]]></title>
      <url>https://xuecat.github.io/2016/12/01/202/</url>
      <content type="html"><![CDATA[<p><img src="/picture/t2.jpg" alt=""></p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="default"><a href="#default" class="headerlink" title="default"></a>default</h4><p>由于泛型T不确定是值类型还是引用类型，所以<br><code>T a = null</code>这句是错误的（值类型就空了）。</p>
<p><code>T a = default(null)</code>这样的话值类型就是0，引用类型就是null</p>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>这个一般是yield return, yield break联合使用；如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; SName(<span class="keyword">int</span> a)</div><div class="line">&#123;</div><div class="line">    yield <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    yield <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">    yield <span class="keyword">return</span> <span class="number">6</span>;</div><div class="line">    yield <span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//注意返回值必须是 IEnumerable 或 IEnumerator</span></div><div class="line"><span class="comment">//好像说这种方法比在函数里面push或add更有效</span></div></pre></td></tr></table></figure></p>
<h3 id="c-遍历属性"><a href="#c-遍历属性" class="headerlink" title="c#遍历属性"></a>c#遍历属性</h3><p>我今天想遍历一个类的属性，发现必须满足以下几点:</p>
<ol>
<li>必须是属性，不能是成员。</li>
<li>必须是<code>public</code></li>
</ol>
<p>满足以上后才能用循环到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">T tdata = new T();</div><div class="line">PropertyInfo[] userpros = tdata.GetType().GetProperties();</div><div class="line">foreach (var pro in userpros) &#123;&#125;</div></pre></td></tr></table></figure></p>
<h4 id="where约束"><a href="#where约束" class="headerlink" title="where约束"></a>where约束</h4><p>这个我不是很深，以后补充；先看段代码。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">class MyBase&lt;T&gt;</div><div class="line">    where T: class</div><div class="line">    , new() &#123;</div><div class="line">    public MyBase() &#123;</div><div class="line">        Console.WriteLine("base");</div><div class="line">    &#125;</div><div class="line">    public MyBase(int n)</div><div class="line">        :this() &#123;</div><div class="line">        Console.WriteLine("base");</div><div class="line">    &#125;</div><div class="line">    public virtual T ShowD() &#123;</div><div class="line">        Console.WriteLine("MyBase");</div><div class="line">        T b = new T();//这里很重要</div><div class="line">        return b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyDrive&lt;D&gt; : MyBase&lt;D&gt;, IEnumerable</div><div class="line">    where D: class, new() &#123;</div><div class="line">    public MyDrive()</div><div class="line">        : base(3) &#123;</div><div class="line">        Console.WriteLine("Drive");</div><div class="line">    &#125;</div><div class="line">    public MyDrive(int a)</div><div class="line">    &#123; &#125;</div><div class="line">    public override D ShowD() &#123;</div><div class="line">        Console.WriteLine("MyDrive");</div><div class="line">        D b = new D();//这句很重要</div><div class="line">        return b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyDrive&lt;Program&gt; my = new MyDrive&lt;Program&gt;(3);//调用</div></pre></td></tr></table></figure></p>
<p>第一个类；where对T约束为引用类型（值类型可以用struct），这样调用<code>&lt;&gt;</code>里面就只能是引用类型了<br>除此外where还约束为new()，表示<code>&lt;&gt;</code>里的类型必须有默认的构造函数，这样才可以用<code>new T()</code>这样的代码（测试发现里面不能加参数）</p>
<p>where还可以准确约束，有点像c++的模板特例化</p>
<h4 id="协变和抗变"><a href="#协变和抗变" class="headerlink" title="协变和抗变"></a>协变和抗变</h4><p><a href="http://blog.csdn.net/sudazf/article/details/17148971" target="_blank" rel="external">http://blog.csdn.net/sudazf/article/details/17148971</a></p>
<h4 id="可空类型及运算符"><a href="#可空类型及运算符" class="headerlink" title="可空类型及运算符"></a>可空类型及运算符</h4><p>可空类型原型是<code>System.Nullable&lt;T&gt;</code>，简单型<code>T?</code><br>网上说它是为了sql设计<br>操作符可以和原型相同<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//？？是判断是否为空</span></div><div class="line"><span class="keyword">int</span>? x = <span class="number">3</span>;</div><div class="line"><span class="keyword">int</span> y = x ?? <span class="number">5</span>;<span class="comment">//y:3</span></div><div class="line"></div><div class="line">x = <span class="number">0</span>;</div><div class="line">y = x ?? <span class="number">6</span>;<span class="comment">//x:0 y:0</span></div><div class="line"></div><div class="line">x = null;</div><div class="line">y = x ?? <span class="number">7</span>;<span class="comment">//x:null y:7</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//再看运算符应用（好像它只能用于引用类型，不能用于值类型）</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">DoQG</span><span class="params">(dynamic dy)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">string</span> result = dy.GG();</div><div class="line">    <span class="keyword">return</span> result ?? <span class="string">"hehe"</span>;</div><div class="line">&#125;</div><div class="line">MyClass hh = <span class="keyword">new</span> MyClass();</div><div class="line">YouClass yy = <span class="keyword">new</span> YouClass();</div><div class="line">MyClass sss = yy ?? null;</div></pre></td></tr></table></figure></p>
<h4 id="各个泛型容器及性能"><a href="#各个泛型容器及性能" class="headerlink" title="各个泛型容器及性能"></a>各个泛型容器及性能</h4><p>队列Queue<t><br>栈Statck<t><br>链表LinkedList<t><br>有序列表SortedList<tkey, tvalue="">, IComparef<tkey>接口用于排序<br>字典Dictionary<tkey, tvalue=""> 无排序 键类型需要实现GethashCode和IEquatable<t><br>有序字典SortedDictionary<tkey, tvalue=""><br>集 HashSet<t><br>有序集 SortedSet<t></t></t></tkey,></t></tkey,></tkey></tkey,></t></t></t></p>
<p>书上本来是有个性能表，但是纠结了感觉没啥用，就不写等以后更新。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> internal IMyInter&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Do</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>暂时看它和虚基类没啥区别呀！！！！！！以后再加吧。</p>
<h4 id="foreach的自定义"><a href="#foreach的自定义" class="headerlink" title="foreach的自定义"></a>foreach的自定义</h4><p>自定义类要使用foreach，就必须实现IEnumerator和IEnumerable<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MyDrive : IEnumerable</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span><span class="params">()</span></span></div><div class="line">    &#123; <span class="keyword">return</span> <span class="keyword">new</span> MyTor(); &#125;</div><div class="line"></div><div class="line">    <span class="keyword">class</span> MyTor : IEnumerator</div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">MoveNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">        <span class="keyword">public</span> object Current &#123; get &#123; <span class="keyword">return</span> null; &#125; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">MyDrive ss = <span class="keyword">new</span> MyDrive();</div><div class="line">foreach (var t in ss) &#123;&#125;</div></pre></td></tr></table></figure></p>
<h4 id="排序搜索等"><a href="#排序搜索等" class="headerlink" title="排序搜索等"></a>排序搜索等</h4><p>本以为较简单的，看了下发现和其它还有关，就记录了。<br>两种：<br>IComparable在要比较的对象类中实现，可以比较该对象和另一对象<br>IComparer在一个单独的类中实现，可以比较任意俩个对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person : IComparable</div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span> <span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> i)</span></span></div><div class="line">    &#123;</div><div class="line">        Name = s;</div><div class="line">        Age = i;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CompareTo</span><span class="params">(object obj)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (obj is Person)</div><div class="line">        &#123;</div><div class="line">            Person ot = obj as Person;</div><div class="line">            <span class="keyword">return</span> ot.Age - <span class="keyword">this</span>.Age;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> PersonCompareName : IComparer</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Compare</span><span class="params">(object x, object y)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (x is Person &amp;&amp; y is Person)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> Comparer.Default.Compare(</div><div class="line">                ((Person)x).Name,</div><div class="line">                ((Person)y).Name);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(<span class="built_in">string</span>[] args)</span></span></div><div class="line">&#123;</div><div class="line">    List&lt;Person&gt; asa = <span class="keyword">new</span> List&lt;Person&gt;();</div><div class="line">    asa.Add(<span class="keyword">new</span> Person(<span class="string">"nam1"</span>, <span class="number">1</span>));</div><div class="line">    asa.Add(<span class="keyword">new</span> Person(<span class="string">"nam2"</span>, <span class="number">2</span>));</div><div class="line">    asa.Add(<span class="keyword">new</span> Person(<span class="string">"nam3"</span>, <span class="number">3</span>));</div><div class="line"></div><div class="line">    asa.Sort();<span class="comment">//排序会进行比较，这个比较会调用IComparable的CompareTo</span></div><div class="line"></div><div class="line">    PersonCompareName ii = <span class="keyword">new</span> PersonCompareName();</div><div class="line">    asa.Sort(ii.Compare);<span class="comment">//这个排序比较会调用IComparer的Compare</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="其它接口"><a href="#其它接口" class="headerlink" title="其它接口"></a>其它接口</h5><ul>
<li><p>搜索<br>如同排序，搜索本身是Predicate<t>继承，传入的话直接一个static函数就好了。<br>搜索可以返回数组</t></p>
</li>
<li><p>字典<br>Dictionary<k, v="">，这个字典缺点就是添加的键值不能相同，同了就抛出异常。<br>所以每次add要判断是否存在，感觉好麻烦！</k,></p>
</li>
</ul>
<p><strong>添加元素</strong> AddRange()，IEnumerable<t><br><strong>删除元素</strong> RemoveAt，IEquatable<t>接口<br><strong>搜索元素</strong> IndexOf、LastIndexOf()、FindIndex()、FindLastIndex()、Find()、FindLast()，IEquatable<t>接口<br><strong>排序元素</strong> Sort()、Comparison<t>和IComparer<t>前面已讲</t></t></t></t></t></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c#空字符和无字符(201)]]></title>
      <url>https://xuecat.github.io/2016/12/01/201/</url>
      <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> str1=stirng.Empty;</div><div class="line"><span class="built_in">string</span> str2=<span class="string">""</span>;</div><div class="line"><span class="built_in">string</span> str3=null;</div></pre></td></tr></table></figure>
<p>str1和str2暂时可视为无区别，但建议多str1<br>str3是空指针，堆上没有开辟内存的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[windbg调试(200)]]></title>
      <url>https://xuecat.github.io/2016/12/01/200/</url>
      <content type="html"><![CDATA[<p>64位寻址到16EB （1EB=1000TB）x64控制寻址范围16TB</p>
<p>ps: 退出指令 <code>q</code> 就好了。</p>
<p>dump：<a href="https://social.technet.microsoft.com/Forums/scriptcenter/zh-CN/e79d38d9-7360-41e5-8288-24f978877755/dump" target="_blank" rel="external">https://social.technet.microsoft.com/Forums/scriptcenter/zh-CN/e79d38d9-7360-41e5-8288-24f978877755/dump</a></p>
<p>vector: <a href="https://stackoverflow.com/questions/48938003/windbg-c-how-to-print-vector-contents" target="_blank" rel="external">https://stackoverflow.com/questions/48938003/windbg-c-how-to-print-vector-contents</a><br><a href="https://0cch.com/2014/08/16/dump-stle79a84vectorefbc8clistefbc8cmape79a84e4b889e4b8aawindbge8849ae69cac/" target="_blank" rel="external">https://0cch.com/2014/08/16/dump-stle79a84vectorefbc8clistefbc8cmape79a84e4b889e4b8aawindbge8849ae69cac/</a></p>
<p>如果只想程序运行时的内存dump，直接从资源管理器；进程tab页上，选中程序右键，就有个产生dump选项。</p>
<p>debug工具一般都有debugger.chm这个文档可以参考<br><strong>x64</strong>:</p>
<ol>
<li>拖拽到windbg，lm查看模块状态</li>
<li>查看时间戳(lmt, 我自己喜欢<code>lmt sm</code>)，找到对应pdb，设置pdb路径</li>
<li>重新加载pdb(.reload)，运行分析命令(!analyze -v)<br>一般崩溃会有exception，就查找这个字符串，就可以找到对应执行函数。(~N s切换到N号线程，主线程是0号,后面要加个<code>s</code>表示线程)<br>主线程没有就切换到其它线程查找(<code>~*e kb</code>， 建议使用<code>~* kb</code> 这样会列出线程号和更多信息)</li>
</ol>
<p><strong>需要确认指令(需要实践)</strong>:<br>托管代码，由托管器管理内存等，c++ clr工程就是。c#就是托管代码<br><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">!dumpheap  显示托管堆的信息</div><div class="line">!dumpheap -stat 检查当前所有托管类型的统计信息</div><div class="line">!dumpheap -type Person –stat 在堆中查找指定类型（person）对象，注意大小写敏感</div><div class="line">!clrstack  显示调用栈</div><div class="line">!clrstack -p 显示调用栈，同时显示参数</div><div class="line">!clrstack 只显示托管代码，而kb只显示非托管代码</div><div class="line">!dumpobj(!do)  显示一个对象的内容</div><div class="line">!dumparray(!da)  显示数组</div><div class="line">!DumpStackObjects(!dso) 当前线程对象分配过程</div></pre></td></tr></table></figure></p>
<p><strong>找到hang住线程</strong>:<br><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">!threads</div><div class="line">~* e!clrstack</div><div class="line">!syncblk</div></pre></td></tr></table></figure></p>
<p><strong>x32</strong>:<br>基本相同，但是当32位程序运行在64位系统的时候，产生的dump</p>
<ol>
<li>先加载64位的扩展(.load wow64exts)</li>
<li>切换到32位模式(!sw)</li>
<li>然后才再像上面那样调试</li>
</ol>
<hr>
<h3 id="源码条件语句"><a href="#源码条件语句" class="headerlink" title="源码条件语句"></a>源码条件语句</h3><h4 id="int类型的断点"><a href="#int类型的断点" class="headerlink" title="int类型的断点"></a>int类型的断点</h4>  <figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bp `WindbgStudyDlg.cpp:<span class="number">198</span>` ".<span class="keyword">if</span> (poi(as)==<span class="number">3</span>)&#123;.<span class="built_in">echo</span> heheok&#125; .<span class="keyword">else</span> &#123;.<span class="built_in">echo</span> MyVar Acceptable; gc&#125;"</div></pre></td></tr></table></figure>
<p>  官方只给了<code>bp</code>的例子，感觉确实只有它能条件断</p>
<ol>
<li>必须用<code>poi</code>指定变量(这里我有个变量<code>as</code>,用这个指令才能指定它)</li>
<li>.echo 输出</li>
<li><code>gc</code>即<code>Go from Conditional Breakpoint</code>,从断点处继续执行</li>
<li><p>第二个<code>echo</code>会自动输出变量名</p>
<h4 id="字符类型的断点"><a href="#字符类型的断点" class="headerlink" title="字符类型的断点"></a>字符类型的断点</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">as</span> /mu $&#123;/v:mystr&#125; @@( MyNest-&gt;Nestin.Buffer );</div><div class="line">.block &#123; r $t0 = $spat( <span class="string">"$&#123;mystr&#125;"</span>, <span class="string">"*11"</span> ); &#125;</div><div class="line">.<span class="keyword">if</span>( @$t0 != <span class="number">1</span> ) &#123; gc &#125; ;</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>使用: <code>bp mytest!mytest::ttfun &quot;$$&lt;d:\\commands.txt&quot;</code></li>
<li>我试了很多遍,函数内部真心没找到指令,大多网上的和官网的都是指定函数参数,也就是说我要专门把监视字符放入一个函数的参数里面才行,不然完全没法断下来。</li>
</ul>
<ol>
<li><code>MyNest-&gt;Nestin.Buffer</code>是自己指定字符串,必须是字符指针,类就自己获取或指定到指针里面</li>
<li><code>*11</code> 匹配内容</li>
<li>上面的是文件格式,不用文件记得把<code>&quot;</code>变<code>\&quot;</code></li>
</ol>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>kb后产生的地址<br>依次是：ebp地址 返回地址 参数地址<br>参数地址默认是三个，但是无对应参数时显示的参数地址是随机的。只能根据函数参数来看地址</p>
<h3 id="指令tips"><a href="#指令tips" class="headerlink" title="指令tips"></a>指令tips</h3><p>bp 在<code>.unload</code>会消失 bu则不会，bu当模块变化时会自动偏移，bp不会<br>bl 罗列断点<br>bc 清除断点(跟bl上面的编号)<br>p (f10)<br>t (f11)<br>lm sm //按文件名排序<br>lm vm {module name}//查看模块详细信息，ocx加载老是没有完整模块名，只有通过这个来查看<br>lmv 罗列模块详细信息<br>lmf 罗列模块image path(终于找到了，这个指令，上次那个加载错误路径的模块，下次就可以用这个指令来解决了)</p>
<p>!sym noisy 符合老是加载不上时，用这个开启模式；这样加载符号过程就会罗列详细信息</p>
<p>有一个数组我知道地址<br>dq 0x2721aae0 把数组展现出来<br>dt 2721aaf0  et_commonctrl::tag_ETControlData来查看第二个数组信息<br>dt this m_arrScenarioSheets <strong>查看成员变量m_arrScenarioSheets (如果要详细信息加-r)</strong><br>dt -v std::vector<csmartptr<cwndscenariosheet>,std::allocator<csmartptr<cwndscenariosheet> &gt; &gt; <strong>查看结构体占用字节数</strong></csmartptr<cwndscenariosheet></csmartptr<cwndscenariosheet></p>
<h3 id="符号tips"><a href="#符号tips" class="headerlink" title="符号tips"></a>符号tips</h3><p>今天又测试了下，指定符号、源、exe后，lm居然没找到对应符号。。。</p>
<p>只好强制加载了。<br><strong>后来发现居然要多个后缀才行</strong>：<br><code>.reload /i simpledoc1.exe</code>这样才行。。。</p>
<p><strong>lm会全部显示，太多了，如果只想显示能加载符号的模块的话用：</strong><code>lml</code>就可以了</p>
<h3 id="栈破坏第一个例子"><a href="#栈破坏第一个例子" class="headerlink" title="栈破坏第一个例子"></a>栈破坏第一个例子</h3><hr>
<p>今天认真看了调试的第一个例子，做下记录，调试的是一个内存破坏的例子：<br>1、先用<code>k</code>命令来显示异常前的函数执行堆栈（后面跟个数字就表示显示几行， k 3：显示最后三行）</p>
<blockquote>
<p>我喜欢用<code>kpn</code>。因为<code>p</code>会列举出函数的调用参数；<code>n</code>会对他们排号，这样方便我用<code>frame</code>来切换上下文作用域；（另外说下<code>b</code>会列举参数地址，反正我也不咋习惯看，就不用）</p>
</blockquote>
<p>2、找到我方代码函数后，用<code>.frame &lt;number&gt;</code>的形式切换到函数的上下文里面。（这个 number 就是我上面说的<code>n</code>所列出的排号）</p>
<blockquote>
<p>为何要切换呢？因为我要找变量呀！！ 默认的<code>X</code>找的是全局变量，我要找局部变量就只好切进函数里去。<br>X Mytest!g<em>* //在Mytest模块中找 g</em> 开头的变量<br>切进去，我直接 X g_ 就可以找到</p>
</blockquote>
<p>3、 X指令或dv，找出变量。</p>
<blockquote>
<p>我喜欢<code>X</code>，虽然都差不多。找的的变量会自动给出此变量的地址</p>
</blockquote>
<p>4、dt转换</p>
<blockquote>
<p>拿到变量地址后，就 <code>dt CAppInfo 0x0047d768</code> 它会把此地址转换成设置的类型，并变量的成员内存一一的列举出来。<br>简单来说这就是个c式的强制转换，只是为了方便研究成员变量的有效性</p>
</blockquote>
<p>5、dd查看成员变量内存</p>
<blockquote>
<p>如上面所说，成员变量被全部列出来了，就可以一个一个查看成员变量的内存<code>dd 0x72726f43</code>。这样就判断有效和无效！</p>
</blockquote>
<hr>
<h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>bp ConsoleApplication1!main+4c 函数第4行<br>bp ConsoleApplication1.cpp:4<br>t 运行单步</p>
<h3 id="k命令"><a href="#k命令" class="headerlink" title="k命令"></a>k命令</h3><p>kb 显示的参数 从左到右分别为 ebp， ret ，arg1， arg2</p>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>r eip  查看下一指令地址<br>u eip  查看下一指令的汇编代码</p>
<h3 id="约定不一致"><a href="#约定不一致" class="headerlink" title="约定不一致"></a>约定不一致</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(<span class="number">__</span>cdecl *MYPROC)</span><span class="params">(DWORD dwOne, DWORD dwTwo)</span></span>;</div><div class="line"><span class="function">VOID <span class="title">CallProc</span><span class="params">(MYPROC pProc)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="number">__</span><span class="function">cdecl <span class="title">wmain</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    HMODULE hMod = LoadLibrary(<span class="string">L"Win32Dll.dll"</span>);</div><div class="line">    <span class="keyword">if</span> (hMod)</div><div class="line">    &#123;</div><div class="line">        MYPROC pProc = (MYPROC)GetProcAddress(hMod, <span class="string">"InitModule"</span>);</div><div class="line">        <span class="keyword">if</span> (pProc)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//这里InitModule本阿里是个__stadcall的约定，由于获取时用 __cdecl。导致函数返回前就清理了栈，使得堆栈破坏。</span></div></pre></td></tr></table></figure>
<h3 id="自动错误"><a href="#自动错误" class="headerlink" title="自动错误"></a>自动错误</h3><p>以前把程序放入windbg，指定pdb，然后运行。如果有空指针调用它会自动跳转到代码。<br>后来有几次测试，又不成功了。<br>今天我无意中发现，<code>.frame &lt;number&gt;</code>到错误的函数后，它又能自动加载跳转到代码了。</p>
<h3 id="堆错误-使用未初始化状态"><a href="#堆错误-使用未初始化状态" class="headerlink" title="堆错误-使用未初始化状态"></a>堆错误-使用未初始化状态</h3><p>此类报错，会在加载后，给出问题代码的，如果有pdb则会直接指出源代码。先看windbg显示的：<br>ConsoleApplication1!wmain+0x87:<br>00265107 c7000a000000    mov     dword ptr [eax],0Ah  ds:002b:baadf00d=????????</p>
<p>eax 的值是baadfood 填充模式时分配成功但没初始化。释放填充是feeefeee</p>
<h3 id="堆错误-堆句柄不匹配"><a href="#堆错误-堆句柄不匹配" class="headerlink" title="堆错误-堆句柄不匹配"></a>堆错误-堆句柄不匹配</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hSmallHeap = GetProcessHeap();<span class="comment">//默认堆</span></div><div class="line">hLargeHeap = HeapCreate(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//私有堆</span></div><div class="line"></div><div class="line">_DPH_BLOCK_INFORMATION有个Heap会辨识堆句柄，以此来判断堆句柄是否匹配。</div></pre></td></tr></table></figure>
<p>去找结构体，自己声明，还要自己定义（因为它定义了才会有符号，才能找到自己声明的那个结构体）</p>
<h3 id="死锁情况"><a href="#死锁情况" class="headerlink" title="死锁情况"></a>死锁情况</h3><p><code>~*e kb</code> 显示真进线程信息很有用 (<code>~* s</code>切线程 <code>切进程要加s</code>)</p>
<p>先看它们第一行信息，Unfrozen表示它们都在运行。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>  <span class="string">Id:</span> <span class="number">2384.</span>f68 <span class="string">Suspend:</span> <span class="number">1</span> <span class="string">Teb:</span> <span class="number">7</span>efdd000 Unfrozen<span class="comment">//主进程</span></div><div class="line"><span class="number">1</span>  <span class="string">Id:</span> <span class="number">2384.14</span>f4 <span class="string">Suspend:</span> <span class="number">1</span> <span class="string">Teb:</span> <span class="number">7</span>efda000 Unfrozen<span class="comment">//子线程</span></div><div class="line"><span class="comment">//这个id很有用，特别是小数点后面的数字代表EBP。</span></div><div class="line"><span class="comment">//后面的OwningThread上的值就是此数字。</span></div></pre></td></tr></table></figure></p>
<p>从堆栈看，俩个线程都在<code>NtWaitForSingleObject</code>结束。找到执行函数<code>RtlEnterCriticalSection</code>的参数<br>在分别<code>!cs 00d9a138</code> <code>!cs 00d9a150</code>(这个命令由于涉及到了内核对象，必须去服务器那边下符号)<br>发现这俩个临界区都锁住了，<code>LOCKED LockCount = 0x1 WaiterWoken = No</code>；<br>而它们的<code>OwningThread</code>则正好分别是彼此，说明是互相锁住了。</p>
<h3 id="锁中产生异常"><a href="#锁中产生异常" class="headerlink" title="锁中产生异常"></a>锁中产生异常</h3><p>临界区的<code>OwningThread</code>会被分配给一个找不到ID的地址（Windows异常模块接管），会导致接下来不会释放临界区。<br>且问题栈会有：<code>DbgBreakPoint DbgUiRemoteBreakin</code></p>
<p>微软建议，封装个类，在析构函数进行解锁。（所以建议使用CCriticalSection而不是windows对象）</p>
<h3 id="线程结束"><a href="#线程结束" class="headerlink" title="线程结束"></a>线程结束</h3><p>当主线程结束工作者线程是，工作者线程正处于分配内存或释放内存的过程中。<br>在这些操作中，堆管理器通常会获得一个临界区。<br>当工作者线程被强行结束时，堆管理器将永远无法离开临界区。<br>意思就是说你terminal时正在开辟堆时（new），可能会导致堆管理器死锁。</p>
<h3 id="DllMain的死锁问题"><a href="#DllMain的死锁问题" class="headerlink" title="DllMain的死锁问题"></a>DllMain的死锁问题</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">BOOL</span> bRet=<span class="literal">FALSE</span>;</div><div class="line">    <span class="keyword">switch</span>(fdwReason)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</div><div class="line">        &#123;</div><div class="line">            DWORD dwId=<span class="number">0</span>;</div><div class="line">            HANDLE hThread=<span class="literal">NULL</span>;</div><div class="line"></div><div class="line">            hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, InitDllProc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwId);        </div><div class="line">            <span class="keyword">if</span>(hThread)</div><div class="line">            &#123;</div><div class="line">                WaitForSingleObject(hThread, INFINITE);</div><div class="line">                CloseHandle(hThread);</div><div class="line">                bRet=<span class="literal">TRUE</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> bRet;</div><div class="line">&#125;</div><div class="line"><span class="comment">//如上此代码会陷入卡死状态。</span></div></pre></td></tr></table></figure>
<ol>
<li><p>进入dllmain后创建线程。</p>
<blockquote>
<p>当windows创建线程时，线程并不会自动从<code>kernel32!BaseThreadStart</code>开始执行；<br>而是首先由APC分发器分发一个APC到新线程，然后作为apc进行初始化完成后才会执行线程。<br>然而APC的分发有一个加载器锁来控制的，以此保护分发访问的冲突问题。<br><strong>然而对于DllMain来说，它本身就是动态库的加载和创建也会出现新线程进程，它本身也会用到APC管理器</strong><br>ps：apc分发和回收用的是同一个锁</p>
</blockquote>
</li>
<li><p>dllmain等待线程</p>
<blockquote>
<p>dllmain等待子线程的创建和设置事件。<br>然而子线程等待dllmain的APC管理器锁解锁。<br>如此就造成了死锁的情况。<br>apc的死锁导致调试线程的注入发生中断，超过30秒后；调试线程会自动挂起进程中所有线程。</p>
</blockquote>
</li>
</ol>
<h3 id="临界区的判断"><a href="#临界区的判断" class="headerlink" title="临界区的判断"></a>临界区的判断</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+<span class="number">0</span>x000 DebugInfo        : 0<span class="type">x0085c560</span> _RTL_CRITICAL_SECTION_DEBUG</div><div class="line">+<span class="number">0</span>x004 LockCount        : 0<span class="type">n</span>-<span class="number">1</span></div><div class="line">+<span class="number">0</span>x008 RecursionCount   : 0<span class="type">n0</span></div><div class="line">+<span class="number">0</span>x00c OwningThread     : (<span class="keyword"><span class="keyword">null</span></span>) </div><div class="line">+<span class="number">0</span>x010 LockSemaphore    : (<span class="keyword"><span class="keyword">null</span></span>) </div><div class="line">+<span class="number">0</span>x014 SpinCount        : 0<span class="type">xfa0</span></div></pre></td></tr></table></figure>
<p><code>dt CRITICAL_SECTION</code>和<code>!cs</code>都行。<br>当处理一个尚未被初始化的临界区，看的值都是随机的<br>当被删除的临界区，看到的值是零<br>过度释放的临界区，会导致程序挂起，<code>LockCount &lt; -1 || RscursionCount &lt; 0</code></p>
<h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><p>64位运行32位时，加载WOW（windows on windows）子系统模块</p>
<p>Mini dump代码直接实例初始化处调用RunCrashHandler<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateDumpFile</span><span class="params">(LPCTSTR lpstrDumpFilePathName, EXCEPTION_POINTERS *pException)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// 创建Dump文件    </span></div><div class="line">	<span class="comment">//    </span></div><div class="line">	HANDLE hDumpFile = CreateFile(lpstrDumpFilePathName, GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Dump信息    </span></div><div class="line">	<span class="comment">//    </span></div><div class="line">	MINIDUMP_EXCEPTION_INFORMATION dumpInfo;</div><div class="line">	dumpInfo.ExceptionPointers = pException;</div><div class="line">	dumpInfo.ThreadId = GetCurrentThreadId();</div><div class="line">	dumpInfo.ClientPointers = TRUE;</div><div class="line"></div><div class="line">	<span class="comment">// 写入Dump文件内容    </span></div><div class="line">	<span class="comment">//    </span></div><div class="line">	MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hDumpFile, MiniDumpNormal, &amp;dumpInfo, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">	CloseHandle(hDumpFile);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">LONG WINAPI <span class="title">UnhandledExceptionFilterEx</span><span class="params">(<span class="keyword">struct</span> <span class="number">_</span>EXCEPTION_POINTERS *pException)</span></span></div><div class="line">&#123;</div><div class="line">	TCHAR szMbsFile[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</div><div class="line">	::GetModuleFileName(<span class="literal">NULL</span>, szMbsFile, MAX_PATH);</div><div class="line">	TCHAR* pFind = <span class="number">_</span>tcsrchr(szMbsFile, <span class="number">_</span>T(<span class="string">'\\'</span>));</div><div class="line">	<span class="keyword">if</span> (pFind)</div><div class="line">	&#123;</div><div class="line">		*(pFind + <span class="number">1</span>) = <span class="number">0</span>;</div><div class="line">		SYSTEMTIME Time = &#123; <span class="number">0</span> &#125;;</div><div class="line">		TCHAR szGuid[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">		GUID guid;</div><div class="line">		<span class="keyword">if</span> (S_OK == ::CoCreateGuid(&amp;guid))</div><div class="line">		&#123;</div><div class="line">			<span class="number">_</span>sntprintf_s(szGuid, <span class="keyword">sizeof</span>(szGuid),</div><div class="line">				<span class="number">_</span>T(<span class="string">"%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X.dmp"</span>),</div><div class="line">				guid.Data1, guid.Data2, guid.Data3,</div><div class="line">				guid.Data4[<span class="number">0</span>], guid.Data4[<span class="number">1</span>],</div><div class="line">				guid.Data4[<span class="number">2</span>], guid.Data4[<span class="number">3</span>],</div><div class="line">				guid.Data4[<span class="number">4</span>], guid.Data4[<span class="number">5</span>],</div><div class="line">				guid.Data4[<span class="number">6</span>], guid.Data4[<span class="number">7</span>]);</div><div class="line">		&#125;</div><div class="line">		<span class="number">_</span>tcscat_s(szMbsFile, MAX_PATH, szGuid );</div><div class="line">		CreateDumpFile(szMbsFile, pException);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// <span class="doctag">TODO:</span> MiniDumpWriteDump  </span></div><div class="line">	FatalAppExit(<span class="number">-1</span>, <span class="number">_</span>T(<span class="string">"Fatal Error"</span>));</div><div class="line">	<span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunCrashHandler</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	SetUnhandledExceptionFilter(UnhandledExceptionFilterEx);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="sobey的调试"><a href="#sobey的调试" class="headerlink" title="sobey的调试"></a>sobey的调试</h3><p>以下是详细过程：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:<span class="number">028</span>&gt; .cxr</div><div class="line">Resetting <span class="keyword">default</span> scope</div><div class="line"><span class="number">0</span>:<span class="number">028</span>&gt; kn</div><div class="line"> # Child-SP          RetAddr           Call Site</div><div class="line"><span class="number">00</span> <span class="number">000000f</span>7<span class="string">`7912b898 00007fff`</span><span class="number">755d</span>13ed ntdll!NtWaitForMultipleObjects+<span class="number">0xa</span></div><div class="line"><span class="number">01</span> <span class="number">000000f</span>7<span class="string">`7912b8a0 00007fff`</span><span class="number">772f</span>132f KERNELBASE!WaitForMultipleObjectsEx+<span class="number">0xed</span></div><div class="line"><span class="number">02</span> <span class="number">000000f</span>7<span class="string">`7912bb80 00007fff`</span><span class="number">773f</span>444b kernel32!WaitForMultipleObjects+<span class="number">0xf</span></div><div class="line"><span class="number">03</span> <span class="number">000000f</span>7<span class="string">`7912bbc0 00007fff`</span><span class="number">773f</span>3e6f kernel32!WerpLaunchAeDebug+<span class="number">0x2373</span></div><div class="line"><span class="number">04</span> <span class="number">000000f</span>7<span class="string">`7912c130 00007fff`</span><span class="number">756</span>b1c1f kernel32!WerpLaunchAeDebug+<span class="number">0x1d</span>97</div><div class="line"><span class="number">05</span> <span class="number">000000f</span>7<span class="string">`7912c160 00007fff`</span><span class="number">782f</span>f1b3 KERNELBASE!UnhandledExceptionFilter+<span class="number">0x23f</span></div><div class="line"><span class="number">06</span> <span class="number">000000f</span>7<span class="string">`7912c250 00007fff`</span><span class="number">782e1</span>e26 ntdll!memset+<span class="number">0xaaf</span>3</div><div class="line"><span class="number">07</span> <span class="number">000000f</span>7<span class="string">`7912c290 00007fff`</span><span class="number">782f</span>349d ntdll!_C_specific_handler+<span class="number">0x96</span></div><div class="line"><span class="number">08</span> <span class="number">000000f</span>7<span class="string">`7912c300 00007fff`</span><span class="number">782</span>b48d7 ntdll!_chkstk+<span class="number">0x9d</span></div><div class="line"><span class="number">09</span> <span class="number">000000f</span>7<span class="string">`7912c330 00007fff`</span><span class="number">782f</span>262a ntdll!RtlRaiseException+<span class="number">0xf67</span></div><div class="line"><span class="number">0</span>a <span class="number">000000f</span>7<span class="string">`7912ca00 00000000`</span><span class="number">00000000</span> ntdll!KiUserExceptionDispatcher+<span class="number">0x3a</span></div><div class="line"><span class="number">0</span>:<span class="number">028</span>&gt; .frame /c <span class="number">5</span></div><div class="line"><span class="number">05</span> <span class="number">000000f</span>7<span class="string">`7912c160 00007fff`</span><span class="number">782f</span>f1b3 KERNELBASE!UnhandledExceptionFilter+<span class="number">0x23f</span></div><div class="line">rax=<span class="number">000000000000005</span>a rbx=<span class="number">0000000000000000</span> rcx=<span class="number">0000000000000003</span></div><div class="line">rdx=<span class="number">000000f</span>77912bcb0 rsi=<span class="number">0000000000000001</span> rdi=<span class="number">0000000000000000</span></div><div class="line">rip=<span class="number">00007f</span>ff756b1c1f rsp=<span class="number">000000f</span>77912c160 rbp=<span class="number">000000f</span>77912fbd0</div><div class="line"> r8=<span class="number">0000000000001000</span>  r9=<span class="number">0000000000000000</span> r10=<span class="number">0000000000000040</span></div><div class="line">r11=<span class="number">0000000000000286</span> r12=ffffffffffffffff r13=<span class="number">0000000000000001</span></div><div class="line">r14=<span class="number">000000f</span>77912c2c0 r15=<span class="number">00007f</span>ff6c3f182c</div><div class="line">iopl=<span class="number">0</span>         nv up ei pl zr na po nc</div><div class="line">cs=<span class="number">0033</span>  ss=<span class="number">002</span>b  ds=<span class="number">002</span>b  es=<span class="number">002</span>b  fs=<span class="number">0053</span>  gs=<span class="number">002</span>b             efl=<span class="number">00000246</span></div><div class="line">KERNELBASE!UnhandledExceptionFilter+<span class="number">0x23f</span>:</div><div class="line"><span class="number">00007f</span>ff<span class="string">`756b1c1f 448bf8          mov     r15d,eax</span></div><div class="line">0:028&gt; dq @rsp+0x48 L2</div><div class="line">000000f7`<span class="number">7912</span>c1a8  <span class="number">000000f</span>7<span class="string">`7912c2c0 00000000`</span><span class="number">00000000</span></div><div class="line"><span class="number">0</span>:<span class="number">028</span>&gt; dq <span class="number">000000f</span>7<span class="string">`7912c2c0 L2</span></div><div class="line">000000f7`<span class="number">7912</span>c2c0  <span class="number">000000f</span>7<span class="string">`7912cef0 000000f7`</span><span class="number">7912</span>ca00</div><div class="line"><span class="number">0</span>:<span class="number">028</span>&gt; .cxr <span class="number">000000f</span>7<span class="string">`7912ca00</span></div><div class="line">rax=000000f775ba1020 rbx=0000000000000000 rcx=000000f77912d170</div><div class="line">rdx=0000000000000000 rsi=000000f7704aa750 rdi=000000f7010182a0</div><div class="line">rip=0000000000000000 rsp=000000f77912d128 rbp=000000f77912db50</div><div class="line"> r8=ffffffffffffffff  r9=0000000000000001 r10=0000000000000000</div><div class="line">r11=000000f77912d170 r12=00000000000000b4 r13=000000f701013728</div><div class="line">r14=000000f701011898 r15=0000000000000000</div><div class="line">iopl=0         nv up ei pl nz na po nc</div><div class="line">cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010206</div><div class="line">00000000`<span class="number">00000000</span> ??              ???</div><div class="line"><span class="number">0</span>:<span class="number">028</span>&gt; kn</div><div class="line">  *** Stack trace <span class="keyword">for</span> last set context - .thread/.cxr resets it</div><div class="line"> # Child-SP          RetAddr           Call Site</div><div class="line"><span class="number">00</span> <span class="number">000000f</span>7<span class="string">`7912d128 00007fff`</span><span class="number">5474</span>bcd3 <span class="number">0x0</span></div><div class="line"><span class="number">01</span> <span class="number">000000f</span>7<span class="string">`7912d130 00007fff`</span><span class="number">5474e32f</span> ETHiveMLU!et_commonclass::_SEDL_ITEM_EXTENTION::~_SEDL_ITEM_EXTENTION+<span class="number">0x93a3</span></div><div class="line"><span class="number">02</span> <span class="number">000000f</span>7<span class="string">`7912d290 00007fff`</span><span class="number">54698d</span>c0 ETHiveMLU!et_commonclass::_SEDL_ITEM_EXTENTION::~_SEDL_ITEM_EXTENTION+<span class="number">0xb9ff</span></div><div class="line"><span class="number">03</span> <span class="number">000000f</span>7<span class="string">`7912d380 00007fff`</span><span class="number">5469729</span>e ETHiveMLU!CETHiveMLPlugin::InitInstance+<span class="number">0x80</span></div><div class="line"><span class="number">04</span> <span class="number">000000f</span>7<span class="string">`7912d4d0 000000f7`</span><span class="number">6</span>a3cce5e ETHiveMLU!ETMLCreatePlug+<span class="number">0x7e</span></div><div class="line"><span class="number">05</span> <span class="number">000000f</span>7<span class="string">`7912d530 000000f7`</span><span class="number">6</span>a3ccaea ETContainerMLU!CETComInterface::~CETComInterface+<span class="number">0x560e</span></div><div class="line"><span class="number">06</span> <span class="number">000000f</span>7<span class="string">`7912d7e0 000000f7`</span><span class="number">6</span>a396357 ETContainerMLU!CETComInterface::~CETComInterface+<span class="number">0x529a</span></div><div class="line"><span class="number">07</span> <span class="number">000000f</span>7<span class="string">`7912d840 000000f7`</span><span class="number">6</span>a36cdf5 ETContainerMLU!CETContainerManage::Init+<span class="number">0x7c7</span></div><div class="line"><span class="number">08</span> <span class="number">000000f</span>7<span class="string">`7912da80 00007fff`</span><span class="number">0</span>cd1d661 ETContainerMLU!ETCOM_InitSystem+<span class="number">0x35</span></div><div class="line"><span class="number">09</span> <span class="number">000000f</span>7<span class="string">`7912dab0 00007fff`</span><span class="number">0</span>cd1d280 <span class="number">0x7fff</span><span class="string">`0cd1d661</span></div><div class="line">0a 000000f7`<span class="number">7912d</span>b60 <span class="number">00007f</span>ff<span class="string">`0cf4023f 0x7fff`</span><span class="number">0</span>cd1d280</div><div class="line"><span class="number">0</span>b <span class="number">000000f</span>7<span class="string">`7912dbc0 00007fff`</span><span class="number">0</span>cbc4f5c <span class="number">0x7fff</span><span class="string">`0cf4023f</span></div><div class="line">0c 000000f7`<span class="number">7912d</span>c40 <span class="number">00007f</span>ff<span class="string">`0cbc46c1 0x7fff`</span><span class="number">0</span>cbc4f5c</div><div class="line"><span class="number">0d</span> <span class="number">000000f</span>7<span class="string">`7912dc90 00007fff`</span><span class="number">0</span>cbc4017 <span class="number">0x7fff</span><span class="string">`0cbc46c1</span></div><div class="line">0e 000000f7`<span class="number">7912d</span>cf0 <span class="number">00007f</span>ff<span class="string">`0cbc3eef 0x7fff`</span><span class="number">0</span>cbc4017</div><div class="line"><span class="number">0f</span> <span class="number">000000f</span>7<span class="string">`7912dd60 00007fff`</span><span class="number">0</span>cbc3e3f <span class="number">0x7fff</span><span class="string">`0cbc3eef</span></div><div class="line">10 000000f7`<span class="number">7912d</span>e10 <span class="number">00007f</span>ff<span class="string">`0cbc3935 0x7fff`</span><span class="number">0</span>cbc3e3f</div><div class="line"><span class="number">11</span> <span class="number">000000f</span>7<span class="string">`7912def0 00007fff`</span><span class="number">0</span>cbc16fc <span class="number">0x7fff</span><span class="string">`0cbc3935</span></div><div class="line">12 000000f7`<span class="number">7912d</span>f20 <span class="number">00007f</span>ff<span class="string">`0cbc14bf 0x7fff`</span><span class="number">0</span>cbc16fc</div><div class="line"><span class="number">13</span> <span class="number">000000f</span>7<span class="string">`7912dfc0 00007fff`</span><span class="number">0</span>cbc1416 <span class="number">0x7fff</span><span class="string">`0cbc14bf</span></div></pre></td></tr></table></figure></p>
<p>前面的都好说，dq L2 ，dq是四字方式，L2是2个四字，所以就是8字。刚好是一个指针的大小</p>
<p>0x48是函数内部的一个栈变量，至于为啥我也不知道，反正这是死命令，记住就ok了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[VA_snippets(199)]]></title>
      <url>https://xuecat.github.io/2016/11/29/199/</url>
      <content type="html"><![CDATA[<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">Aline</div><div class="line">//////////////////////////////////////////////////////////////////////////</div><div class="line"></div><div class="line">big moudle</div><div class="line">/************************************************************************/</div><div class="line">/* $end$                                                                     */</div><div class="line">/************************************************************************/</div><div class="line"></div><div class="line">brief</div><div class="line">/*</div><div class="line"> * @brief $end$</div><div class="line"> */</div><div class="line"></div><div class="line">enum</div><div class="line"> /**&lt; $end$ */</div><div class="line"></div><div class="line">member</div><div class="line"> /**&lt; @brief $end$,  */</div><div class="line"></div><div class="line"> function</div><div class="line"> /** </div><div class="line"> * @param [in]</div><div class="line"> * @param [out]</div><div class="line"> * @return</div><div class="line"> * @brief $end$</div><div class="line"> * @note</div><div class="line"> */</div><div class="line"></div><div class="line"> Time</div><div class="line"> // $end$ [$MONTH$/$DAY$/$YEAR$ %USERNAME%]</div><div class="line"></div><div class="line">Doxygen - Class Comment</div><div class="line">/*!</div><div class="line"> * @class $classname$</div><div class="line"> *</div><div class="line"> * @brief $end$</div><div class="line"> *</div><div class="line"> * @author %USERNAME%</div><div class="line"> * @date $MONTHLONGNAME$ $YEAR$</div><div class="line"> */</div><div class="line"></div><div class="line">Doxygen - Class Comment (Long)</div><div class="line">/*!</div><div class="line"> * @class $classname$</div><div class="line"> * @ingroup GroupName</div><div class="line"> * @brief $end$</div><div class="line"> *</div><div class="line"> * TODO: long description</div><div class="line"> *</div><div class="line"> * @note </div><div class="line"> * @author %USERNAME%</div><div class="line"> * @version 1.0</div><div class="line"> * @date $MONTHLONGNAME$ $YEAR$</div><div class="line"> * Contact: user@company.com</div><div class="line"> *</div><div class="line"> */</div><div class="line"></div><div class="line"> Doxygen - Header Comment</div><div class="line"> /*!</div><div class="line"> * @file $FILE_BASE$.$FILE_EXT$</div><div class="line"> *</div><div class="line"> * @author %USERNAME%</div><div class="line"> * @date $MONTHLONGNAME$ $YEAR$</div><div class="line"> *</div><div class="line"> * $end$</div><div class="line"> */</div><div class="line"></div><div class="line">Doxygen - Header Comment (Long)</div><div class="line">/*!</div><div class="line"> * @file $FILE_BASE$.$FILE_EXT$</div><div class="line"> * @date $DATE$ $HOUR$:$MINUTE$</div><div class="line"> *</div><div class="line"> * @author %USERNAME%</div><div class="line"> * Contact: user@company.com</div><div class="line"> *</div><div class="line"> * @brief $end$</div><div class="line"> *</div><div class="line"> * TODO: long description</div><div class="line"> *</div><div class="line"> * @note</div><div class="line">*/</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多线程(198)]]></title>
      <url>https://xuecat.github.io/2016/11/21/198/</url>
      <content type="html"><![CDATA[<p><img src="/picture/t1.jpg" alt=""></p>
<p>咋说呢，一直以来虽然知道<code>_beginthreadex</code>比较好。但是想起55用<code>CreateThread</code>，还是有点余悸。</p>
<p><strong>先看段原话</strong>：</p>
<p>有些CRT的函数象<code>malloc(), fopen(), _open(), strtok(), ctime(), 或localtime()</code>等函数需要专门的线程局部存储的数据块，<br>这个数据块通常需要在创建线程的时候就建立，如果使用<code>CreateThread</code>，这个数据块就没有建立，然后会怎样呢？<br>在这样的线程中还是可以使用这些函数而且没有出错，实际上函数发现这个数据块的指针为空时，会自己建立一个，<br>然后将其与线程联系在一起，这意味着如果你用<code>CreateThread</code>来创建线程，然后使用这样的函数，<br>会有一块内存在不知不觉中创建，遗憾的是，这些函数并不将其删除，而<code>CreateThread</code>和<code>ExitThread</code>也无法知道这件事，<br>于是就会有Memory Leak，在线程频繁启动的软件中(比如某些服务器软件)，迟早会让系统的内存资源耗尽！<br></p>
<hr>
<p><strong>说白了</strong>：如果多线程里面有CRT函数，最好使用<code>_beginthread</code>   <code>_beginthreadex</code>   <code>AfxBeginThread</code>(这个函数内部调用<code>_beginthreadex</code>创建处理的<code>CWinThread</code>专门的UI线程，可以通过发送接收message)</p>
<p>上面四个线程都有相应的<code>ExitThread或_endthread</code>；当然这些函数必须放入线程函数中。<br></p>
<h4 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h4><h4 id="共同的毛病1："><a href="#共同的毛病1：" class="headerlink" title="共同的毛病1："></a>共同的毛病1：</h4><p><strong>虽然</strong>：在线程被创建成功后，都可以用<code>WaitForSingleObject( hThread, INFINITE );</code>来等待线程结束。<br><strong>但是这是不准的</strong>：一些<code>begin</code>函数本身就有<code>CloseHandle</code>了（如：<code>_beginthread</code>），再加上一些代码的<code>CloseHandle</code>，<br>所以无法正确知道线程的计数到底是在哪个时候被置为0，而且被置为0也不一定会是线程退出。<br>再说执行完线程函数后，<code>beging</code>函数本身有许多代码要执行。<br><strong>也就是说，最好不要这么等待线程结束，最好给个事件、原子等放在线程函数末尾，来判断线程是否结束。</strong></p>
<h4 id="共同的毛病2："><a href="#共同的毛病2：" class="headerlink" title="共同的毛病2："></a>共同的毛病2：</h4><p>如果在线程函数中调用退出函数，是会立即退出的。<br>也就是说连执行线程函数中，定义类的析构函数都来不及，就会直接退出线程返回，<br>如果那个类有析构有内存释放的话就糟糕了，会出现内存泄漏的。<br><strong>也就是说，最好不要用退出线程函数来退出线程，用return自然返回是最好的。</strong></p>
<h4 id="内存释放："><a href="#内存释放：" class="headerlink" title="内存释放："></a>内存释放：</h4><ul>
<li>内存释放这里也有个共同点； 创建线程后直接<code>CloseHandle</code>是可以的，这样的线程对象，在函数运行完了就自动释放（就算是_beginthread等有自释放代码的类型也同样适用）</li>
</ul>
<p><code>AfxBeginThread</code>会自动<code>CloseHandle</code>；相应<code>endthread</code>函数也有<code>CloseHandle</code>代码<br><code>_beginthread</code>会自动<code>CloseHandle</code>；相应<code>endthread</code>函数也有<code>CloseHandle</code>代码<br><code>_beginthreadex</code>必须手动<code>CloseHandle</code><br><code>CreateThread</code>必须手动<code>CloseHandle</code></p>
<h4 id="比较："><a href="#比较：" class="headerlink" title="比较："></a>比较：</h4><p><code>AfxBeginThread</code>创建的线程比较庞大，一般的后台运行线程是没必要的<br><code>CreateThread</code>创建的线程无法使用CRT函数<br><code>_beginthread</code>创建的线程可以使用CRT函数，但引用官方的话来说：“使用 _beginthreadex 比 _beginthread 更为安全”；</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c#入门经典(1)(197）]]></title>
      <url>https://xuecat.github.io/2016/11/21/197/</url>
      <content type="html"><![CDATA[<p><img src="/picture/r4.jpg" alt=""></p>
<p>唉！！，es6正看着呢；去海外组了。。。。要补c#知识了</p>
<h3 id="NET程序："><a href="#NET程序：" class="headerlink" title=".NET程序："></a>.NET程序：</h3><p>使用.NET兼容语言（如c#）编写程序 -&gt; 把代码编译为CIL，存储在程序集中（即VS干的事） <br><br>-&gt; 执行时，先使用JIT编译器将代码编译为本机代码 -&gt; 在托管的CLR环境下运行本机代码。</p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><h4 id="变量类型："><a href="#变量类型：" class="headerlink" title="变量类型："></a>变量类型：</h4><p>字节数增多：sbyte(1) short(2) int(4) long(8)<br>不同的是：其它类型的<code>unsigned</code>前面加<code>u</code>就好，唯独<code>byte</code>是0到255</p>
<p>转义字符(\”表示”)和字面量(100L 100F)都和c++差不多<br>多了个新功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> strTest = <span class="string">"wangqiu"</span>;</div><div class="line"><span class="built_in">string</span> strHEHE = $<span class="string">"&#123;strTest&#125; hehe"</span> + $<span class="string">" &#123;3+5&#125;de"</span>;<span class="comment">//这样是可以的哟，用法如同js的模板字符</span></div></pre></td></tr></table></figure>
<p><strong>差点忘了说，c#中变量类型其实全是System的类，也就意味着基本变量类型本身就有很多成员函数可以使用</strong></p>
<h4 id="typeof和GetType"><a href="#typeof和GetType" class="headerlink" title="typeof和GetType"></a>typeof和GetType</h4><p>c++的是typeid，记得mfc好像有个，忘了。</p>
<p>都返回<code>System.Type</code>类型，一个是类函数一个是语言函数（参数是类名）。</p>
<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p><code>switch</code>语句有点不同，多了个<code>goto case &lt;com&gt;:</code>，用来实现在这个case语句中跳转到其它case语句中</p>
<h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><p>用法基本同；c#多了层保险，可以用<code>checked((type))</code>出现的崩溃来保证，高字节向低字节转换;也可以默认设置强制转换加check；在书67页。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>用法和c++基本同；多了个指定类型，<code>enum Type : long</code>，这样指定枚举变量的类型。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] myArray = &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;<span class="comment">//很智能，可以自动创建数组类，这样就能使用很多成员函数了。</span></div><div class="line"><span class="keyword">int</span>[] myArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>] &#123;<span class="number">6</span>, <span class="number">7</span>&#125;;<span class="comment">//new int[number],不能new int;</span></div><div class="line"></div><div class="line"><span class="comment">//数组是引用类型，开辟的元素也在堆上</span></div><div class="line"><span class="keyword">int</span>[] myArray = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</div><div class="line">var inlist = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</div></pre></td></tr></table></figure>
<p>数组的遍历可以用<code>for</code>也可以用<code>foreach(string f in fN)</code>;只是<code>foreach</code>里的f是只读属性，不能写。</p>
<ul>
<li>多元数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//几元数组就用几个`,`表示</span></div><div class="line"><span class="keyword">int</span>[,] h = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">int</span>[,] s = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;<span class="comment">//但是这种赋值会改变，声明的几元</span></div><div class="line"><span class="comment">//foreach会一行一行遍历全部元素。</span></div></pre></td></tr></table></figure>
<ul>
<li>锯齿数组<br>这个更该是数组中的数组，一个行不一定固定个数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> [][] d = &#123;</div><div class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>&#125;,<span class="comment">//这行就一个</span></div><div class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,<span class="comment">//这行俩个</span></div><div class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</div><div class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">7</span>, <span class="number">8</span>&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>数组是合并相同类型，元祖就是合并不同类型<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; tuple = Tuple.Create&lt;<span class="keyword">int</span> , <span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3.3</span>);</div></pre></td></tr></table></figure></p>
<p>暂时我认为这个东西没啥用，不如用结构体。看以后吧!</p>
<h4 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h4><p><code>var</code>会自动转换到相应的类型，当然也可以访问相应的成员函数。</p>
<h4 id="nameof"><a href="#nameof" class="headerlink" title="nameof"></a>nameof</h4><p>把变量名变成字符形式</p>
<h4 id="as和is"><a href="#as和is" class="headerlink" title="as和is"></a>as和is</h4><p>is会做俩次检查，as会做一次检查，as效率会高点<br>as类似于强制转换，转换失败便返回null<br>as只能用于引用类型和装箱转换，所以值类型还是得用is。除此外as还有隐式转换（见类的隐式显示）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MyDrive bs = <span class="keyword">new</span> MyDrive();</div><div class="line">Program pro = bs as Program;</div><div class="line"><span class="keyword">if</span> (pro) &#123;&#125;<span class="comment">//这种写法大误，被c++惯坏了。</span></div><div class="line"><span class="keyword">if</span> (pro != null)<span class="comment">//才行。如果要上面写法成功的话就必须加个隐式转换的bool</span></div></pre></td></tr></table></figure></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="参数调用顺序是从左向右"><a href="#参数调用顺序是从左向右" class="headerlink" title="参数调用顺序是从左向右"></a>参数调用顺序是从左向右</h4><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>类中函数默认是private类型的，如果访问要public<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//数组参数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span>(<span class="params"><span class="keyword">int</span>[] intA</span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//引用参数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span>(<span class="params"><span class="keyword">ref</span> <span class="keyword">int</span> val</span>) </span>&#123;&#125;</div><div class="line">Show(<span class="keyword">ref</span> intA);<span class="comment">//它调用也比较特殊，还有就是intA必须要被赋过值</span></div><div class="line"></div><div class="line"><span class="comment">//输出参数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span>(<span class="params"><span class="keyword">out</span> <span class="keyword">int</span> valA</span>) </span>&#123;&#125;</div><div class="line">Show(<span class="keyword">out</span> intA)<span class="comment">//感觉它比引用都高级</span></div></pre></td></tr></table></figure></p>
<p>函数可以重载，但是<code>out</code>和<code>ref</code>不能相同</p>
<h4 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetI</span><span class="params">()</span> </span>=&gt; <span class="number">1</span> + <span class="number">3</span>;</div><div class="line">Func&lt;<span class="built_in">string</span>, <span class="built_in">string</span> , <span class="keyword">int</span>&gt; hh = (<span class="comment">/*string */</span>x, <span class="comment">/*string */</span>y) =&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><ol>
<li>支持默认参数，同时不会在意默认参数位置（即不像c++那样默认参数必须放后面）</li>
<li>支持无序传入，<code>SName(kk:1, hh:2)</code>这种形式传入是支持的，但是如果这样写就必须把所有参数写完。</li>
</ol>
<h4 id="c-的委托和事件"><a href="#c-的委托和事件" class="headerlink" title="c#的委托和事件"></a>c#的委托和事件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">Run</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span> </span>&#123;&#125;</div><div class="line"><span class="function">delegate <span class="keyword">double</span> <span class="title">Process</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span></span>;</div><div class="line">Process tp1 = Run;</div><div class="line">Process tp2 = (<span class="keyword">int</span> p1, <span class="keyword">int</span> p2) =&gt; &#123;<span class="keyword">return</span> p1 + p2;&#125;;</div><div class="line">Process tp3 = <span class="keyword">new</span> Process(Run);<span class="comment">//标准建议这种写法，说是能明白干了什么</span></div><div class="line"></div><div class="line"><span class="function">delegate <span class="keyword">int</span> <span class="title">NumberChanger</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</div><div class="line">NumberChanger nc1 = <span class="keyword">new</span> NumberChanger(AddNum);<span class="comment">//这样才对嘛，反正引用类型都是在堆里</span></div><div class="line">NumberChanger nc2 = <span class="keyword">new</span> NumberChanger(MultNum);<span class="comment">//</span></div><div class="line"></div><div class="line">NumberChanger[] has = <span class="keyword">new</span> NumberChanger[<span class="number">3</span>];<span class="comment">//代理数组</span></div></pre></td></tr></table></figure>
<p>delegate 至少0个参数，至多32个参数，可以无返回值，也可以指定返回值类型<br>泛型Action至少0个参数，至多16个参数，无返回值<br>泛型Func至少0个参数，至多16个参数，根据返回值泛型返回。必须有返回值，不可void(它最后一个参数才表示返回)<br>泛型Predicate有且只有一个参数，返回值固定为bool</p>
<p>后面的泛型较delegate的好处是，不用先声明再使用；可以直接使用。<br>它们都可以当参数传值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Book</span><span class="params">()</span> </span>&#123; Console.WriteLine(<span class="string">"我是提供书籍的"</span>);&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Book</span><span class="params">(<span class="built_in">string</span> BookName)</span> </span>&#123;&#125;</div><div class="line">Action BookAction = <span class="keyword">new</span> Action(Book);</div><div class="line">Action BookAction1 = <span class="keyword">new</span> Action&lt;<span class="built_in">string</span>&gt;(Book);</div><div class="line">BookAction();</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> Test&lt;T1, T2&gt;(Func&lt;T1, T2, <span class="keyword">int</span>&gt; func, T1 a, T2 b) &#123; <span class="keyword">return</span> func(a, b); &#125;</div><div class="line">Console.WriteLine(Test&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(Fun,<span class="number">100</span>,<span class="number">200</span>));</div></pre></td></tr></table></figure>
<p>##关于委托我想放个链接：<a href="http://www.cnblogs.com/r01cn/archive/2012/11/30/2795977.html" target="_blank" rel="external">http://www.cnblogs.com/r01cn/archive/2012/11/30/2795977.html</a><br> 里面有多播/过滤/GetInvocationList(多播只能保证执行分别，而返回值是最后一个，而出现的)##</p>
<h5 id="匿名"><a href="#匿名" class="headerlink" title="匿名"></a>匿名</h5><p>除了lamda外，还可以这样用匿名<br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">calc.CalculationPerformedEvent += delegate(object sender, CalculationEventArgs e) &#123;</div><div class="line">    <span class="attribute">Console.WriteLine("Anonymous Calc</span>: &#123;0&#125; x &#123;1&#125; = &#123;2&#125;", e<span class="variable">.X</span>, e<span class="variable">.Y</span>, e<span class="variable">.Result</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><p>事件的实现严格需要代理的配合；关键字<code>event</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">public class Mom //事件发布器</div><div class="line">&#123;</div><div class="line">    public event Action&lt;int&gt; Eat;//订阅函数模板，这个需要代理函数的支持。所以也可以用delegate等来代替</div><div class="line">    public void Cook()//发布函数</div><div class="line">    &#123; Eat(1); &#125;</div><div class="line">&#125;</div><div class="line">public class Dad//事件订阅器</div><div class="line">&#123;</div><div class="line">    public void DEat(int a)//订阅函数</div><div class="line">    &#123; Console.WriteLine(&quot;dad eat&quot;); &#125;</div><div class="line">&#125;</div><div class="line">public class Child//事件订阅器</div><div class="line">&#123;</div><div class="line">    public void CEat(int a)//订阅函数</div><div class="line">    &#123; Console.WriteLine(&quot;child eat&quot;); &#125;</div><div class="line">&#125;</div><div class="line">class Program</div><div class="line">&#123;</div><div class="line">    static void Main(string[] args)</div><div class="line">    &#123;</div><div class="line">        Mom mom = new Mom();</div><div class="line">        Dad dad = new Dad();</div><div class="line">        Child ch = new Child();</div><div class="line"></div><div class="line">        mom.Eat += dad.DEat;//开始订阅</div><div class="line">        mom.Eat += ch.CEat;</div><div class="line"></div><div class="line">        mom.Cook();//开始发布，这样就会执行dad的DEat和ch的CEat函数。</div><div class="line"></div><div class="line">        Console.ReadKey();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//然而当传入信息更复杂时，可以如下。事件进阶版</div><div class="line">public class Food : EventArgs</div><div class="line">&#123;</div><div class="line">    private string message;</div><div class="line">    public Food()</div><div class="line">    &#123; message = &quot;wq&quot;; &#125;</div><div class="line"></div><div class="line">    public Food(string ss)</div><div class="line">    &#123; message = ss; &#125;</div><div class="line">&#125;</div><div class="line">public class Mom</div><div class="line">&#123;</div><div class="line">    public event EventHandler&lt;Food&gt; Eat;</div><div class="line">    public void Cook()</div><div class="line">    &#123; Eat(this, new Food(&quot;hi&quot;)); &#125;</div><div class="line">&#125;</div><div class="line">public class Dad</div><div class="line">&#123;</div><div class="line">    public void DEat(object obj, Food fo)</div><div class="line">    &#123; Console.WriteLine(&quot;dad eat&quot;); &#125;</div><div class="line">&#125;</div><div class="line">public class Child</div><div class="line">&#123;</div><div class="line">    public void CEat(object obj, Food fo)</div><div class="line">    &#123; Console.WriteLine(&quot;child eat&quot;); &#125;</div><div class="line">&#125;</div><div class="line">class Program</div><div class="line">&#123;</div><div class="line">    static void Main(string[] args)</div><div class="line">    &#123;</div><div class="line">        Mom mom = new Mom();</div><div class="line">        Dad dad = new Dad();</div><div class="line">        Child ch = new Child();</div><div class="line"></div><div class="line">        mom.Eat += dad.DEat;</div><div class="line">        mom.Eat += ch.CEat;</div><div class="line"></div><div class="line">        mom.Cook();</div><div class="line"></div><div class="line">        Console.ReadKey();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Action和Func"><a href="#Action和Func" class="headerlink" title="Action和Func"></a>Action和Func</h5><p><code>Action</code>本身就是代理只不过是返回void的代理；Action<int, int=""> 返回void，参数为俩int的代理。</int,></p>
<p><code>Func</code>是有返回没参数的委托</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><ol>
<li><p>带运算；<br><code>Console.WriteLine($&quot;{SName(1, 2)}&quot;)</code>;会运算了SName函数再输出；注意的是它和参数传入形式不能共存。</p>
</li>
<li><p>参数传入；<br><code>Console.WriteLine(&quot;{0}a{1}&quot;, 10.02, 121);</code>这里<code>0</code>表示后面第一个参数，随着参数增加，可以依次递增。<br>还有，它会完整输出参数的形式。不用担心是string、int、float，它全按参数形式输出。</p>
</li>
<li><p>格式符；<br>只记录几个简单的：<br>D 十进制、N数字格式、X十六进制、P百分数格式；<br><code>Console.WriteLine(String.Format(&quot;{0:N1}&quot;, 10))</code>这里{0:N1}表示第一个参数，按数字格式输出，小数点后留一位。<br>格式符后面的数字可增加，表示小数点后面的位数。但是格式符前面不能加数字，实在加要用占位符。</p>
</li>
<li><p>占位符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span>.Format(<span class="string">"&#123;0:0000.00&#125;"</span>, <span class="number">12394.039</span>) 结果为：<span class="number">12394.04</span></div><div class="line"><span class="built_in">string</span>.Format(<span class="string">"&#123;0:0000.00&#125;"</span>, <span class="number">194.039</span>) 结果为：<span class="number">0194.04</span></div><div class="line"><span class="built_in">string</span>.Format(<span class="string">"&#123;0:###.##&#125;"</span>, <span class="number">12394.039</span>) 结果为：<span class="number">12394.04</span></div><div class="line"><span class="built_in">string</span>.Format(<span class="string">"&#123;0:####.#&#125;"</span>, <span class="number">194.039</span>) 结果为：<span class="number">194</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>零占位符：<br>如果格式化的值在格式字符串中出现“0”的位置有一个数字，则此数字被复制到结果字符串中。小数点前最左边的“0”的位置和小数点后最右边的“0”的位置确定总在结果字符串中出现的数字范围。<br>“00”说明符使得值被舍入到小数点前最近的数字，其中零位总被舍去。<br>数字占位符：<br>如果格式化的值在格式字符串中出现“#”的位置有一个数字，则此数字被复制到结果字符串中。否则，结果字符串中的此位置不存储任何值。<br>请注意，如果“0”不是有效数字，此说明符永不显示“0”字符，即使“0”是字符串中唯一的数字。如果“0”是所显示的数字中的有效数字，则显示“0”字符。<br>“##”格式字符串使得值被舍入到小数点前最近的数字，其中零总被舍去。</p>
<p>但是占位符又不简单的是这些：<code>(&quot;{0:123##2.00}&quot;, 11)</code>输出：123112.00 <code>(&quot;{0:123##20.00}&quot;, 11)</code>输出：123121.00<br>看来实际用还得再测试下。</p>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>调试信息的输出，这个调试信息是输出一行，比c++方便多了。<br><code>Debug.WriteLine()</code>只能在debug模式下<br><code>Trace.WriteLine()</code>任何模式下<br><code>Debug.Assert()</code><br><code>Trace.Assert()</code></p>
<p>也支持<code>try catch finally</code> finally必执行。</p>
<h4 id="XML文档"><a href="#XML文档" class="headerlink" title="XML文档"></a>XML文档</h4><p>这个我觉得很有必要。c++一般都是doxygen语法来，c#却这么高级直接官方支持（官方的snippets简直丧心病狂，太好用了）。<br>另外官方建议用<code>Sandcastle</code>来生成相关阅读文档。</p>
<p>值列举常用的，详细：<a href="http://www.cnblogs.com/mq0036/p/3544264.html" target="_blank" rel="external">http://www.cnblogs.com/mq0036/p/3544264.html</a><br>summary：永远描述类型<br>remarks：添加有关类型的信息，补充summary<br>param：参数描述<br>returns：返回值描述<br>value: 属性说明（官方示例是set、get的那些属性）<br>example：示例代码部分<br>c：文本标记为代码<br>code：多行指示为代码<br>exception：异常说明<br>see：seealso：用<code>&lt;see cref=&quot;member&quot;/&gt;</code></p>
<h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> #<span class="meta-keyword">undef</span> #<span class="meta-keyword">if</span> #<span class="meta-keyword">elif</span> #<span class="meta-keyword">else</span> #<span class="meta-keyword">endif</span> <span class="comment">//和c++相同</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG </span></div><div class="line">    <span class="meta">#<span class="meta-keyword">warning</span> <span class="meta-string">"Don't"</span><span class="comment">//c#的警告和错误的预编译和c++不同</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Wrong"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#region #endregion<span class="comment">//折叠用</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span><span class="comment">//此指令和c++使用完全不同</span></span></div></pre></td></tr></table></figure>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="this和base"><a href="#this和base" class="headerlink" title="this和base"></a>this和base</h4><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">internal <span class="keyword">class</span> My&#123;&#125;;<span class="comment">//此关键字修饰的类，只运行同一个程序集访问（即同一exe或dll）</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> My&#123;&#125;;<span class="comment">//运行其它程序集访问</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> abstract <span class="keyword">class</span> M&#123;&#125;;<span class="comment">//也可以加private等，此修饰符是抽象类，只能继承，不能实例化</span></div><div class="line"><span class="keyword">public</span> sealed <span class="keyword">class</span> M&#123;&#125;;<span class="comment">//此修饰符不允许继承</span></div><div class="line"></div><div class="line"><span class="comment">//继承的时候要注意：编译器不允许派生类的可访性高于基类，即内部类继承公共类可以，公共类继承内部不行。</span></div><div class="line"><span class="comment">//以下不行：</span></div><div class="line">internal <span class="keyword">class</span> My&#123;&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> MD : My&#123;&#125;<span class="comment">//不行</span></div><div class="line"></div><div class="line"><span class="comment">//继承时不能有多个基类，c#只运行一个基类；但是可以加接口的</span></div><div class="line"><span class="keyword">class</span> My : MyBass, IMyInterface, IMy&#123;&#125; <span class="comment">//虽然只能一个基类，但是多个接口是可以的。注意接口必须在基类后面</span></div></pre></td></tr></table></figure>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>大量例子对属性的使用都是这样的，感觉这个属性有点多余。<br>属性支持访问控制：<code>get</code>和<code>set</code>支持使用：public、private、protected来控制访问。<br>属性支持重写：<code>abstract</code>、<code>virtual</code>、<code>override</code>这些可以联合使用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="number">_</span>age;</div><div class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">int</span> Age &#123;</div><div class="line">    get &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">_</span>age;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">set</span> &#123;</div><div class="line">        <span class="number">_</span>age = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>自动属性<code>public double Height { get; set; }</code></p>
<h4 id="构造函数和析构"><a href="#构造函数和析构" class="headerlink" title="构造函数和析构"></a>构造函数和析构</h4><p>基本和c++相同，允许重载、访问控制。<br>不同：</p>
<ul>
<li>执行顺序（MyDericed继承基类）；MyDericed myO = new MyDericed();1、执行System.Object.Object()构造函数；2、执行MyBaseClass.MyBaseClass构造函数；3、执行MyDericed构造函数</li>
<li>委托不同；<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class MyD: MyBass</div><div class="line">&#123;</div><div class="line">    public MyD() : this(5, 6)&#123;&#125;//委托给自身的另一个构造函数</div><div class="line">    public MyD(int i, int j) : base(i) &#123;&#125;//调用基类构造函数</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="对象初始化器"><a href="#对象初始化器" class="headerlink" title="对象初始化器"></a>对象初始化器</h4><p><code>HeClass hh = new HeClass(2) { _me = 3 };</code><br>HeClass有个成员_me；<br>这个功能简直装逼用，没啥实用。效率和调用构造函数一样；<br>而且成员还必须是public，不然没法访问。。。。</p>
<p>##然后就是静态构造函数##<br>编写静态构造函数的一个原因是,类有一些静态字段或属性,需要在第一次使用类之前,从外部源中初始化这些静态字段和属性<br>由于并不确定它执行的时间，所以注意下此函数中对静态变量的赋值。</p>
<h4 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h4><p>给类加个static只是告诉编译器，这个类的所有成员必须是<code>static</code>类型的，不然就报错</p>
<h4 id="类和结构体区别"><a href="#类和结构体区别" class="headerlink" title="类和结构体区别"></a>类和结构体区别</h4><p>c#中类和结构体有个大大的区别， 类是引用类型，结构体是值类型。<br>也就是说：<br>直接的<code>=</code>操作对类来说是引用赋值（是浅拷贝过程）<br>直接的<code>=</code>操作对结构体来说是复制信息（是深拷贝）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyStru st = <span class="keyword">new</span> MyStru&#123; d=<span class="number">1</span>, a=<span class="number">2</span> &#125;;<span class="comment">//值类型还是在栈空间</span></div></pre></td></tr></table></figure>
<h4 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h4><p>被嵌套在里面的类可以访问外部类的private成员，这和c++不同</p>
<p>对于嵌套类则不能把类型定义为protectcd、private和protected internal,<br>因为这些修饰符对于包含在名称空间中的类型没有意义。因此这些修饰符只能应用于成员。<br><strong>但是</strong>,如果是嵌套类的话，这些修饰符就有了些意义。</p>
<h4 id="其它定义字段"><a href="#其它定义字段" class="headerlink" title="其它定义字段"></a>其它定义字段</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> readonly <span class="keyword">int</span> MyInt = <span class="number">3</span>;<span class="comment">//表示这个字段只能在执行构造函数的过程中赋值，或由初始化赋值语句赋值。</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> MyInt;<span class="comment">//书上建议用const代替static，这样既避免出错也可以达到相同效果</span></div></pre></td></tr></table></figure>
<p>c#的extern导入的是外部程序集，经常和DllImport联合使用。</p>
<h4 id="继承使用"><a href="#继承使用" class="headerlink" title="继承使用"></a>继承使用</h4><p>c#的virtual、override、更是不同<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyClass &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span>  <span class="keyword">void</span> <span class="title">ShowD</span><span class="params">()</span> </span>&#123;</div><div class="line">            Console.WriteLine(<span class="string">"My"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">class</span> YouClass : MyClass &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">ShowD</span><span class="params">()</span> </span>&#123;</div><div class="line">            Console.WriteLine(<span class="string">"You"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">class</span> HeClass : YouClass &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">ShowD</span><span class="params">()</span> </span>&#123;</div><div class="line">            Console.WriteLine(<span class="string">"He"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//可以看出，如果想要重写，必须用virtual、override的配合</span></div><div class="line">    <span class="comment">//如果是 override sealed void... 配合的话，重写就此结束；派生类不能再重写。</span></div></pre></td></tr></table></figure></p>
<h4 id="partial部分关键字的使用"><a href="#partial部分关键字的使用" class="headerlink" title="partial部分关键字的使用"></a>partial部分关键字的使用</h4><p>partial关键字允许把类、结构或接口放在多个文件中，编译再变成一个类。<br>包括继承对象也会整合在一起（但是访问权限关键字不能整合）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Big1.cs</span></div><div class="line">partial <span class="keyword">class</span> TheBig : IMyInter1</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">//Big2.cs</span></div><div class="line">partial <span class="keyword">class</span> TheBig : IMyInter2</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//编译后就是</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> TheBig :IMyInter1, IMyInter2 </div><div class="line">&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//上面介绍了部分类，下面介绍部分方法</span></div><div class="line"><span class="keyword">public</span> partial <span class="keyword">class</span> MyClass</div><div class="line">&#123;</div><div class="line">    <span class="function">partial <span class="keyword">void</span> <span class="title">MyMethod</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> partial <span class="keyword">class</span> MyClass</div><div class="line">&#123;</div><div class="line">    <span class="function">partial <span class="keyword">void</span> <span class="title">MyMethod</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//部分方法的出现是为了解决要使用其它部分类的方法时，避免访问不到。</span></div><div class="line"><span class="comment">//但是它有以下毛病：</span></div><div class="line"><span class="comment">//0、只能存在于partial的类中</span></div><div class="line"><span class="comment">//1、总是私有类型，且不能有返回值</span></div><div class="line"><span class="comment">//2、使用的任何参数不能是out参数。但ref参数是可以的</span></div><div class="line"><span class="comment">//3、不能使用virtual、abstract、overrride、new、sealed、extern这些修饰符</span></div></pre></td></tr></table></figure></p>
<h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><p>浅拷贝由默认隐式转换和MemberwiseClone来完成不用说。<br>来看深拷贝代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> HeClass : ICloneable</div><div class="line">&#123;</div><div class="line">    HeClass(<span class="keyword">int</span> a)</div><div class="line">    &#123; <span class="number">_</span>me = a; &#125;</div><div class="line">    <span class="keyword">int</span> <span class="number">_</span>me;</div><div class="line">    <span class="function"><span class="keyword">public</span> object <span class="title">Clone</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        HeClass c = <span class="keyword">new</span> HeClass(<span class="number">_</span>me);</div><div class="line">        <span class="keyword">return</span> c;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//发现必须继承ICloneable，并重写其函数</span></div><div class="line"><span class="comment">//还要注意new的构造函数传值问题。</span></div></pre></td></tr></table></figure></p>
<h4 id="重载符函数"><a href="#重载符函数" class="headerlink" title="重载符函数"></a>重载符函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> YouClass : MyClass &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> YouClass <span class="keyword">operator</span> +(YouClass a) &#123;</div><div class="line">        YouClass yy = <span class="keyword">new</span> YouClass();</div><div class="line">        <span class="keyword">return</span> yy;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ClassA a;</div><div class="line">classB b;</div><div class="line">ClassC c;</div><div class="line">c = a + b;</div><div class="line">像这样的参数就必须是(ClassA, classB)，更重要的和顺序有关。</div></pre></td></tr></table></figure>
<p>如上操作符函数有这些要求：<br>必须是public<br>必须是static<br>返回值必须是原型</p>
<p>一元运算符：+、-、！、~、++、–、true、false<br>二元：+、-、*、/、%、&amp;、|、^、&lt;&lt;、&gt;&gt;<br>比较：==、!=、&lt;、&gt;、&lt;=、&gt;=</p>
<h4 id="隐式转换和显式转换"><a href="#隐式转换和显式转换" class="headerlink" title="隐式转换和显式转换"></a>隐式转换和显式转换</h4><p>对于引用类型来说，如下代码有误：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">MyDrive bs = <span class="keyword">new</span> MyDrive();</div><div class="line">Program pro = (Program)bs;<span class="comment">//1</span></div><div class="line">Program pro = bs;<span class="comment">//2</span></div><div class="line"></div><div class="line"><span class="comment">//如要成功，就需要支持隐式转换（2）和显式转换（1）</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> implicit <span class="keyword">operator</span> <span class="title">Program</span><span class="params">(MyDrive s)</span> </span></div><div class="line">&#123; <span class="keyword">return</span> null; &#125;<span class="comment">//隐式</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">Program</span><span class="params">(MyDrive s)</span></span></div><div class="line">&#123; <span class="keyword">return</span> null;  &#125;<span class="comment">//显式</span></div><div class="line"></div><div class="line">向MyDrive类添加如上函数便可，</div><div class="line">但是注意；相同函数隐式和显式只能存在一个，不能共存。</div></pre></td></tr></table></figure></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="函数隐藏"><a href="#函数隐藏" class="headerlink" title="函数隐藏"></a>函数隐藏</h4><p>c#会像c++那样出现函数隐藏，但是它面对函数隐藏的时候会报警告的,如果要消除警告：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MyDriver:</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">new</span> <span class="keyword">int</span> <span class="title">ShowD</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//加个new，这样做并不会改变执行时的代码调用；只是去掉编译的警告而已。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><p>所有类都派生于<code>System.Object</code>，即使定义时没指定基类也会默认继承。</p>
<h4 id="abstract和sealed"><a href="#abstract和sealed" class="headerlink" title="abstract和sealed"></a>abstract和sealed</h4><ul>
<li><code>abstract</code>对类；修饰并不能阻止其函数的定义，也无法使函数默认变成可重写类型(函数依旧需要自己声明重写类型)；<br>它对类来说就只能是个说明是接口类的作用，实际作用并没有。</li>
<li><code>abstract</code>对函数；此函数为虚函数，默认重写类型</li>
<li><code>sealed</code>对类；这样表示此类不能被继承</li>
<li><code>sealed</code>对函数；只能对可重写类型的函数才能使用（virtual abstract），表示此函数子类不能重写，常和<code>override</code>联合使用</li>
</ul>
<h4 id="拆箱和装箱"><a href="#拆箱和装箱" class="headerlink" title="拆箱和装箱"></a>拆箱和装箱</h4><p><strong>首先这俩个操作是隐式的</strong><br>所有值类型均隐式派生自System.ValueType：<br>结构体、数值、整形、字符（char）、浮点、bool、枚举、派生于System.Nullable<br>如<code>int i = new int()</code>等价于<code>int i = 0</code></p>
<p>所有引用类型均隐式派生自System.object(包括它本身)：<br>数组：（派生于System.Array）数组的元素，不管是引用类型还是值类型，都存储在托管堆上；<br>类：class（派生于System.Object）；<br>接口：interface（接口不是一个“东西”，所以不存在派生于何处的问题。）；<br>委托：delegate（派生于System.Delegate）；<br>object：（System.Object的别名）；<br>字符串：string（System.String的别名）。</p>
<p><em>今天测试了下，发现string却可以像值类型那样运作，搜索了下：</em><br><em>string最为显著的一个特点就是它具有恒定不变性：我们一旦创建了一个string，在managed heap 上为他分配了一块连续的内存空间，我们将不能以任何方式对这个string进行修改使之变长、变短、改变格式。</em><br><em>所有对这个string进行各项操作（比如调用ToUpper获得大写格式的string）而返回的string，实际上另一个重新创建的string，其本身并不会产生任何变化。 </em><br><em>每次改变值时都会建立一个新的string对象，变量会指向这个新的对象，而原来的还是指向原来的对象，所以不会改变。这也是string效率低下的原因。</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">object obj = <span class="number">1</span>;<span class="comment">//装箱</span></div><div class="line"><span class="keyword">int</span> value = (<span class="keyword">int</span>)obj;<span class="comment">//拆箱</span></div><div class="line"></div><div class="line"><span class="comment">//如上，c#中对值类型是放入栈中，对引用类型是放入堆中</span></div><div class="line"><span class="comment">//上面1是值，obj是引用。所以存在过程的转换</span></div><div class="line"><span class="comment">//这多余的转换会导致运行效率低下，所以请尽量避免。</span></div><div class="line"></div><div class="line"><span class="comment">//比如使用List&lt;obj&gt;来代替ArrayList;避免拆箱和装箱</span></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ReactRouter-tutorial（196）]]></title>
      <url>https://xuecat.github.io/2016/11/13/196/</url>
      <content type="html"><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu</a></p>
<ol>
<li>Router指定历史控件,切换路径历史直接：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; browserHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</div><div class="line">browserHistory.push(<span class="string">'/some/path'</span>);</div></pre></td></tr></table></figure>
<ol>
<li>Route来控制布局,path指定路径(path有匹配规则)，component指定控件。<br><code>&lt;Link to=&quot;/about&quot;&gt;</code> 被点击后，会激活to指定的相应路径，并渲染上面path指定的控件。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class="line">    &lt;Route path="/" component=&#123;App&#125;&gt;</div><div class="line">        &lt;Route path="/repos" component=&#123;Repos&#125;&gt;</div><div class="line">            &lt;Route path="/repos/:repoName" component=&#123;Repo&#125;/&gt;</div><div class="line">        &lt;/Route&gt;</div><div class="line">        &lt;Route path="/about" component=&#123;About&#125;/&gt;</div><div class="line">    &lt;/Route&gt;</div><div class="line">&lt;/Router&gt;</div><div class="line">//上面App包含了俩个，可以通过分别激活路径来切换显示区</div><div class="line"></div><div class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class="line">    &lt;Route path="/" component=&#123;App&#125;/&gt;</div><div class="line">    &lt;Route path="/repos" component=&#123;Repos&#125;&gt;</div><div class="line">        &lt;Route path="/repos/:repoName" component=&#123;Repo&#125;/&gt;</div><div class="line">    &lt;/Route&gt;</div><div class="line">    &lt;Route path="/about" component=&#123;About&#125;/&gt;</div><div class="line">&lt;/Router&gt;</div><div class="line">//三面三个同级，所以无论在哪个类里激活路径，都会跳转页面。</div><div class="line"></div><div class="line">//注意如果在App里面激活`/repos/:repoName`,则会先激活`/repos`再来激活它的子组件</div></pre></td></tr></table></figure>
<ol>
<li><p><code>&lt;IndexRoute component={Home}/&gt;</code> 设置默认渲染组件,如放上面1 - App下面，就会成为默认children渲染。<br> 如果想在列表有个组件相应的选中项 还要在App加个 <code>&lt;li&gt;&lt;NavLink to=&quot;/&quot; onlyActiveOnIndex={true}&gt;Home&lt;/NavLink&gt;&lt;/li&gt;</code></p>
</li>
<li><p>Contexts属性。</p>
</li>
</ol>
<ul>
<li>通过context传递属性的方式可以大量减少 通过显式的通过 props 逐层传递属性的方式。这样可以减少组件之间的直接依赖关系</li>
<li>如果你为一个组件指定了context，那么这个组件的子组件只要定义了contextTypes 属性，就可以访问到父组件指定的context了。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> A = React.createClass(&#123;</div><div class="line">    contextTypes: &#123;</div><div class="line">        name: React.PropTypes.string.isRequired,</div><div class="line">    &#125;,</div><div class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>My name is: &#123;this.context.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">React.withContext(&#123;<span class="string">'name'</span>: <span class="string">'Jonas'</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Outputs: "My name is: Jonas"</span></div><div class="line">    React.render(<span class="xml"><span class="tag">&lt;<span class="name">A</span> /&gt;</span>, document.body);</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">/////////////////////////////////////////////////////////////////////////</div><div class="line">//父类可以指定contextTypes，也可以指定childContextTypes；childContextTypes只是限定了传给子类的类型,无它就默认全下传。</div><div class="line">var A = React.createClass(&#123;</div><div class="line">    childContextTypes: &#123;</div><div class="line">         fruit: React.PropTypes.string.isRequired</div><div class="line">    &#125;,</div><div class="line">    getChildContext: function() &#123;//如果不书写这个函数，子类则无法获取</div><div class="line">         return &#123; fruit: "Banana"，name: "Apple" &#125;;</div><div class="line">    &#125;,</div><div class="line">    render: function() &#123;</div><div class="line">         return <span class="tag">&lt;<span class="name">B</span> /&gt;</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var B = React.createClass(&#123;</div><div class="line">    contextTypes: &#123;</div><div class="line">        name: React.PropTypes.string.isRequired,</div><div class="line">        fruit: React.PropTypes.string.isRequired</div><div class="line">    &#125;,</div><div class="line">    render: function() &#123;</div><div class="line">        return <span class="tag">&lt;<span class="name">div</span>&gt;</span>My name is: &#123;this.context.name&#125; and my favorite fruit is: &#123;this.context.fruit&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>;//由于父类限定了类型，所以如果是this.context.name就会报错</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">React.withContext(&#123;'name': 'Jonas'&#125;, function () &#123;//给A类，构造ContextTypes属性</div><div class="line">    React.render(<span class="tag">&lt;<span class="name">A</span> /&gt;</span>, document.body);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li>关于跳转的方式,一种是用相应的history来push，一种是用context.router来push</li>
</ol>
<p>子类的<code>contextTypes</code>其实访问的是<code>Router</code>的<code>context</code>,<code>Router</code>有个叫router的<code>RouterContext</code>类型变量</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[各个进制的表示（195）]]></title>
      <url>https://xuecat.github.io/2016/11/07/195/</url>
      <content type="html"><![CDATA[<p>二进制好像vs2012以后才支持的吧，八进制表示在15上可以。</p>
<p> 二进制：0b011(3) 0B011(3)</p>
<p> 八进制: 00011(9); js是：0o011(9) 0O011(9)</p>
<p> 十六进制: 0x011(17) 0X011(17)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js浅拷贝和深拷贝（194）]]></title>
      <url>https://xuecat.github.io/2016/10/25/194/</url>
      <content type="html"><![CDATA[<p>浅拷贝：直接赋值<br><br>深拷贝：数组（nar=ar.slice(0)、nar=ar.concat()），对象(new Object())<br></p>
<pre><code>var deepCopy = function(source) {
    var result={};
    for (var key in source) {
        result[key] = typeof source[key]===’object’? deepCoyp(source[key]): source[key];
    }
return result; 
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[node-npm指令（193）]]></title>
      <url>https://xuecat.github.io/2016/10/24/193/</url>
      <content type="html"><![CDATA[<ul>
<li><p>npm查看全局安装过的包:<code>npm list -g --depth 0</code></p>
</li>
<li><p>删除node_module模块：<code>rimraf node_module</code></p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[es6和js笔记（192）]]></title>
      <url>https://xuecat.github.io/2016/10/19/192/</url>
      <content type="html"><![CDATA[<h3 id="变量命令"><a href="#变量命令" class="headerlink" title="变量命令"></a>变量命令</h3><h4 id="var和let"><a href="#var和let" class="headerlink" title="var和let"></a>var和let</h4><ul>
<li>let只在其块级作用域内有效，而var却全局有效。</li>
<li>区块中有let和const，则这个区块暂时性死区；即区块会对这些命令声明的变量一开始就形成封闭作用域，只要在声明前使用这些变量，就会报错（相反var不会）</li>
</ul>
<h4 id="const命令只保证变量指向地址不变，不能保证数据不变。"><a href="#const命令只保证变量指向地址不变，不能保证数据不变。" class="headerlink" title="const命令只保证变量指向地址不变，不能保证数据不变。"></a>const命令只保证变量指向地址不变，不能保证数据不变。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = [];</div><div class="line">foo.prop = <span class="number">123</span>;<span class="comment">//这是被允许的</span></div><div class="line">foo = &#123;&#125;;<span class="comment">//这是不被允许的</span></div><div class="line"></div><div class="line"><span class="comment">//要完全冻结，参考如下代码</span></div><div class="line"><span class="keyword">var</span> constantize = (obj) =&gt; &#123;</div><div class="line">    <span class="built_in">Object</span>.freeze(obj);</div><div class="line">    <span class="built_in">Object</span>.key(obj).forEach((key, value) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</div><div class="line">            constantize(obj[key]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><h4 id="字符遍历。（好像用-也可以遍历）"><a href="#字符遍历。（好像用-也可以遍历）" class="headerlink" title="字符遍历。（好像用[]也可以遍历）"></a>字符遍历。（好像用<code>[]</code>也可以遍历）</h4><p>es5: for (var i=0; i<str.length; i++)="" {alert(str.charat(i));}="" <br=""><br>es6: for (let i=0 of str) {alert(i);}</str.length;></p>
<h4 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h4><p>es6多了:<br><br>includes:返回布尔，表示十分找到参数字符串。第二个参数，表示开始搜索的位置<br>startsWith:返回布尔，表示参数字符串是否在源字符串的头部。第二个参数，表示开始搜索的位置<br>endsWith:返回布尔，表示参数字符串是否在源字符串的尾部。第二个参数，表示开始搜索的位置<br>repeat:返回一个新字符串，表示将原字符串重复n次</p>
<h4 id="模板字符串，使用反引号（-这个符号）"><a href="#模板字符串，使用反引号（-这个符号）" class="headerlink" title="模板字符串，使用反引号（`这个符号）"></a>模板字符串，使用反引号（`这个符号）</h4><p>普通字符： <code>dd&#39;\n&#39;asdf</code> 这里有换行<br>多行字符： 无需连接符，所有的空格、回车和缩进都会被保留在输出中。<br>变量嵌入：<code>hello ${name} are ${time}?</code> name和time是定义的变量。如果括号里面的不是字符串，则按一般规则转换为字符，如调用toString方法<br>函数调用：function tag(s, v, d); tag<code>hello ${a+b} ${a}</code>;<br>String的raw函数</p>
<h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><p>es5中String对象的方法，search、match、replace、split支持JS正则</p>
<h3 id="类型扩展"><a href="#类型扩展" class="headerlink" title="类型扩展"></a>类型扩展</h3><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><p>Number增加成员isFinite，isNaN.<br> es6把es5中的全局函数parseInt,parseFloat移植到了Number对象上。<br>Number成员，isSafeInteger范围在2的53次方</p>
<p><code>isFinite()</code>和<code>isNaN()</code>在es5是全局，es6在<code>Math</code>上又加了相同的函数;<br>区别在于：全局的方法先调用Number把非数值转换成数值，再进行判断。<br>而新方法只对数值有效，非数值一律false</p>
<h4 id="Math对象-es6新增17个方法。它的方法都是静态方法-Math-abs-s"><a href="#Math对象-es6新增17个方法。它的方法都是静态方法-Math-abs-s" class="headerlink" title="Math对象,es6新增17个方法。它的方法都是静态方法:Math.abs(s)"></a>Math对象,es6新增17个方法。它的方法都是静态方法:<code>Math.abs(s)</code></h4><p>Math.trunc(4.2)//除去一个数的小数部分，返回整数<br><br>Math.sign();//判断一个数是正数(re:+1)、负数(re:-1)、还是零(re:0)、其它(re:NaN)<br>Math.cbrt();//计算一个数的立方根<br>对数、指数、平方等就不写了。</p>
<h4 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h4><ul>
<li><p>from函数；伪组数转换：</p>
<p>  let arraylike = {</p>
<pre><code>0: &apos;a&apos;,
1: &apos;b&apos;,
length: 2//这个属性必须有
</code></pre><p>  };//注意这是个对象，并不是数组</p>
</li>
</ul>
<p>es5中转换数组：[].slice.call(arraylike);或这么写Array.prototype.slice.call(arraylike);//[‘a’, ‘b’];<br>es6中转换数组：Array.from(arraylike);<br>//只要部署了Iterator接口的数据结构，和ES6的Set、Map。都可以转换。<br><br>//如果参数是数组，则返回新数组<br><br>//from还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组中<br></p>
<pre><code>function test(a,b,c,d) 
{ 
    var arg = Array.prototype.slice.call(arguments,1); 
    alert(arg); 
} 
test(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;); //b,c,d
</code></pre><h5 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h5><p>Array.of(2, 3, 4)//[2, 3, 4]</p>
<h4 id="find返回的是第一个符合条件的元素-1-4-5-10-find-n-gt-n-lt-0-5-1-5-find-function-value-index-arr-return-value-gt-9-10"><a href="#find返回的是第一个符合条件的元素-1-4-5-10-find-n-gt-n-lt-0-5-1-5-find-function-value-index-arr-return-value-gt-9-10" class="headerlink" title="find返回的是第一个符合条件的元素:  [1, 4, -5, 10].find((n) =&gt; n &lt; 0)//-5    [1, 5].find(function(value, index, arr) { return value &gt; 9;})//10"></a>find返回的是第一个符合条件的元素:  [1, 4, -5, 10].find((n) =&gt; n &lt; 0)//-5    [1, 5].find(function(value, index, arr) { return value &gt; 9;})//10</h4><h4 id="fill填充数组"><a href="#fill填充数组" class="headerlink" title="fill填充数组"></a>fill填充数组</h4><h4 id="entries-返回键值对遍历器，keys-返回值遍历器，values-返回键遍历器"><a href="#entries-返回键值对遍历器，keys-返回值遍历器，values-返回键遍历器" class="headerlink" title="entries()//返回键值对遍历器，keys()//返回值遍历器，values()//返回键遍历器"></a>entries()//返回键值对遍历器，keys()//返回值遍历器，values()//返回键遍历器</h4><pre><code>for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) {}
for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) {}
//es6有遍历器对象
</code></pre><h4 id="includes-返回一个布尔值，表示某个数组是否包含给定值。-1-2-3-includes-2-true"><a href="#includes-返回一个布尔值，表示某个数组是否包含给定值。-1-2-3-includes-2-true" class="headerlink" title="includes()//返回一个布尔值，表示某个数组是否包含给定值。 [1, 2, 3].includes(2);//true"></a>includes()//返回一个布尔值，表示某个数组是否包含给定值。 [1, 2, 3].includes(2);//true</h4><h3 id="函数（函数参数默认压栈顺序，从左到右）"><a href="#函数（函数参数默认压栈顺序，从左到右）" class="headerlink" title="函数（函数参数默认压栈顺序，从左到右）"></a>函数（函数参数默认压栈顺序，从左到右）</h3><h4 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h4><p>es5 </p>
<pre><code>function log (x, y) { y = y || &apos;world&apos;;}
</code></pre><p>es6</p>
<pre><code>function log(x, y = &apos;world&apos;) {}
</code></pre><ul>
<li><p>解构和默认参数</p>
<pre><code>function foo({x, y = 5}) { console.log(x, y);}
foo({})//undefined, 5
foo({x:1})//1, 5
foo({x:1, y:2})//1, 2

function m1({x=0, y=0} = {}) {}
function m2({x, y} = {x:0, y:0}) {}
//上面俩个函数，在m({x:3})、m({})这种类型时，就不同
//它们顺序是先赋值参数，再执行构里面的默认值

//默认参数位置不用在尾部。但是调用要用undefined参数，如： f(undefined, 1)

//使用默认参数会相应减少length属性的值。(function(a, b, c = 5){}).length //2
</code></pre></li>
</ul>
<h4 id="rest参数和扩展运算符"><a href="#rest参数和扩展运算符" class="headerlink" title="rest参数和扩展运算符"></a>rest参数和扩展运算符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</div><div class="line">        sum += val;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"><span class="comment">//有了rest后，就可以不使用arguments；只是注意rest参数是数组，且后面不能再有其它参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</div><div class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">        array.push(item);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = [];</div><div class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div></pre></td></tr></table></figure>
<h5 id="扩展运算符-…"><a href="#扩展运算符-…" class="headerlink" title="扩展运算符(…)"></a>扩展运算符(…)</h5><ol>
<li>当作参数声明时，它如同c的自定义长度参数，允许多个参数传入，而它就是个数组</li>
<li>当作为参数使用，定义时，它就是个数组的解构符。</li>
</ol>
<p>扩展运算符也是加三个点(…)，好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">**数组使用**</div><div class="line"><span class="comment">//es5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, w, v, h</span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arge = [<span class="number">4</span>, <span class="number">5</span>];</div><div class="line">f.apply(<span class="literal">null</span>, args);</div><div class="line"></div><div class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]);</div><div class="line"><span class="built_in">Array</span>.prototype.push.apply(args, arge);</div><div class="line">args.concat(arge, arge);</div><div class="line"></div><div class="line">**连接数组**</div><div class="line"><span class="comment">//es6</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, w, v, h</span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>];</div><div class="line">f (<span class="number">-1</span>, ...args, ...[<span class="number">7</span>]);</div><div class="line"></div><div class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]);</div><div class="line">args.push(...arge);</div><div class="line">[...args, ...arge, ...arge];</div></pre></td></tr></table></figure>
<h4 id="function有name属性（浏览器支持，es6才标准）"><a href="#function有name属性（浏览器支持，es6才标准）" class="headerlink" title="function有name属性（浏览器支持，es6才标准）"></a>function有name属性（浏览器支持，es6才标准）</h4><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数内部没有自己的this，导致内部的this就是外层代码块的this。<br><br>除此外，arguments、super、new.target也是指向外层函数对应的。</p>
<h5 id="尾调用优化-严格模式生效"><a href="#尾调用优化-严格模式生效" class="headerlink" title="尾调用优化(严格模式生效)"></a>尾调用优化(严格模式生效)</h5><p>js的函数调用会形成”调用帧”，以记录每个调用函数的信息和内部变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> m = <span class="number">1</span>; <span class="keyword">let</span> n = <span class="number">3</span>;</div><div class="line">    <span class="keyword">return</span> g(m+n);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上，这种当执行到return，就会销毁f的调用帧，只使用g的调用帧。这种”尾调用”大大的节省了内存<br><strong>注意:内层函数用到外层函数内部变量，还是无法尾调用(如: g函数内部使用f的m变量)</strong></p>
<h5 id="尾调用的尾递归-严格模式生效"><a href="#尾调用的尾递归-严格模式生效" class="headerlink" title="尾调用的尾递归(严格模式生效)"></a>尾调用的尾递归(严格模式生效)</h5><p>递归耗内存是因为保存太多的调用帧，尾调用就只有一个调用帧，所以永远不会发生”栈溢出”错误</p>
<h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><h4 id="属性简洁写法"><a href="#属性简洁写法" class="headerlink" title="属性简洁写法"></a>属性简洁写法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</div><div class="line"><span class="keyword">let</span> z = &#123;x, y&#125;<span class="comment">//&#123;x: 1, y: 2&#125; 这样以后取个好名字就ok拉，好方便</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="class"><span class="keyword">class</span>() </span>&#123;&#125;<span class="comment">//es6不同，它允许简洁写法，自己补充属性名为class</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="comment">//es5要么字符，要么自己定义属性</span></div><div class="line">    <span class="string">'class'</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="属性-属性多了-set-get描述符，可以像c-那样使用"><a href="#属性-属性多了-set-get描述符，可以像c-那样使用" class="headerlink" title="属性(属性多了 set get描述符，可以像c#那样使用)"></a>属性(属性多了 set get描述符，可以像c#那样使用)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//es5</span></div><div class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="string">'class'</span>: <span class="function"><span class="keyword">function</span> </span>&#123;&#125;<span class="comment">//此处，class对语法解析器来说是个关键字，为了让语法解析器解析为属性函数，必须加单引号</span></div><div class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'he'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//es6</span></div><div class="line"><span class="keyword">var</span> baz = &#123;foo: <span class="string">'bar'</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="class"><span class="keyword">class</span>() </span>&#123;&#125;</div><div class="line">    method() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'he'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="属性名表达式-使用-来实现"><a href="#属性名表达式-使用-来实现" class="headerlink" title="属性名表达式(使用[]来实现)"></a>属性名表达式(使用[]来实现)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对属性的定义有俩种(es5只能用方法一)</span></div><div class="line">obj.foo = <span class="number">123</span>;</div><div class="line">obj[<span class="string">'f'</span> + <span class="string">'oo'</span>] = <span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="comment">//当多个定义的时候</span></div><div class="line"><span class="keyword">var</span> na = <span class="number">4</span>;</div><div class="line"><span class="keyword">var</span> hh = <span class="string">'wq'</span>;</div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    <span class="string">'pp'</span>: <span class="number">2</span>,</div><div class="line">    [<span class="string">'a'</span> + na]: <span class="number">3</span>,</div><div class="line">    [wq]: <span class="number">4</span>,</div><div class="line">    [<span class="string">'a'</span> + wq]: <span class="number">5</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//另外（表达式虽然可以使用，但是表达式计算的结果是全数字的话（数字开头也算），访问属性时会混乱出错）</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line">a.obj = <span class="number">3</span>;</div><div class="line">a[obj];<span class="comment">//error</span></div><div class="line">a[<span class="string">'obj'</span>];<span class="comment">//ok  因为点运算符后面总是字符串</span></div><div class="line"></div><div class="line"><span class="number">1</span>、对js来说属性名一定是字符串，不可能是其它对象</div><div class="line"><span class="number">2</span>、[]运算出来的只能是字符串，</div><div class="line"><span class="number">3</span>、[]里面的只能是对象，<span class="string">`['obj']`</span>是生产一个<span class="string">`obj`</span>的字符串，再转换</div></pre></td></tr></table></figure>
<h5 id="name的俩种特殊情况："><a href="#name的俩种特殊情况：" class="headerlink" title="name的俩种特殊情况："></a>name的俩种特殊情况：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>()).name <span class="comment">// "anonymous"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line">doSomething.bind().name <span class="comment">// "bound doSomething"</span></div></pre></td></tr></table></figure>
<h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>除了个别（NaN、+0、-0）和<code>===</code>不一样，其它都一致。 </p>
<h4 id="Object。assign"><a href="#Object。assign" class="headerlink" title="Object。assign()"></a>Object。assign()</h4><p>它会从左向右，依次把元素叠加到第一个参数上，并返回第一个参数(注意assign只是一级属性复制，比浅拷贝多深拷贝了一层而已)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = &#123; a: <span class="number">1</span>, b: <span class="number">1</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> source1 = &#123; b: <span class="number">2</span>, c: <span class="number">2</span> &#125;;</div><div class="line"><span class="keyword">var</span> source2 = &#123; c: <span class="number">3</span> &#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</div><div class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>(<span class="literal">true</span>) <span class="comment">// &#123;[[PrimitiveValue]]: true&#125;</span></div><div class="line"><span class="built_in">Object</span>(<span class="number">10</span>)  <span class="comment">//  &#123;[[PrimitiveValue]]: 10&#125;</span></div><div class="line"><span class="built_in">Object</span>(<span class="string">'abc'</span>) <span class="comment">// &#123;0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"&#125;</span></div><div class="line"><span class="comment">//如果组合的话，只进字符。</span></div><div class="line"></div><div class="line"><span class="comment">//Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性）</span></div><div class="line"><span class="comment">//也不拷贝不可枚举的属性（enumerable: false）。</span></div><div class="line"></div><div class="line"><span class="comment">//如果要保持继承链</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="属性的可枚举"><a href="#属性的可枚举" class="headerlink" title="属性的可枚举"></a>属性的可枚举</h4><p>es5有三个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p>
<ul>
<li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性<br>es6多个<code>assign</code></li>
</ul>
<h4 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h4><p>书上建议使用<br><code>Object.setPrototypeOf()</code>（写操作）、<br><code>Object.getPrototypeOf()</code>（读操作）、<br><code>Object.create()</code>（生成操作）代替 <code>__proto__</code>的直接操作，因为只有浏览器广泛支持，其它环境不一定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">setPrototypeOf(obj, proto) &#123;</div><div class="line">  obj.__proto__ = proto;</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;<span class="comment">//setPrototypeOf的原型和它差不多，也就意味着这是浅拷贝。</span></div><div class="line"><span class="keyword">let</span> proto = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> obj = &#123; x: <span class="number">10</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</div><div class="line"></div><div class="line">proto.y = <span class="number">20</span>;</div><div class="line">proto.z = <span class="number">40</span>;</div><div class="line"></div><div class="line">obj.x <span class="comment">// 10</span></div><div class="line">obj.y <span class="comment">// 20</span></div><div class="line">obj.z <span class="comment">// 40</span></div></pre></td></tr></table></figure>
<h4 id="Object-keys-和values相对"><a href="#Object-keys-和values相对" class="headerlink" title="Object.keys 和values相对"></a>Object.keys 和values相对</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; foo: <span class="string">"bar"</span>, baz: <span class="number">42</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.keys(obj)</div><div class="line"><span class="comment">// ["foo", "baz"]</span></div></pre></td></tr></table></figure>
<h4 id="Object-values-和keys相对"><a href="#Object-values-和keys相对" class="headerlink" title="Object.values 和keys相对"></a>Object.values 和keys相对</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; foo: <span class="string">"bar"</span>, baz: <span class="number">42</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.values(obj)</div><div class="line"><span class="comment">// ["bar", 42]</span></div></pre></td></tr></table></figure>
<h4 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries"></a>Object.entries</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; foo: <span class="string">'bar'</span>, baz: <span class="number">42</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.entries(obj)</div><div class="line"><span class="comment">// [ ["foo", "bar"], ["baz", 42] ]</span></div></pre></td></tr></table></figure>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>从字面上理解，是为了属性引入新方法，同时避免重名的情况；保证属性名独一无二。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();<span class="comment">//它接收字符的，Symbol('a'),这样多了个字符串标识</span></div><div class="line"><span class="keyword">var</span> a = &#123;[mySymbol]: <span class="string">'H!'</span>&#125;;<span class="comment">//由于Symbol是函数，所以必须用属性名表达式</span></div><div class="line"></div><div class="line"><span class="comment">//还有一种使用方式是定义常量,感觉蛮实用的</span></div><div class="line"><span class="keyword">const</span> COLOR_RED    = <span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">const</span> COLOR_GREEN  = <span class="built_in">Symbol</span>();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComplement</span>(<span class="params">color</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (color) &#123;</div><div class="line">    <span class="keyword">case</span> COLOR_RED:</div><div class="line">      <span class="keyword">return</span> COLOR_GREEN;</div><div class="line">    <span class="keyword">case</span> COLOR_GREEN:</div><div class="line">      <span class="keyword">return</span> COLOR_RED;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Undefined color'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Symbol属性函数"><a href="#Symbol属性函数" class="headerlink" title="Symbol属性函数"></a>Symbol属性函数</h5><p><code>Object.getOwnPropertySymbols</code>方法返回一个数组，成员是当前对象的所有用作属性名的 <code>Symbol</code> 值。</p>
<p><code>Symbol.for()</code>接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'ff'</span>);</div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'ff'</span>);</div><div class="line">s1 === s2<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p><code>Symbol.keyFor()</code>返回一个已登记的<code>Symbol</code>类型的key；<br>换句话说，它对<code>Symbol.for</code>返回成功的是能返回的。<br>对新建的<code>Symbol(&lt;string&gt;)</code>类型是无法返回的。</p>
<h3 id="Proxy-属于元编程"><a href="#Proxy-属于元编程" class="headerlink" title="Proxy(属于元编程)"></a>Proxy(属于元编程)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</div><div class="line">  &#125;,</div><div class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, value, receiver</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>!`</span>);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">obj.count = <span class="number">1</span></div><div class="line"><span class="comment">//  setting count!</span></div><div class="line">++obj.count</div><div class="line"><span class="comment">//  getting count!</span></div><div class="line"><span class="comment">//  setting count!</span></div><div class="line"><span class="comment">//  2</span></div><div class="line"></div><div class="line"><span class="comment">//同一个拦截器，可以设置多个操作</span></div><div class="line"><span class="keyword">var</span> handler = &#123;</div><div class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, name</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (name === <span class="string">'prototype'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.prototype;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + name;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  apply: <span class="function"><span class="keyword">function</span>(<span class="params">target, thisBinding, args</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> args[<span class="number">0</span>];</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;value: args[<span class="number">1</span>]&#125;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y;</div><div class="line">&#125;, handler);</div><div class="line"></div><div class="line">fproxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1</span></div><div class="line"><span class="keyword">new</span> fproxy(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// &#123;value: 2&#125;</span></div><div class="line">fproxy.prototype === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></div><div class="line">fproxy.foo <span class="comment">// "Hello, foo"</span></div></pre></td></tr></table></figure>
<p><strong>总的来说有点像c++的操作符函数，但比操作符函数高级</strong><br>支持一下特性：</p>
<ol>
<li><code>get(target, propKey, receiver)</code>拦截对象属性读取</li>
<li><code>set(target, propKey, value, receiver)</code>拦截对象属性的设置 返回一个布尔值。</li>
<li><code>has(target, propKey)</code>拦截propKey in proxy的操作，以及对象的hasOwnProperty方法 返回一个布尔值。</li>
<li><code>deleteProperty(target, propKey)</code>拦截delete proxy[propKey]的操作 返回一个布尔值。</li>
<li><code>ownKeys(target)</code>拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组</li>
<li><code>getOwnPropertyDescriptor(target, propKey)</code>拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li>
<li><code>defineProperty(target, propKey, propDesc)</code>拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li>
<li><code>preventExtensions(target)</code>拦截Object.preventExtensions(proxy)，返回一个布尔值。</li>
<li><code>getPrototypeOf(target)</code>拦截Object.getPrototypeOf(proxy)，返回一个对象。</li>
<li><code>isExtensible(target)</code>拦截Object.isExtensible(proxy)，返回一个布尔值。</li>
<li><code>setPrototypeOf(target, proto)</code>拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。</li>
<li><code>apply(target, object, args)</code>拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li>
<li><code>construct(target, args)</code>拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li>
</ol>
<p><strong>这个确实太多了，也没咋记，具体看书吧！</strong></p>
<h3 id="二进制数组"><a href="#二进制数组" class="headerlink" title="二进制数组"></a>二进制数组</h3><p>网络传输和图片视频文件解析等<br><code>var type = new ArrayBuffer(32);</code>开辟二进制内存</p>
<p>访问二进制内存，不同数据有多种读取方式，叫”视图”<br>有俩种视图:</p>
<ol>
<li>TypeArray视图, 整体是同一数据类型<code>Int8Array Uint8Array....16 32</code></li>
<li><p>Dataview视图</p>
<h4 id="TypeArray视图"><a href="#TypeArray视图" class="headerlink" title="TypeArray视图"></a>TypeArray视图</h4><p>构造函数参数有3个:<br>第一个必需，接收ArrayBuffer<br>第二个可选，视图开始的字节序号，必需保证字节合理性不然异常<br>第三个可选，视图包含的数据个数，必需保证字节合理性不然异常</p>
<p>成员<code>BYTES_PER_ELEMENT</code>表示类型所占字节数<br>成员<code>byteLength</code>获取占内存长度<br>成员<code>length</code>获取数组含多少个成员</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</div><div class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(b);</div></pre></td></tr></table></figure>
<h4 id="DataView视图"><a href="#DataView视图" class="headerlink" title="DataView视图"></a>DataView视图</h4><p>get方式一轮次获<br>set方式设置<br>俩函数都有字节序的设置</p>
</li>
</ol>
<h3 id="Set-Map"><a href="#Set-Map" class="headerlink" title="Set/Map"></a>Set/Map</h3><p>和stl不同，他们并不会排序<br>map的键支持对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">"d"</span>, <span class="string">"a"</span>], [<span class="string">"t"</span>, <span class="string">"x"</span>]]);</div><div class="line">map</div><div class="line">.set(k, <span class="number">111</span>);</div><div class="line">.set(k, <span class="number">222</span>);</div></pre></td></tr></table></figure></p>
<p><strong>和Array连用</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</div><div class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(x=&gt;x*<span class="number">2</span>));</div><div class="line"></div><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([...map].filter(([k, v]) =&gt; k&lt;<span class="number">3</span>))</div></pre></td></tr></table></figure></p>
<h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><p>主要用于es6的<code>for...of</code>语句<br>此语句的遍历依靠<code>next()</code> 返回一个对象{value:…, done:…} false表示遍历结束</p>
<p>es6中只要部署了<code>Symbol.iterator</code>接口，就可以遍历(数组默认部署)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ar = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"><span class="keyword">let</span> it = ar[<span class="built_in">Symbol</span>.iterator]();<span class="comment">//访问ar这个数组部署的遍历函数，并得到这个表达式</span></div><div class="line">it.next()<span class="comment">//&#123;value:'a', done:false&#125;</span></div></pre></td></tr></table></figure></p>
<p>当对象也要使用for of语句遍历时，加个接口就好(接口是个函数，返回带有next的对象)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span>(<span class="params">v</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.v = v;</div><div class="line">    <span class="keyword">this</span>.n = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line">obj.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">//定义这个对象有个此类接口，并定义代码</span></div><div class="line">    <span class="keyword">var</span> it = &#123;next: next&#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> cur = <span class="keyword">this</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (cur) &#123;</div><div class="line">            <span class="keyword">var</span> va = cur.v;</div><div class="line">            <span class="keyword">var</span> <span class="keyword">do</span> = cur == <span class="literal">null</span>;</div><div class="line">            cur = cur.next;</div><div class="line">            <span class="keyword">return</span> &#123;done: <span class="keyword">do</span>, value: va&#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> &#123;done: <span class="literal">true</span>&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> it;<span class="comment">//返回带有next 函数的对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> one = <span class="keyword">new</span> obj(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> two = <span class="keyword">new</span> obj(<span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> three = <span class="keyword">new</span> obj(<span class="number">3</span>);</div><div class="line">one.next = two;</div><div class="line">two.next = three;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> one)<span class="comment">//如此遍历就可以了</span></div></pre></td></tr></table></figure></p>
<p><strong>还可以用于解构</strong><br>由于<code>...</code>运算符也是用<code>Iterator</code>接口，所以<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> four = [...one]<span class="comment">//[1, 2, 3] 这个样子是完全可以的</span></div></pre></td></tr></table></figure></p>
<p><strong>字符串也可以用next遍历</strong></p>
<p><strong>js原有的for…in只能读取属性值,后面的for…of才能读取键值如同forEach</strong></p>
<h3 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">he</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'aa'</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'dd'</span>;</div><div class="line">    <span class="keyword">return</span> <span class="string">'ss'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> hw = he();<span class="comment">//g函数 调用并不会立即执行，只会返回个函数指针</span></div><div class="line">hw.next();<span class="comment">//&#123;value:'aa', done:false&#125;  使用next才会真正执行，内部的yield只是给个执行暂停的操作</span></div><div class="line">hw.next();<span class="comment">//&#123;value:'dd', done:false&#125;</span></div><div class="line">hw.next();<span class="comment">//&#123;value:'ss', done:true&#125;</span></div><div class="line">hw.next();<span class="comment">//&#123;value:undefined, done:true&#125;</span></div><div class="line"></div><div class="line"><span class="comment">//由此可以写个暂缓函数</span></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;...&#125;</div><div class="line"><span class="keyword">var</span> gen = f();</div><div class="line">setTimmeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;gen.next();&#125;, <span class="number">200</span>);</div></pre></td></tr></table></figure>
<p><strong>yield不能用于一般函数即使临时函数也不行</strong></p>
<h4 id="next方法参数"><a href="#next方法参数" class="headerlink" title="next方法参数"></a>next方法参数</h4><p><code>next</code>可以带一个参数，该参数会被作为上一条yield语句的返回值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> y = <span class="number">2</span>*(yeild (x+<span class="number">1</span>));</div><div class="line">    <span class="keyword">var</span> z= yeild (y/<span class="number">3</span>);</div><div class="line">    <span class="keyword">return</span> (x+y+z);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</div><div class="line">a.next()<span class="comment">//&#123;value:6,done:false&#125; 走到第一个yeild停止</span></div><div class="line">a.next()<span class="comment">//&#123;value:NaN, done:false&#125; 由于传的参数为定义，所以作为返回值y被赋值是undefined</span></div><div class="line">a.next()<span class="comment">//&#123;value:NaN, done:false&#125; 由于传的参数为定义，所以作为返回值z被赋值是undefined</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>);</div><div class="line">b.next()<span class="comment">//&#123;value:6,done:false&#125; 走到第一个yeild停止</span></div><div class="line">b.next(<span class="number">12</span>)<span class="comment">//&#123;value:8,done:true&#125; yeild返回12，乘2除3为8</span></div></pre></td></tr></table></figure></p>
<h4 id="配合Iterator接口"><a href="#配合Iterator接口" class="headerlink" title="配合Iterator接口"></a>配合Iterator接口</h4><p>以前要封装接口，必须让函数返回带next函数标准返回对象的对象<br>现在如下便可<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> j = &#123;ff: <span class="number">33</span>, ss: <span class="number">55</span>&#125;</div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">obj</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> key = <span class="built_in">Object</span>.keys(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> pro <span class="keyword">of</span> key) &#123;</div><div class="line">        <span class="keyword">yield</span> [pro, <span class="keyword">this</span>[pro]];<span class="comment">//它会自动弹出标准对象</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">j[<span class="built_in">Symbol</span>.iterator] = obj;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> t <span class="keyword">of</span> j) &#123;...&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Generator-prototype-return-强制返回，不继续执行"><a href="#Generator-prototype-return-强制返回，不继续执行" class="headerlink" title="Generator.prototype.return()强制返回，不继续执行"></a>Generator.prototype.return()强制返回，不继续执行</h4><h4 id="yield-的使用"><a href="#yield-的使用" class="headerlink" title="yield*的使用"></a>yield*的使用</h4><p>Generator内部不能调用Generator函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fucction* foo() &#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'a'</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'b'</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'x'</span>;</div><div class="line">    <span class="keyword">yield</span>* foo();</div><div class="line">    <span class="keyword">yield</span> <span class="string">'y'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Genrator中的return<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> <span class="string">"foo"</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> v = <span class="keyword">yield</span>* foo();</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"v:"</span> + v);</div><div class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> it = bar();</div><div class="line">it.next()<span class="comment">//&#123;value:1, done:false&#125;</span></div><div class="line">it.next()<span class="comment">//&#123;value:2, done:false&#125;</span></div><div class="line">it.next()<span class="comment">//&#123;value:3, done:false&#125;</span></div><div class="line">it.next()<span class="comment">//"v:foo" &#123;value:1,done:false&#125;</span></div><div class="line">it.next()<span class="comment">//&#123;value:undefined, done:true&#125;</span></div></pre></td></tr></table></figure></p>
<h4 id="Generator中的this"><a href="#Generator中的this" class="headerlink" title="Generator中的this"></a>Generator中的this</h4><p>和普通函数的this差不多，但是不能和new使用，当构造函数使用得变通<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">F</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="keyword">this</span>.b = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> f = F.call(obj);</div><div class="line">f.next();<span class="comment">//...2</span></div><div class="line">f.next();<span class="comment">//...3</span></div><div class="line">f.next();<span class="comment">//...undefined</span></div><div class="line">obj.a<span class="comment">//1</span></div><div class="line">obj.b<span class="comment">//2</span></div><div class="line">obj.c<span class="comment">//3</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Gen</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> F.call(F.prototype);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Gen();</div><div class="line">f.next();<span class="comment">//...2</span></div><div class="line">f.next();<span class="comment">//...3</span></div><div class="line">f.next();<span class="comment">//...undefined</span></div><div class="line">f.a<span class="comment">//1</span></div><div class="line">f.b<span class="comment">//2</span></div><div class="line">f.c<span class="comment">//3</span></div></pre></td></tr></table></figure></p>
<h4 id="Generator使用Trick"><a href="#Generator使用Trick" class="headerlink" title="Generator使用Trick"></a>Generator使用Trick</h4><p>以前切换状态必须要个高层变量来保存，切换时就false，true的换。<br>现在可以直接:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cl = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</div><div class="line">   <span class="keyword">yield</span> <span class="literal">true</span>;</div><div class="line">   <span class="keyword">yield</span> <span class="literal">false</span>;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> t = cl();</div><div class="line">t.next()<span class="comment">//...true</span></div><div class="line">t.next()<span class="comment">//...false</span></div><div class="line">t.next()<span class="comment">//...true</span></div></pre></td></tr></table></figure></p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>状态对象，用来传递异步消息<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ati</span>(<span class="params">s</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((r, j) =&gt; &#123;setTimeout(r, s, <span class="string">'wangqiu'</span>)&#125;)<span class="comment">//执行r函数是让此对象状态变为resolve；执行j函数是让此对象变成reject状态</span></div><div class="line">&#125;</div><div class="line">ati(<span class="number">20</span>).then((v) =&gt; &#123;<span class="built_in">console</span>.log(v)&#125;, (j)=&gt;&#123;<span class="built_in">console</span>.log(j)&#125;)<span class="comment">//先执行函数，并定义then；当状态是resolve则执行第一个参数的函数，当状态是rejeect则执行第二个参数函数</span></div></pre></td></tr></table></figure></p>
<h4 id="Promise-then"><a href="#Promise-then" class="headerlink" title="Promise.then"></a>Promise.then</h4><p>由于<code>then</code>返回的是一个<code>promise</code>对象，所以可以连续then<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getJson(<span class="string">"1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> post.comment;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comment</span>) </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h4 id="Promise-catch和普通一样"><a href="#Promise-catch和普通一样" class="headerlink" title="Promise.catch和普通一样"></a>Promise.catch和普通一样</h4><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p><code>all</code>参数是个Promise数组，返回一个Promise<br>只有当数组里面的Promise全改变状态，才会改变此Promise状态<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="Promise-race同上调用-数组中一个改变，就跟着改变"><a href="#Promise-race同上调用-数组中一个改变，就跟着改变" class="headerlink" title="Promise.race同上调用,数组中一个改变，就跟着改变"></a>Promise.race同上调用,数组中一个改变，就跟着改变</h4><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>类的方法之间不需要逗号分隔，加了会报错<br><code>typeof ClassName</code>是<code>function</code>即类数据类型是函数<br>构造函数也只是<code>prototype.constructor</code>的子函数</p>
<p><strong>类内部所有定义的属性都是不可枚举的</strong></p>
<p><code>let d = new class {...}()</code>这样写法是允许的</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><strong>子类构造函数必须调用super</strong><br>子类没有自己的this对象，是继承父类的this，所以必须supper构造父类<br>因此<code>super</code>之前的this调用都是错误的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="给类添加私有方法Trick"><a href="#给类添加私有方法Trick" class="headerlink" title="给类添加私有方法Trick"></a>给类添加私有方法Trick</h4><p>通过symbol导致第三方获取不到函数名，所以称为私有方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> bar = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</div><div class="line"><span class="keyword">const</span> snaf = <span class="built_in">Symbol</span>(<span class="string">'snaf'</span>);</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span> </span>&#123;</div><div class="line">    foo(baz) &#123;</div><div class="line">        <span class="keyword">this</span>[bar](baz);</div><div class="line">    &#125;</div><div class="line">    [bar](baz) &#123;<span class="comment">//利用方括号访问制造变量属性，这样外部获取不到变量就无法访问</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[snaf] = baz;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="set和get属性拦截"><a href="#set和get属性拦截" class="headerlink" title="set和get属性拦截"></a>set和get属性拦截</h4><h4 id="class和generator"><a href="#class和generator" class="headerlink" title="class和generator"></a>class和generator</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(..args) &#123;</div><div class="line">        <span class="keyword">this</span>.args = args;</div><div class="line">    &#125;</div><div class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;<span class="comment">//如果自己写要index记录next遍历位置，要返回next属性函数返回指定类型</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> <span class="keyword">this</span>.args) &#123;</div><div class="line">            <span class="keyword">yield</span> arg;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="keyword">new</span> Foo(<span class="string">'hello'</span>, <span class="string">'world'</span>)) &#123;</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"><span class="comment">//hello</span></div><div class="line"><span class="comment">//world</span></div></pre></td></tr></table></figure>
<h4 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h4><p>这个和es5直接定义函数的属性相似,区别在于父类的静态方法可以被子类继承<br><code>es6规定static只能静态方法，不能静态变量属性</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> classMethod() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'hello'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Foo.classMethod();</div></pre></td></tr></table></figure></p>
<h4 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h4><p>这个属性专门用在构造函数中(es5的函数构造，es6的constructor函数里面使用)<br>它用来判断<code>new</code>的对象名(这样就算是继承也能知道new的对象是哪个)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">'1'</span>);</div><div class="line"><span class="keyword">var</span> nper= Person.call(person, <span class="string">'2'</span>);</div></pre></td></tr></table></figure></p>
<h4 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h4><p>子类允许使用<code>super</code>关键字来访问父类函数</p>
<p><strong>尽量不用super访问变量,我不知道为何会访问到prototype上去，赋值就可以，读却不行</strong></p>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><h4 id="模块加载"><a href="#模块加载" class="headerlink" title="模块加载"></a>模块加载</h4><p>CommonJS加载方式<br><code>let {stat, exists} = require(&#39;fs&#39;);</code></p>
<p>es6方式:<br><code>import {stat, exists} from &#39;fs&#39;</code></p>
<p>前者整体加载fs模块(加载所有的fs方法),然后在使用时用到3个方法。即”运行时加载”<br>后者通过命令显式指定输出代码，输入时也用静态命令方式。实际只加载了fs的3个方法，其它未加载。即”编译时加载”<br>后者效率高</p>
<h4 id="导入导出命令"><a href="#导入导出命令" class="headerlink" title="导入导出命令"></a>导入导出命令</h4><p><code>export</code>和<code>import</code>对接的接口名必须相同<br>如果不同，可以用此来<code>import {last as surn} from &#39;./profile&#39;</code></p>
<blockquote>
<p>上面是逐一加载方式,接下来是整体加载方式<br><code>import * as pro from &#39;./profile&#39;</code> <code>pro.last</code></p>
</blockquote>
<h4 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h4><p>由于上面的介绍必须知道导入和导出的接口名才能继续。所以有了<code>default</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//导出文件 export.js</span></div><div class="line"><span class="keyword">export</span> deault fuction dd() &#123;...&#125;</div><div class="line"></div><div class="line"><span class="comment">//导入文件</span></div><div class="line">impport custom <span class="keyword">from</span> <span class="string">'./export'</span></div><div class="line">custom();</div></pre></td></tr></table></figure>
<h4 id="导出继承"><a href="#导出继承" class="headerlink" title="导出继承"></a>导出继承</h4><p><code>export * from &#39;circle&#39;</code>从circle导出所有</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><h4 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这俩个都是异步加载<br><code>defer</code>与<code>async</code>的区别是：前者要等到整个页面正常渲染结束，才会执行；后者一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</p>
<h4 id="es6模块和CommonJS模块差异"><a href="#es6模块和CommonJS模块差异" class="headerlink" title="es6模块和CommonJS模块差异"></a>es6模块和CommonJS模块差异</h4><blockquote>
<p>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用<br>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</p>
</blockquote>
<p>值拷贝:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib.js</span></div><div class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  counter: counter,</div><div class="line">  incCounter: incCounter,</div><div class="line">&#125;;</div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./lib'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(mod.counter);  <span class="comment">// 3</span></div><div class="line">mod.incCounter();</div><div class="line"><span class="built_in">console</span>.log(mod.counter); <span class="comment">// 3</span></div><div class="line"><span class="comment">//除非写成函数，否则是值拷贝</span></div></pre></td></tr></table></figure></p>
<h4 id="Node加载"><a href="#Node加载" class="headerlink" title="Node加载"></a>Node加载</h4><p>node有自己的commonjs模块格式，所以建议node和es6的加载方案各自分开</p>
<p>node使用es6加载时会依次寻找脚本<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'./foo'</span>;</div><div class="line"><span class="comment">// 依次寻找</span></div><div class="line"><span class="comment">//   ./foo.js</span></div><div class="line"><span class="comment">//   ./foo/package.json</span></div><div class="line"><span class="comment">//   ./foo/index.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">'baz'</span>;</div><div class="line"><span class="comment">// 依次寻找</span></div><div class="line"><span class="comment">//   ./node_modules/baz.js</span></div><div class="line"><span class="comment">//   ./node_modules/baz/package.json</span></div><div class="line"><span class="comment">//   ./node_modules/baz/index.js</span></div><div class="line"><span class="comment">// 寻找上一级目录</span></div><div class="line"><span class="comment">//   ../node_modules/baz.js</span></div><div class="line"><span class="comment">//   ../node_modules/baz/package.json</span></div><div class="line"><span class="comment">//   ../node_modules/baz/index.js</span></div><div class="line"><span class="comment">// 再上一级目录</span></div></pre></td></tr></table></figure></p>
<h4 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h4><blockquote>
<p>a脚本依赖b脚本，b脚本依赖c脚本，c脚本依赖a脚本；会造成递归加载使得程序无法进行</p>
</blockquote>
<p>CommonJS的循环加载时,返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</p>
<p>ES6的循环加载时，返回的是引用，所以只有执行到了才会有数据。</p>
<h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h3><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p><code>const</code>优于<code>let</code>：提醒阅读/符合函数式编程思想/js编译器会进行优化</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> a = <span class="string">"foobar"</span>;</div><div class="line"><span class="keyword">const</span> b = <span class="string">'foo'</span> + a + <span class="string">'bar'</span>;</div><div class="line"></div><div class="line"><span class="comment">// acceptable</span></div><div class="line"><span class="keyword">const</span> c = <span class="string">`foobar`</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> a = <span class="string">'foobar'</span>;</div><div class="line"><span class="keyword">const</span> b = <span class="string">`foo<span class="subst">$&#123;a&#125;</span>bar`</span>;</div><div class="line"><span class="keyword">const</span> c = <span class="string">'foobar'</span>;</div></pre></td></tr></table></figure></p>
<h4 id="优先使用解构赋值"><a href="#优先使用解构赋值" class="headerlink" title="优先使用解构赋值"></a>优先使用解构赋值</h4><p><strong>数组解构</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> first = arr[<span class="number">0</span>];</div><div class="line"><span class="keyword">const</span> second = arr[<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> [first, second] = arr;</div></pre></td></tr></table></figure></p>
<p><strong>函数参数是对象，优先使用解构(注意当对参数无修改才如此使用，因为解构是赋值过程)</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">user</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> firstName = user.firstName;</div><div class="line">  <span class="keyword">const</span> lastName = user.lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; firstName, lastName &#125; = obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// best</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">&#123; firstName, lastName &#125;</span>) </span>&#123;<span class="comment">//</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>对象定义不得随便增加新属性，如果要增加属性，要使用<code>Object.assign</code></strong></p>
<p><strong>扩展运算符拷贝数组</strong><br>const itemscopy = […items];</p>
<p><strong>使用箭头函数取代bind，放弃self</strong><br>由于箭头函数的<code>this</code>指向定义处，所以放弃以前的<code>bind</code>和<code>self</code>写法</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS-Google语法（191）]]></title>
      <url>https://xuecat.github.io/2016/10/17/191/</url>
      <content type="html"><![CDATA[<ol>
<li>如果一个值是恒定的，它命名中的字母要全部大写（如 <code>CONSTANT_VALUE_CASE</code> ）</li>
<li><p>一定要分号，js是弱语言，很多时候不要分号也能执行。但是容易出错。</p>
<p> //函数表达式后面要分号结束，但是函数声明就不需要</p>
<pre><code>var foo = function() {
    return true;
};  // 这里要分号

function foo() {
    return true;
}  // 这里不用分号
</code></pre></li>
<li><p>不要在块内函数声明，应该使用一个变量初始化函数表达式在块内定义一个函数块</p>
</li>
<li>为了最大的可移植性和兼容性，总是使用标准功能而不是非标准功能（例如，采用 string.charAt(3) 而非 string[3] ，用DOM的功能访问元素而不是使用特定于一个具体应用的简写）。</li>
<li><p>原始类型的包装对象，</p>
<pre><code>var x = new Boolean(false);
if (x) {//这是错误的，因为x是个object，而不是bool，正确该是var x = Boolean(0);
    alert(&apos;hi&apos;);  //显示“hi”。
}
</code></pre></li>
<li><p>方法和属性定义</p>
</li>
</ol>
<p>虽然有多种使用“new”关键词来创建对象方法和属性的途径，首选的创建方法的途径是：</p>
<pre><code>Foo.prototype.bar = function() {
    /* ... */
};//好像这样能提供性能
</code></pre><p>其他特性的首选创建方式是在构造函数中初始化字段：</p>
<pre><code>/** @constructor */
function Foo() {
    this.bar = value;
}
</code></pre><ol>
<li>删除，使用this.foo == null,而不是delete</li>
<li>遍历数组使用for循环 而不是for-in</li>
<li>多行字符不要使用连接行符，直接’+’</li>
<li>构建数组对象用字面量，而不是构造函数。</li>
</ol>
<p>//问题在构造只有一个元素的函数时</p>
<pre><code>var a = new Array(x); //它表示的是开辟一个x大小的数组，内部赋值undifinew；而不是开辟一个数组，内部赋值x；
var a = [x1, x2];
var a = [x1];
var a = [];
</code></pre><p>对象构造函数，为了一致性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"></div><div class="line">    <span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    o2.a = <span class="number">0</span>;</div><div class="line">    o2.b = <span class="number">1</span>;</div><div class="line">    o2.c = <span class="number">2</span>;</div><div class="line">    o2[<span class="string">'strange key'</span>] = <span class="number">3</span>;</div><div class="line"></div><div class="line">改为：</div><div class="line"></div><div class="line">    <span class="keyword">var</span> o = &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> o2 = &#123;</div><div class="line">        a: <span class="number">0</span>,</div><div class="line">        b: <span class="number">1</span>,</div><div class="line">        c: <span class="number">2</span>,</div><div class="line">        <span class="string">'strange key'</span>: <span class="number">3</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//关于对象属性的设置和获取，也最好使用字面量；请看`192`第15条</span></div></pre></td></tr></table></figure>
<ol>
<li>强烈禁止修改如 Object.prototype 和 Array.prototype 等对象的原型。</li>
<li>不要使用条件注释；条件注释会在运行时改变JavaScript语法树，阻碍自动化工具。</li>
<li>私有 属性和方法应该以下划线开头命名</li>
<li>保护 属性和方法应该以无下划线开头命名（像公共属性和方法一样）。</li>
<li>可选函数参数以 opt_ 开头。</li>
<li>参数数目可变的函数应该具有以 var_args 命名的最后一个参数。</li>
<li>为了避免在大小写敏感的平台上引起混淆，文件名应该小写。文件名应该以 .js 结尾，并且应该不包含除了 - 或 <em> （相比较 </em> 更推荐 - ）以外的其它标点</li>
<li><p>括号书写：</p>
<pre><code>if (something) {
} else {
}
</code></pre></li>
<li><p>多行，对象和数组初始化</p>
<pre><code>var arr = [1, 2, 3];  //之后无空格[或之前]
var obj = {a: 1, b: 2, c: 3};  //之后无空格[或之前]

//不要像这样：

WRONG_Object.prototype = {
    a          : 0,
    b          : 1,
    lengthyName: 2
};
</code></pre></li>
<li><p>匿名函数传递</p>
<pre><code>prefix.something.reallyLongFunctionName(&apos;whatever&apos;, function(a1, a2) {
    if (a1.equals(a2)) {
        someOtherLongFunctionName(a1);
    } else {
        andNowForSomethingCompletelyDifferent(a2.parrot);
    }
});

var names = prefix.something.myExcellentMapFunction(
    verboselyNamedCollectionOfItems,
    function(item) {
        return item.name;
    });
</code></pre></li>
<li><p>字符串使用单引号，虽然js不区分单引号和双引号。<br><br>但是一般html的属性用的是双引号。所以当js字符串为了区分html和转义，最好使用单引号。</p>
</li>
<li>注释可以参考jsdoc的做法</li>
<li><p>布尔类型</p>
<pre><code>下边的布尔表达式都返回false：
//@
null
undefined
&apos;&apos;空字符串
数字0
//但是要小心，因为以下这些返回true：
字符串&quot;0&quot;
[]空数组
{}空对象

//@所以 while (x != null) {}这样不好， 该是 while(x) {}
//if (y != null &amp;&amp; y != &apos;&apos;) {} 也改成 if (y) {}

//@二元布尔操作符是可短路的,所以
    var win;
    if (opt_win) {
        win = opt_win;
    } else {
        win = window;
    }
    //可以改成：
    function foo(opt_win) {
        var win = opt_win || window;
    }

    if (node) {
        if (node.kids) {
            if (node.kids[index]) {
                foo(node.kids[index]);
            }
        }
    }
    //可以改成：
    var kid = node &amp;&amp; node.kids &amp;&amp; node.kids[index];
    if (kid) {
        foo(kid);
    }
</code></pre></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React记录（190）]]></title>
      <url>https://xuecat.github.io/2016/10/16/190/</url>
      <content type="html"><![CDATA[<p><strong>1. this.props.children</strong><br>它是链表没错(当只有一个时，是string之类元素)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">React.Children.map(<span class="keyword">this</span>.props.children, <span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;child&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</div><div class="line">        &#125;)</div><div class="line"><span class="comment">//每个child是一个ReactElement的object，可能ReactElement有默认的隐式处理吧_shadowChildren之类吧！</span></div></pre></td></tr></table></figure>
<p>此句，一直不明白为何object能当字符处理。</p>
<p><strong>2. markdown显示</strong><br>使用remarkable库，可以支持markdown格式显示语句。<br><br>但是不能直接render解析（虽然表面看是对的），好像react做了XSS 攻击的保护。<br><br>解析后的语句只能放入节点属性中：dangerouslySetInnerHTML={ __html: md.render(this.props.children.toString()) }<br><br>值得注意的是，它支持的markdown语法是最新的，也就是说有些语法严格和空格有关(如<code># d</code>必须空格)</p>
<p><strong>3. react key添加</strong><br>我在用map的时候，被警告必须加key。react对dom做遍历的时候，会根据data-reactid生成虚拟dom树。如果你没有手动的添加unique constant key的话，react是无法记录你的dom操作的。</p>
<p><strong>4. createClass函数问题</strong><br>createClass创建的方法</p>
<p><code>rawMarkup: function() {}</code></p>
<p>要<code>this.rawMarkup()</code>才能访问到；晕，刚居然没注意。</p>
<p><strong>5. eslint安装</strong><br>eslint和eslint插件必须全部 全局安装。局部安装老是报错，无法找到插件。</p>
<p><strong>6. react-es6</strong><br>这个由于很多，只说下属性的设置；<br>es5对类属性设置是用： <code>render: function(){}</code><br><br>es6对类属性设置是用：<code>render() {}</code><br><br>居然看半天没发现。<br><a href="http://blog.csdn.net/wangzengdi/article/details/50719395" target="_blank" rel="external">http://blog.csdn.net/wangzengdi/article/details/50719395</a></p>
<p><strong>7. 无状态的函数式组件</strong><br>除了正统的rn创建外；还有个创建组件的方法<br></p>
<p>声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Pane = (props) =&gt; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">Pane.propTypes = &#123;</div><div class="line">  label: React.PropTypes.string.isRequired,</div><div class="line">  children: React.PropTypes.element.isRequired</div><div class="line">&#125;;</div><div class="line"><span class="comment">//使用：</span></div><div class="line">&lt;Pane label=<span class="string">"asdf"</span> /&gt;</div></pre></td></tr></table></figure>
<p>注意俩点：</p>
<ol>
<li>不能有生命周期方法</li>
<li>不能有ref（实例dom属性，React.findDOMNode）</li>
</ol>
<p><strong>8. children isrequired</strong><br><code>children: React.PropTypes.element.isRequired</code></p>
<p><strong>9. react全家桶</strong><br>webpack和其它基本已经知道了；给个前端ui库吧：reactui库有个ant design 和material ui、 boostrap<br><br>flux网上说文档又臭又长，转redux</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[换系统时要保存的文件（189）]]></title>
      <url>https://xuecat.github.io/2016/10/12/189/</url>
      <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/e1.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<ul>
<li>vscode 插件项</li>
<li>桌面的<code>笔记.txt</code></li>
</ul>
<p>今天真是超级扯淡的一天：</p>
<ul>
<li>sp1系统和其它非ultimate系统（msdn我告诉你），没有系统更新模块；sp1到无所谓，模块集成了，只是没法英文系统而已。</li>
<li>电脑更新和安装vs，不要插移动硬盘！</li>
<li>电脑更新和安装vs，不要插移动硬盘！</li>
<li>电脑更新和安装vs，不要插移动硬盘！ 尼玛，它会直接破坏小马的系统激活，气死我了。</li>
</ul>
<hr>
<p>我win7 sp1系统想换英语语言包一直更新不到，今天发现可以直接google下面这个：<br>windows6.1-kb2483139-x64-en-us_9b9c8a867baff2920507fbf1e1b4a158572b9b87</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CFile各属性笔记（188）]]></title>
      <url>https://xuecat.github.io/2016/09/27/188/</url>
      <content type="html"><![CDATA[<p><strong>今日为楼下写多线程的文件操作测试程序，记录下。</strong></p>
<p>CFile::shareDenyNone 表示允许其它进/线程访问（多线程时便用此CFile::shareDenyNone和CFile::shareDenyNone搭配，对文件边读边写）</p>
<p>CFile::shareDenyRead 禁止其它进/线程读操作</p>
<p>CFile::shareDenyWrite 禁止其它进/线程写操作</p>
<p>CFile::shareExclusive 禁止其它进/线程读写操作</p>
<p>CFile::modeNoTruncate 它必须要和CFile::modeCreate连用保证稳定性。好吧对于它一般是写操作时用的多，<br><br>CFile::modeCreate会清零文件，即原来文件80k，你写入50k，这下文件就只有50k新数据。<br><br>CFile::modeNoTruncate不会清零文件，即原来80k，写入50k，这下文件就有50k新数据和30k旧数据。如果想对尾部添加的话直接seek到end就好<br></p>
<p><strong>CFile::osNoBuffer 不会有系统缓存。它太特殊了，今天就卡这儿；它对文件操作必须按照卷大小来操作：也就是说添加此属性的CFile，seek、read、write的操作大小必须是1024的倍数</strong> </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[npm install注意187]]></title>
      <url>https://xuecat.github.io/2016/09/26/187/</url>
      <content type="html"><![CDATA[<p><code>--save-dev</code> 是你开发时候依赖的东西，<code>--save</code> 是你发布之后还依赖的东西。</p>
<p>比如，你写 ES6 代码，如果你想编译成 ES5 发布那么 babel 就是devDependencies。<br><br>如果你用了 jQuery，由于发布之后还是依赖jQuery，所以是dependencies。</p>
<p>但是在 npm 里面除了二进制的依赖，似乎也不用区分是不是dev。<br><br>因为使用npm就是自己编译的意思，而不使用npm直接拿编译后的版本的，这些依赖项也看不到。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[google调试react(186)]]></title>
      <url>https://xuecat.github.io/2016/09/25/186/</url>
      <content type="html"><![CDATA[<p>今天死活断点不了，google了好久；发现有个<code>debugger</code>放入代码中就好了，可以看堆栈了。<br><br>断点不了的问题至今没找到，气死人了。！</p>
<p>好吧v2ex果然大神多，jsx需要编译产生sourcemap后才能被调试，所以webpack是标配。另外react-hot-loader（js库）和react-devtools（google插件）不错</p>
<p><code>Create React App</code>和<code>generator-react-webpack</code>会自动生成react项目，使用webpack自动打包，但是<code>dev-source-map</code>模式下无法调试。<br><br>其它模式参考：<a href="https://segmentfault.com/a/1190000004280859" target="_blank" rel="external">https://segmentfault.com/a/1190000004280859</a></p>
<p>调试的jsx，一般都是被打包成js的，很好看，也方便调试（就google-&gt;source 那里找源码有点不好找，打包多了）。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p> <code>react developer tools</code>在<code>react</code>tab那里，使用控制台(如果没有就在三个点那里<code>Show console drawer</code>),<br> 鼠标选中组件，控制台输入<code>$r</code> <code>$r.props</code>来查看当前组件的信息(这些信息右边板块看不到的，另外第一个下拉框必需选<code>top</code>才能识别);<br> 也支持直接调用<code>$r.setState({message: &#39;Hello world!&#39;}</code></p>
<h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p> 还可以用<code>debugger;</code>代码来手动添加，这对部分代码很友好</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS中单引号与双引号的一个区别185]]></title>
      <url>https://xuecat.github.io/2016/09/25/185/</url>
      <content type="html"><![CDATA[<p>一般Javascript资料里面，很少区分单引号(‘)和双引号(“)，认为它们作用相同，今天发现有一处不同点，举例如下：</p>
<pre><code>在一段JS语句中，希望通过编程在网页中动态添加一个命令按钮， 则基本实现语句如下所示 

      var btnOk2=document.createElement(&quot;&lt;input type=&apos;button&apos; value=&apos;确定/&gt;&quot;);
      document.body.appendChild(btnOk2);
若要在点击按钮后显示一个提示信息，则要对其onclick事件编程，此时有多种方法可以实现。

1. 添加函数

      onclick=clickOK();//clickOK()为单独定义的函数

      function clickOK(){

         alert(&quot;确定&quot;);

      }

2. 使用匿名函数

      onclick=function(){alert(&apos;确定&apos;)};//注意，此处alert内的提示信息应使用单引号，若使用双引号则放入整个input 时语法不正确

3. 直接使用javascript语句，单引号

      onclick=&apos;javascript:{alert(&apos;确定&apos;)&apos;;//注意，此语句语法没问题，但却不能正常执行，点击按钮时无结果，具体原因不详，也未深究

4. 直接使用javascript语句，双引号

      由于要放入input语句中，因此alert不能直接使用双引号，使用转义符/完成

      onclick=&apos;javascript:alert(/&quot;确定/&quot;)&apos;;//注意，此语句语法没问题，也能够正常执行

使用第4中方法的完整实例语句如下：

var btnOk2=document.createElement(&quot;&lt;input type=&apos;button&apos; value=&apos;确定 onclick=&apos;javascript:alert(/&quot;确定/&quot;)&apos;/&gt;&quot;);
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[critical_section临界区注意事项184]]></title>
      <url>https://xuecat.github.io/2016/09/22/184/</url>
      <content type="html"><![CDATA[<p>EnterCriticalSection作为临界区</p>
<p>critical_section效率要高一些，因为是针对同一个进程的。<br>mutex是针对整个操作系统的。</p>
<p>//1.测试同一线程两次EnterCriticalSection会不会阻塞<br>//答案:不会<br>/*</p>
<p>//2.测试同一线程两次EnterCriticalSection，调用一次LeaveCriticalSection 另一个线程是否可以以EnterCriticalSection<br>//答案:不可以 两次EnterCriticalSection 必须调用 LeaveCriticalSection两次</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在VSCode的配置--react(183)]]></title>
      <url>https://xuecat.github.io/2016/09/21/183/</url>
      <content type="html"><![CDATA[<p>###过程多了186也有，这里这说下开发环境，有利工具</p>
<ol>
<li><p>代码语法提示，插件ESLint；它对写的代码进行语法错误提示，特别是配置了react的插件后，对react属性、状态等书写有全面提示。</p>
</li>
<li><p>代码自动补全，node插件Typings和vsc插件Typings suto installer，前者全局安装，后者会自动把package.jason的TS（微软的TypingScript）包全下全</p>
</li>
<li><p>emment（内置，它简直为前端而生，语法很好使）；它默认是不支持js的，jsx倒是可以。<br><br>我google和官网了很久都没找到提示，最后没法，去git看看（原来git官网的doc是实时更新的，比官网的doc更新都勤快，以后只去git去看doc了）<br></p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="string">"workbench.sideBar.location"</span>: <span class="string">"right"</span>,</div><div class="line">  <span class="string">"editor.minimap.enabled"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="string">"emmet.triggerExpansionOnTab"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="string">"emmet.syntaxProfiles"</span>: &#123;</div><div class="line">      <span class="string">"javascript"</span>: <span class="string">"javascriptreact"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"emmet.includeLanguages"</span>: &#123;</div><div class="line">      <span class="string">"javascript"</span>: <span class="string">"javascriptreact"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"workbench.iconTheme"</span>: <span class="string">"vscode-icons"</span></div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>单个js调试，launch.json的配置  <a href="https://segmentfault.com/a/1190000004136202" target="_blank" rel="external">https://segmentfault.com/a/1190000004136202</a></p>
<p>  “name”: “启动”,<br>  “type”: “node”,<br>  “request”: “launch”,<br>  “program”: “${workspaceRoot}/demo01/tt.js”,</p>
</li>
</ul>
<hr>
<h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><p>感觉这个还好，不是很麻烦。<br>eslint –init 创建它就会自动问一些东西。<br>npm install –save-dev eslint-config-angular 由于我用angular所以要让它自动有angular的语法和提示，就安装了这个插件。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[仿函数和配接器的使用182]]></title>
      <url>https://xuecat.github.io/2016/09/17/182/</url>
      <content type="html"><![CDATA[<p>要想使用stl配接器算法，unary_function、binary_function的仿函数就必须使用.</p>
<h3 id="先来看STL已经提供的仿函数"><a href="#先来看STL已经提供的仿函数" class="headerlink" title="先来看STL已经提供的仿函数"></a>先来看STL已经提供的仿函数</h3><h2 id="—"><a href="#—" class="headerlink" title="—"></a>—</h2><h4 id="算法类仿函数"><a href="#算法类仿函数" class="headerlink" title="算法类仿函数"></a>算法类仿函数</h4><p>加法： <code>plus&lt;T&gt;</code> <br><br>减法：<code>minus&lt;T&gt;</code><br><br>乘法：<code>multiplies&lt;T&gt;</code><br><br>除法：<code>divides&lt;T&gt;</code> <br><br>模取：<code>modulus&lt;T&gt;</code><br><br>否定：<code>negate&lt;T&gt;</code>(一元)<br></p>
<h4 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h4><p>等于：<code>equal_to&lt;T&gt;</code><br><br>不等于：<code>not_equal_to&lt;T&gt;</code><br><br>大于：<code>greater&lt;T&gt;</code><br><br>大于或等于：<code>greater_equal&lt;T&gt;</code><br><br>小于：<code>less&lt;T&gt;</code><br><br>小于或等于:<code>less_equal&lt;T&gt;</code><br></p>
<h4 id="逻辑运算仿函数"><a href="#逻辑运算仿函数" class="headerlink" title="逻辑运算仿函数"></a>逻辑运算仿函数</h4><p>and: <code>logical_and&lt;T&gt;</code><br><br>or: <code>logical_or&lt;T&gt;</code><br><br>not: <code>logical_not&lt;T&gt;</code><br></p>
<h4 id="选择和投射"><a href="#选择和投射" class="headerlink" title="选择和投射"></a>选择和投射</h4><p><code>select1st&lt;T&gt;</code> <code>select2nd&lt;T&gt;</code> 对于此类，是针对pair的，传入pair，并返回第一个元素或第二个元素<br><br><code>project1st&lt;T&gt;</code> <code>project2nd&lt;T&gt;</code> 对于此类，是针对多参数的，传入俩个参数，只返回第一个元素或第二个元素<br></p>
<h2 id="—-1"><a href="#—-1" class="headerlink" title="—"></a>—</h2><h3 id="再看配接器"><a href="#再看配接器" class="headerlink" title="再看配接器"></a>再看配接器</h3><table>
<thead>
<tr>
<th>函数名</th>
<th style="text-align:center">实际效果</th>
<th style="text-align:center">实际对象</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#bind">bind(_Farg0::* const _Pmd, _Arg0&amp;&amp; _A0)</a></td>
<td style="text-align:center">11的新特性，auto配合万能绑定，参数能支持到20个参数，对成员函数绑定时第一个参数默认为传入<code>对象</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="#bind1st">bind1st(const op&amp; op, const T&amp; x)</a></td>
<td style="text-align:center">op(x, param)</td>
<td style="text-align:center">binder1st<op>(op, arg1_type(x))</op></td>
</tr>
<tr>
<td><a href="#bind2nd">bind2nd(const op&amp; op, const T&amp; x)</a></td>
<td style="text-align:center">op(param, x)</td>
<td style="text-align:center">binder2nd<op>(op, arg2_type(x))</op></td>
</tr>
<tr>
<td><a href="#not1">not1(const Pred&amp; pred)</a></td>
<td style="text-align:center">!pred(param)</td>
<td style="text-align:center">unary_negate<pred>(pred)</pred></td>
</tr>
<tr>
<td><a href="#not2">not2(const Pred&amp; pred)</a></td>
<td style="text-align:center">!pred(param1, param2)</td>
<td style="text-align:center">binary_negate<pred>(pred)</pred></td>
</tr>
<tr>
<td><a href="#compose1">compose1(const Op1&amp; op1, const Op2&amp; op2)</a></td>
<td style="text-align:center">op1(op2(param))</td>
<td style="text-align:center">unary_compose<op1, op2="">(op1, op2)</op1,></td>
</tr>
<tr>
<td><a href="#compose2">compose2(<br>const Op1&amp; op1,<br> const Op2&amp; op2,<br> const Op3&amp; op3)</a></td>
<td style="text-align:center">op1(op2(param),<br> op3(param))</td>
<td style="text-align:center">binary_compose<op1, op2,="" op3=""><br>(op1, op2, op3)</op1,></td>
</tr>
<tr>
<td><a href="#ptr_fun">ptr_fun(Result(*fp)(Arg))</a></td>
<td style="text-align:center">fp(param)</td>
<td style="text-align:center">pointer_to_unary_function<arg, result="">(fp)</arg,></td>
</tr>
<tr>
<td><a href="#ptr_fun">ptr_fun(Result(*fp)(Arg1, Arg2))</a></td>
<td style="text-align:center">fp(param1, param2)</td>
<td style="text-align:center">pointer_to_binary_function<arg1, arg2,="" result="">(fp)</arg1,></td>
</tr>
<tr>
<td><a href="#mem_fn">mem_fn()</a></td>
<td style="text-align:center">11的新特性，auto配合，和bind绑定成员函数块差别不大，第一个参数默认为传入<code>对象</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="#mem_fun">mem_fun(S (T::*f)())</a></td>
<td style="text-align:center">(param-&gt;*f)()</td>
<td style="text-align:center">mem_fun_t<s, t="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun">mem_fun(S (T::*f)() const)</a></td>
<td style="text-align:center">(param-&gt;*f)()</td>
<td style="text-align:center">const_mem_fun_t<s, t="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun_ref">mem_fun_ref(S (T::*f)())</a></td>
<td style="text-align:center">(param.*f)()</td>
<td style="text-align:center">mem_fun_ref_t<s, t="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun_ref">mem_fun_ref(S (T::*f)() const)</a></td>
<td style="text-align:center">(param.*f)()</td>
<td style="text-align:center">const_mem_fun_ref_t<s, t="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun1">mem_fun1(S (T::*f)(A))</a></td>
<td style="text-align:center">(param-&gt;*f)(x)</td>
<td style="text-align:center">mem_fun1_t<s, t,="" a="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun1">mem_fun1(S (T::*f)(A) const)</a></td>
<td style="text-align:center">(param-&gt;*f)(x)</td>
<td style="text-align:center">const_mem_fun1_t<s, t,="" a="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun1_ref">mem_fun1_ref(S (T::*f)(A))</a></td>
<td style="text-align:center">(param.*f)(x)</td>
<td style="text-align:center">mem_fun1_ref_t<s, t,="" a="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun1_ref">mem_fun1_ref(S (T::*f)(A) const)</a></td>
<td style="text-align:center">(param.*f)(x)</td>
<td style="text-align:center">const_mem_fun1_ref_t<s, t,="" a="">(f)</s,></td>
</tr>
</tbody>
</table>
<hr>
<p></p><h2 id="bind"> bind <h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">my_divide</span> <span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;<span class="keyword">return</span> x/y;&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> MyPair &#123;</div><div class="line"><span class="keyword">double</span> a,b;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> a*b;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Foo &#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_sum</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n1+n2 &lt;&lt; <span class="string">'\n'</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> data = <span class="number">10</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;    <span class="comment">//这里注意 adds visibility of _1, _2, _3,...</span></div><div class="line"></div><div class="line"><span class="comment">// binding functions:</span></div><div class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">std</span>::bind (my_divide,<span class="number">10</span>,<span class="number">2</span>);               <span class="comment">// returns 10/2</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_five() &lt;&lt; <span class="string">'\n'</span>;                          <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> fn_half = <span class="built_in">std</span>::bind (my_divide,<span class="number">_1</span>,<span class="number">2</span>);               <span class="comment">// returns x/2</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_half(<span class="number">10</span>) &lt;&lt; <span class="string">'\n'</span>;                        <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> fn_invert = <span class="built_in">std</span>::bind (my_divide,<span class="number">_2</span>,<span class="number">_1</span>);            <span class="comment">// returns y/x</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_invert(<span class="number">10</span>,<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>;                    <span class="comment">// 0.2</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> fn_rounding = <span class="built_in">std</span>::bind&lt;<span class="keyword">int</span>&gt; (my_divide,<span class="number">_1</span>,<span class="number">_2</span>);     <span class="comment">// returns int(x/y)</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_rounding(<span class="number">10</span>,<span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>;                  <span class="comment">// 3</span></div><div class="line"></div><div class="line">MyPair ten_two &#123;<span class="number">10</span>,<span class="number">2</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// binding members:</span></div><div class="line"><span class="keyword">auto</span> bound_member_fn = <span class="built_in">std</span>::bind (&amp;MyPair::multiply,<span class="number">_1</span>); <span class="comment">// returns x.multiply()</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bound_member_fn(ten_two) &lt;&lt; <span class="string">'\n'</span>;           <span class="comment">// 20</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> bound_member_data = <span class="built_in">std</span>::bind (&amp;MyPair::a,ten_two); <span class="comment">// returns ten_two.a</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bound_member_data() &lt;&lt; <span class="string">'\n'</span>; </div><div class="line"></div><div class="line">Foo foo;</div><div class="line"><span class="keyword">auto</span> f3 = <span class="built_in">std</span>::bind(&amp;Foo::print_sum, foo, <span class="number">95</span>, <span class="number">_1</span>);</div><div class="line">f3(<span class="number">5</span>);</div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="bind1st"> bind1st <h2><p></p>
<p></p><h2 id="bind2nd"> bind2nd <h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; a - b &lt;&lt; <span class="built_in">endl</span>;;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> <span class="number">_</span>tmain(<span class="keyword">int</span> argc, <span class="number">_</span>TCHAR* argv[])</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</div><div class="line">    for_each(a, a+<span class="number">4</span>, bind1st(ptr_fun(fun), <span class="number">2</span>));<span class="comment">//此处由于，bind1st要传入适配器，所以要么fun继承前面的多元函数，要么如此处理</span></div><div class="line">    for_each(a, a+<span class="number">4</span>, bind2nd(ptr_fun(fun), <span class="number">2</span>));</div><div class="line">    system(<span class="string">"pause"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="not1"> not1 <h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">count_if(a, a+<span class="number">5</span>, not1(bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">4</span>)))<span class="comment">//统计大于等于4的个数</span></div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="not2"> not2 <h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span> h = accumulate(a, a+<span class="number">5</span>, <span class="number">4</span>, not2(ptr_fun(fun)));<span class="comment">//此中的not2然并卵作用，主要是自己无法想到好的二元算法了</span></div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="compose1"> compose1 <h2><p></p>
<p></p><h2 id="compose2"> compose2 <h2><br><figure class="highlight c"><figcaption><span>它是GNU的所以vs STL没有，有源码如下++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="number">_F</span>n1, <span class="keyword">class</span> <span class="number">_F</span>n2&gt;</div><div class="line"><span class="keyword">class</span> unary_compose</div><div class="line">    : <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> <span class="number">_F</span>n2::argument_type,</div><div class="line">        <span class="keyword">typename</span> <span class="number">_F</span>n1::result_type&gt;</div><div class="line">&#123;    <span class="comment">// functor adapter _Func(stored, right)</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> unary_function&lt;<span class="keyword">typename</span> <span class="number">_F</span>n2::argument_type,</div><div class="line">        <span class="keyword">typename</span> <span class="number">_F</span>n1::result_type&gt; <span class="number">_B</span>ase;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="number">_B</span>ase::argument_type argument_type;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="number">_B</span>ase::result_type result_type;</div><div class="line"></div><div class="line">    unary_compose(<span class="keyword">const</span> <span class="number">_F</span>n1&amp; <span class="number">_F</span>unc1,</div><div class="line">        <span class="keyword">const</span> <span class="number">_F</span>n2&amp; <span class="number">_F</span>unc2)</div><div class="line">        : op1(<span class="number">_F</span>unc1), op2(<span class="number">_F</span>unc2)</div><div class="line">        &#123;    <span class="comment">// construct from functor and left operand</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    <span class="function">result_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> argument_type&amp; <span class="number">_</span>Value)</span> <span class="keyword">const</span></span></div><div class="line">        &#123;    <span class="comment">// apply functor to operands</span></div><div class="line">        <span class="keyword">return</span> (op1(op2(<span class="number">_</span>Value)));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    <span class="function">result_type <span class="title">operator</span><span class="params">()</span><span class="params">(argument_type&amp; <span class="number">_</span>Value)</span> <span class="keyword">const</span></span></div><div class="line">        &#123;    <span class="comment">// apply functor to operands</span></div><div class="line">        <span class="keyword">return</span> (op1(op2(<span class="number">_</span>Value)));</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="number">_F</span>n1 op1;    <span class="comment">// the functor to apply</span></div><div class="line">    <span class="number">_F</span>n2 op2;    <span class="comment">// the functor to apply</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="number">_F</span>n1,</div><div class="line"><span class="keyword">class</span> <span class="number">_F</span>n2&gt; <span class="keyword">inline</span></div><div class="line">unary_compose&lt;<span class="number">_F</span>n1, <span class="number">_F</span>n2&gt; compose1(<span class="keyword">const</span> <span class="number">_F</span>n1&amp; <span class="number">_F</span>unc1, <span class="keyword">const</span> <span class="number">_F</span>n2&amp; <span class="number">_F</span>unc2)</div><div class="line">&#123;    <span class="comment">// return a unary_compose functor adapter</span></div><div class="line">    <span class="keyword">return</span> (unary_compose&lt;<span class="number">_F</span>n1, <span class="number">_F</span>n2&gt;(<span class="number">_F</span>unc1, <span class="number">_F</span>unc2));</div><div class="line">&#125;</div><div class="line"></div><div class="line">for_each(a, a+<span class="number">5</span>, compose1(bind2nd(multiplies&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>), bind2nd(plus&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>))); </div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="ptr_fun"> ptr_fun <h2><p></p>
<blockquote>
<p>上面已经有代码演示，无需</p>
</blockquote>
<hr>
<p></p><h2 id="mem_fun"> mem_fun <h2><br><figure class="highlight c"><figcaption><span>成员对象必须是指针++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> <span class="built_in">vector</span> &lt;<span class="built_in">string</span>*&gt; numbers;</div><div class="line"></div><div class="line"><span class="comment">// populate vector of pointers:</span></div><div class="line">numbers.push_back ( <span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"one"</span>) );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"two"</span>) );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"three"</span>) );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"four"</span>) );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"five"</span>) );</div><div class="line"></div><div class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; lengths ( numbers.size() );</div><div class="line"></div><div class="line">transform (numbers.begin(), numbers.end(), lengths.begin(), mem_fun(&amp;<span class="built_in">string</span>::length));</div><div class="line">    </div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *numbers[i] &lt;&lt; <span class="string">" has "</span> &lt;&lt; lengths[i] &lt;&lt; <span class="string">" letters.\n"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// deallocate strings:</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>*&gt;::iterator it = numbers.begin(); it!=numbers.end(); ++it)</div><div class="line">    <span class="keyword">delete</span> *it;</div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="mem_fun1"> mem_fun1 <h2><p></p>
<blockquote>
<p>这个函数并不像<code>实际效果</code>那样，它应该是俩个参数，且各个绑定不同。<br>此函数11之后被淘汰</p>
</blockquote>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   numbers.push_back ( <span class="keyword">new</span> dd );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> dd );</div><div class="line"></div><div class="line">   <span class="keyword">class</span> dd &#123;</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">       dd() &#123;&#125;</div><div class="line">       ~dd() &#123;&#125;</div><div class="line">       <span class="function"><span class="keyword">int</span> <span class="title">aa</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">           <span class="built_in">cout</span> &lt;&lt; a - <span class="number">1</span>  &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">           <span class="keyword">return</span> a - <span class="number">1</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line">   for_each (numbers.begin(), numbers.end(), bind2nd(mem_fun1(&amp;dd::aa), <span class="number">2</span>));<span class="comment">//如此便是循环执行：iterator-&gt;aa(2);</span></div><div class="line"></div><div class="line">   <span class="comment">////////////////////////////</span></div><div class="line">   numbers.push_back ( <span class="keyword">new</span> dd );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> dd );</div><div class="line"></div><div class="line">   <span class="keyword">class</span> aa &#123;</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">       aa() &#123;&#125;</div><div class="line">       ~aa() &#123;&#125;</div><div class="line">       <span class="function"><span class="keyword">int</span> <span class="title">dd</span><span class="params">(dd* a)</span> </span>&#123;</div><div class="line">           <span class="built_in">cout</span> &lt;&lt; <span class="number">33</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">           <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line">   aa s;</div><div class="line">   for_each (numbers.begin(), numbers.end(), bind1st(mem_fun1(&amp;aa::dd), &amp;s));<span class="comment">//如此便是循环执行：(&amp;s)-&gt;dd(iterator);</span></div><div class="line"></div></pre></td></tr></table></figure>
<hr>
<p></p><h2 id="mem_fun_ref"> mem_fun_ref <h2><p></p>
<p></p><h2 id="mem_fun1_ref"> mem_fun1_ref <h2><p></p>
<blockquote>
<p>它们和<code>mem_fun</code>区别在于，iterator是对象，而不是指针。<br>mem_fun1_ref此函数11之后被淘汰</p>
</blockquote>
<hr>
<p></p><h2 id="mem_fn"> mem_fn <h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   dd a;</div><div class="line"><span class="keyword">auto</span> triple = <span class="built_in">std</span>::mem_fn(&amp;dd::aa);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; triple(a, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//以a为调用对象，传入2</span></div><div class="line"></div></pre></td></tr></table></figure><p></p>
</h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MP3解码过程小知识181]]></title>
      <url>https://xuecat.github.io/2016/09/08/181/</url>
      <content type="html"><![CDATA[<p>代码暂时不提供了，直接去<code>178</code>的sobey库寻。说明MP3音频过程遇见。</p>
<ol>
<li>帧头是大端字节，所以要转换下</li>
<li>判断是否是帧头，看第一个字节是否是FF，同步信息第一个字节必须是FF（qq音乐喜欢用ff fe，网络音乐喜欢用ff fb）</li>
<li>vbr的xing头并不影响解码，照常使用，只是在标签帧中多些信息而已</li>
<li>有些MP3没有TAG ID3V2头只有ID3V1头，文件起点直接开始第一帧帧头，数据。。。</li>
<li><p>有些MP3的TAG ID3V2头算出来的大小不准确，并不能找到第一帧位置。<br>这时，多半是它在第一帧和标签头之间又填充了很多无用信息<br>此时只能一个个字节去找FF帧头了</p>
</li>
<li><p>MP3标签帧对图片有保存：<a href="http://blog.csdn.net/studywithallofyou/article/details/7738785" target="_blank" rel="external">http://blog.csdn.net/studywithallofyou/article/details/7738785</a>  但是我在用ue去解析qq的MP3文件，却发现无APIC，虽没用代码检测，<code>先标记吧</code></p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[180]]></title>
      <url>https://xuecat.github.io/2016/09/08/180/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><h5 id="“梦里相逢人不见，若知是梦何须醒。纵然梦里常幽会，怎比真如见一回。”"><a href="#“梦里相逢人不见，若知是梦何须醒。纵然梦里常幽会，怎比真如见一回。”" class="headerlink" title="“梦里相逢人不见，若知是梦何须醒。纵然梦里常幽会，怎比真如见一回。”"></a>“梦里相逢人不见，若知是梦何须醒。纵然梦里常幽会，怎比真如见一回。”</h5></blockquote>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bmp的颜色存储179]]></title>
      <url>https://xuecat.github.io/2016/09/06/179/</url>
      <content type="html"><![CDATA[<p><strong>BGR与Bit-Fields</strong><br>当图像中引用的色彩超过256种时，我们就需要16bpp或更高bpp的位图。调色板不适合bpp较大的位图，因此16bpp以上的位图都不使用调 色板。<br>不使用调色板的位图图像有两种编码格式：RGB和Bit-Fields（下称BF）。<br></p>
<p>RGB编码格式是一种均分的思想，使Red、Green、Blue三个颜色分量所包含的信息容量尽可能一样大。<br>16bpp-RGB：在每个像素所占的16bits中，低5位表示Blue分量；中5为表示Green分量；高5位表示Red分量；最高1位无意义 （后来有些应用程序将其视为透明度Alpha分量，但这并不是标准）。<br>所以从低到高的顺序实际上是B-G-R，这也是我在BMP简介的表格里，把RGB的 编码方式都写成BGR的原因。<br><br>24bpp-RGB：24bpp的位图又称为真彩位图，它通常只有这一种编码格式，在24bits中，低8位表示Blue分量；中8为表示 Green分量；高8位表示Red分量。BGR<br><br>32bpp-RGB：在32bits中，低24位的编码方式与24bpp位图相同，最高8位用来表示透明度Alpha分量。<br>32bpp的位图尺寸太 大，一般只有在图像处理的中间过程中使用。对于需要半透过效果的图像，更好的选择是PNG格式。<br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Sobey的sdk库178]]></title>
      <url>https://xuecat.github.io/2016/08/30/178/</url>
      <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>头文件</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#SBT_WAVFileReadWrite">SBT_WAVFileReadWrite</a></td>
<td style="text-align:center">Wave文件读写（附重采样转换）</td>
</tr>
<tr>
<td><a href="#SBT_PCMAdvProcess">SBT_PCMAdvProcess</a></td>
<td style="text-align:center">PCM数据操作：重采样转换、WAV数据大小计算（整个音频数据长度）、(跳下)</td>
</tr>
<tr>
<td><a href="#SBT_PCMAdvProcess2">SBT_PCMAdvProcess2</a></td>
<td style="text-align:center">SBT_AudioMIX_Param_ST,没用过，从解释感觉是通道增益 <code>待更新</code></td>
</tr>
<tr>
<td><a href="#SBT_PCMBasicProcess">SBT_PCMBasicProcess</a></td>
<td style="text-align:center">PCM数据操作：重采样、调节音量、声道分离、声道合并、降噪、采样率过滤、（跳下）</td>
</tr>
<tr>
<td><a href="#SBT_PCMBasicProcess2">SBT_PCMBasicProcess2</a></td>
<td style="text-align:center">时间计算</td>
</tr>
<tr>
<td><a href="#SBT_MPEGBufferEncode">SBT_MPEGBufferEncode</a></td>
<td style="text-align:center">MPEG编码，视频和音频基带数据编码，只用过YUV、RGB基带数据视频编码其它未尝试<code>待更新</code></td>
</tr>
<tr>
<td><a href="#SBT_MPGABufferDecode">SBT_MPGABufferDecode</a></td>
<td style="text-align:center">MPGE(mpga)音频的解码,支持mp1/mp2/mp3解码（帧解码）,对应SBT_MPABufferEncode</td>
</tr>
<tr>
<td><a href="#SBT_CutlistV2">SBT_CutlistV2</a></td>
<td style="text-align:center">万能代码，把文件名给传给cutlist，让cutlist播，自己去取缓存</td>
</tr>
<tr>
<td><a href="#SBT_MediaDetect">SBT_MediaDetect</a></td>
<td style="text-align:center">万能媒体文件读取，读取视音频文件信息，GetClipSampleIcon不知道何用<code>待更新</code></td>
</tr>
<tr>
<td><a href="#SBT_MediaDetect2">SBT_MediaDetect2</a></td>
<td style="text-align:center">同上，增加可读性的文件读取，测试代码见<a href="#SBT_CutlistV2">SBT_CutlistV2</a></td>
</tr>
</tbody>
</table>
<hr>
<p></p><h2 id="SBT_WAVFileReadWrite"> SBT_WAVFileReadWrite <h2><p></p>
<ol>
<li>writer是自带重采样的（采样率或通道转换）</li>
<li>readerex才带有重采样功能<figure class="highlight c"><figcaption><span>测试代码：++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   BYTE* bybuffer = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">BOOL end;</div><div class="line">WAVEFORMATEX wavef, *pwave;</div><div class="line">Init_StanderWave(wavef);</div><div class="line"></div><div class="line">pwave = &amp;wavef;</div><div class="line">SBT_WAVFileReaderEx read;</div><div class="line">read.Initialize();</div><div class="line">read.SetInputFile(<span class="number">_</span>T(<span class="string">"D:\\tebig.wav"</span>));</div><div class="line">read.GetOutputWAVEFormat(&amp;pwave);</div><div class="line">wavef.nChannels = pwave-&gt;nChannels;</div><div class="line">wavef.wBitsPerSample = pwave-&gt;wBitsPerSample;</div><div class="line">Calcute_Block_SamplesPer(wavef);</div><div class="line">read.SetOutputWAVEFormat(&amp;wavef);</div><div class="line">read.SetPCMFrameSize(BY_BYTE, wavef.nAvgBytesPerSec/<span class="number">25</span>);<span class="comment">//</span></div><div class="line">read.EnableInternalBuffer();</div><div class="line">read.StartRead();</div><div class="line"></div><div class="line">SBT_WAVFileWriter wavwrite;</div><div class="line"><span class="keyword">int</span> ar = wavwrite.Initialize();</div><div class="line">ar = wavwrite.SetOutputFile(<span class="number">_</span>T(<span class="string">"D:\\wwaw.wav"</span>));</div><div class="line">ar = wavwrite.SetInputWAVEFormat(&amp;wavef);</div><div class="line">ar = wavwrite.SetOutputWAVEFormat(&amp;wavef);</div><div class="line">ar = wavwrite.StartWrite();</div><div class="line"></div><div class="line"><span class="keyword">while</span> (<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">	read.ReadEx(BY_BYTE, wavef.nAvgBytesPerSec/<span class="number">25</span>, &amp;bybuffer, &amp;len, &amp;pwave, &amp;end);<span class="comment">//输出长度依旧不定长不知为何,BY_FRAME我没成功过</span></div><div class="line">	<span class="keyword">if</span> (end)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	ar = wavwrite.SetInputBuffer(bybuffer, len);<span class="comment">//这个函数很挑剔，SBT_PCMBasicProcess2的从采样数据输入就不行（不知为何）。</span></div><div class="line">&#125;</div><div class="line">wavwrite.StopWrite();</div><div class="line">   </div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p></p><h2 id="SBT_PCMAdvProcess"> SBT_PCMAdvProcess <h2><p></p>
<p></p><h2 id="SBT_PCMAdvProcess2"> SBT_PCMAdvProcess2 <h2><p></p>
<ol>
<li>这个是通过名和void指针调用</li>
</ol>
<hr>
<p></p><h2 id="SBT_PCMBasicProcess"> SBT_PCMBasicProcess <h2><p></p>
<p></p><h2 id="SBT_PCMBasicProcess2"> SBT_PCMBasicProcess2 <h2><p></p>
<ol>
<li>CalResampleParam参数未知，待研究</li>
<li>ReformatLPCM在按照帧做转换时会出现输出数据不定长（连续写入也有问题），ReformatLPCM2按帧转换输出长度比较正常，但是对WAVEFORMATEX要计算好。<figure class="highlight c"><figcaption><span>测试代码：++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">m_SBPcmProcess.ReformatLPCM2(*m_pSrcWave, m_pReadData, inlen, *m_pDstWave, &amp;pOut1, &amp;outlen1);</div><div class="line"></div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p></p><h2 id="SBT_MPEGBufferEncode"> SBT_MPEGBufferEncode <h2><br><figure class="highlight c"><figcaption><span>测试代码：++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">SBT_MPEGBufferEncode*	m_pBufferEncode;</div><div class="line">DO(m_pBufferEncode-&gt;SetEncodeOperationMode(XH_MPEG_ESBUF_OUT));</div><div class="line">    </div><div class="line">XH_MPEG_ENCODE_PARAM paramIn;</div><div class="line">paramIn.GetDefaultParam(m_nVideoType == SD_TYPE ? XH_MPEG2_422PML : XH_MPEG2_422PHL);</div><div class="line">paramIn.chroma_format = <span class="number">1</span>;</div><div class="line">paramIn.group_I_frame_count = <span class="number">1</span>;</div><div class="line">paramIn.group_B_frame_count = <span class="number">0</span>;</div><div class="line">paramIn.group_P_frame_count = <span class="number">0</span>;</div><div class="line"></div><div class="line">DO(m_pBufferEncode-&gt;SetEncodeParam(&amp;paramIn));</div><div class="line">DO(m_pBufferEncode-&gt;SetEncodeOutputCB(XH_VIDEO_OUTPUT_CB, EncodeOutCB, <span class="keyword">this</span>));</div><div class="line"></div><div class="line">m_bitInfoHead.biCompression = BI_RGB;</div><div class="line">DO(m_pBufferEncode-&gt;SetVideoInputBufferFormat(&amp;m_bitInfoHead));</div><div class="line">DO(m_pBufferEncode-&gt;StartEncode());</div><div class="line">DO(m_pBufferEncode-&gt;SetVideoInputBuffer(m_pBmpDataBuf, m_dwBmpSize));</div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="SBT_MPGABufferDecode"> SBT_MPGABufferDecode <h2><br><figure class="highlight"><figcaption><span>测试代码：++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//这是mp3解码测试，从MP3里一个个读取帧数据，再放入解码。</div><div class="line">//对pcm文件写入，要用SBT_WAVFileReadWrite。</div><div class="line">//自写的pcm文件写入老是有点问题，也没调试；代码不易，暂时放入记录以后修改。</div><div class="line">#define Calcute_Block_SamplesPer(outhead) outhead.nBlockAlign = (outhead.nChannels * outhead.wBitsPerSample) / 8;\</div><div class="line">outhead.nAvgBytesPerSec = outhead.nSamplesPerSec * outhead.nBlockAlign;</div><div class="line"></div><div class="line">#define Create_DstWave(outhead, inhead) \</div><div class="line">	outhead.wFormatTag = 1;\</div><div class="line">	outhead.nSamplesPerSec = 48000;\</div><div class="line">	outhead.nAvgBytesPerSec = 1152000;\</div><div class="line">	outhead.nChannels = 8;\</div><div class="line">	outhead.nBlockAlign = 24;\</div><div class="line">	outhead.wBitsPerSample = inhead.wBitsPerSample;\</div><div class="line">	Calcute_Block_SamplesPer(outhead);</div><div class="line"></div><div class="line">#define GetID3V2Size(header) (header.Size[0] &amp; 0x7F)&lt;&lt; 21 | (header.Size[1] &amp; 0x7F) &lt;&lt; 14 | (header.Size[2] &amp; 0x7F) &lt;&lt; 7 | (header.Size[3] &amp; 0x7F); </div><div class="line"></div><div class="line">#define BITRATEFREE 0xfffe</div><div class="line">#define BITRATEBAD  0xffff</div><div class="line"></div><div class="line">//// MP3FRAMEHEADER structure</div><div class="line">//struct MP3FRAMEHEADER //4byte</div><div class="line">//&#123;</div><div class="line">//	unsigned framesync   :11;    //同步信息</div><div class="line">//	unsigned MPEGID      : 2;    //版本</div><div class="line">//	unsigned layer       : 2;    //层</div><div class="line">//	unsigned protectbit  : 1;    //CRC 校验</div><div class="line">//	unsigned bitrateindx : 4;    //位率</div><div class="line">//	unsigned samplefreq  : 2;    //采样率</div><div class="line">//	unsigned paddingbit  : 1;    //帧长调节</div><div class="line">//	unsigned privatebit  : 1;    //保留字</div><div class="line">//	unsigned channel     : 2;    //声道模式</div><div class="line">//	unsigned modeext     : 2;    //扩充模型</div><div class="line">//	unsigned copyright   : 1;    //Copyright</div><div class="line">//	unsigned original    : 1;    //原版标志</div><div class="line">//	unsigned emphasis    : 2;    //强调模式</div><div class="line">//&#125;;</div><div class="line"></div><div class="line">// MP3FRAMEHEADER structure</div><div class="line">struct MP3FRAMEHEADER</div><div class="line">&#123;</div><div class="line">	unsigned emphasis : 2;			// M</div><div class="line">	unsigned original : 1;			// L</div><div class="line">	unsigned copyright : 1;			// K</div><div class="line">	unsigned modeext : 2;			// J</div><div class="line">	unsigned channel : 2;			// I</div><div class="line">	unsigned privatebit : 1;			// H</div><div class="line">	unsigned paddingbit : 1;			// G</div><div class="line">	unsigned samplefreq : 2;		// F</div><div class="line">	unsigned bitrateindx : 4;			// E</div><div class="line">	unsigned protectbit : 1;			// D</div><div class="line">	unsigned layer : 2;			// C</div><div class="line">	unsigned MPEGID : 2;			// B</div><div class="line">	unsigned framesync : 11;		// A</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct MP3ID3V2TAG //10byte</div><div class="line">&#123;</div><div class="line">	char Header[3];//ID3</div><div class="line">	char Ver;//3</div><div class="line">	char Revision;</div><div class="line">	char Flag;</div><div class="line">	char Size[4];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// MP3ID3V1TAG structure</div><div class="line">struct MP3ID3V1TAG//128byte</div><div class="line">&#123;</div><div class="line">	char ident[3]; // TAG</div><div class="line">	char title[30];</div><div class="line">	char artist[30];</div><div class="line">	char album[30];</div><div class="line">	char year[4];</div><div class="line">	char comment[28];</div><div class="line">	BYTE reserved;</div><div class="line">	BYTE tracknum;</div><div class="line">	BYTE genre;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">int g_BitRates[] = &#123;</div><div class="line">	BITRATEFREE, BITRATEFREE, BITRATEFREE, BITRATEFREE, BITRATEFREE, </div><div class="line">	32,  32,  32,  32,    8,</div><div class="line">	64,  48,  40,  48,   16,</div><div class="line">	96,  56,  48,  56,  24,</div><div class="line">	128,  64,  56,  64,  32,</div><div class="line">	160,  80,  64,  80,  40,</div><div class="line">	192,  96,  80,  96,  48,</div><div class="line">	224, 112,  96, 112,  56,</div><div class="line">	256, 128, 112, 128,  64,</div><div class="line">	288, 160, 128, 144,  80,</div><div class="line">	320, 192, 160, 160,  96,</div><div class="line">	352, 224, 192, 176, 112,</div><div class="line">	384, 256, 224, 192, 128,</div><div class="line">	416, 320, 256, 224, 144,</div><div class="line">	448, 384, 320, 256, 160,</div><div class="line">	BITRATEBAD, BITRATEBAD, BITRATEBAD, BITRATEBAD, BITRATEBAD</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int g_SampleCountMap[4][4] = &#123;</div><div class="line">	0,    0,    0,    0,</div><div class="line">	576,  0,  576, 1152, //l3</div><div class="line">	1152, 0, 1152, 1152, //l2</div><div class="line">	384,  0,  384,  384, //l1</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int g_SampleRate[4][4] = &#123;</div><div class="line">	11025, 0, 22050, 44100,//0</div><div class="line">	12000,     0,    24000,   48000,//1</div><div class="line">	8000,		0,	  16000,   32000,//2</div><div class="line">	0,		0,		0,	0,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int GetBitRate(INT nlayer, INT nversion, int nbitindex)</div><div class="line">&#123;</div><div class="line">	if (nversion == 3)</div><div class="line">	&#123;</div><div class="line">		return g_BitRates[nbitindex * 5 + (3 - nlayer)];</div><div class="line">	&#125;</div><div class="line">	else if (nversion == 2)//</div><div class="line">	&#123;</div><div class="line">		if (nlayer == 3)</div><div class="line">			return g_BitRates[nbitindex * 5 + 3];</div><div class="line">		else</div><div class="line">			return g_BitRates[nbitindex * 5 + 4];</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool Is_Mp3FrameHead(const unsigned char * pHead) </div><div class="line">&#123;</div><div class="line">	if (pHead[0] == 0xff &amp;&amp; (pHead[1] &amp; 0xe0) == 0xe0)</div><div class="line">	&#123;</div><div class="line">		if (((pHead[1] &amp; 0x06) &gt;&gt; 1) == 0) return 0; /* no layer 4 */</div><div class="line">		if (((pHead[2] &amp; 0xf0) &gt;&gt; 4) == 15) return 0; /* bitrate can't be 1111 */</div><div class="line">		if (((pHead[2] &amp; 0x0c) &gt;&gt; 2) == 3) return 0; /* samplerate can't be 11 */</div><div class="line">		return 1;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool Is_Mp3V1Head(const unsigned char* pHead)</div><div class="line">&#123;</div><div class="line">	if (pHead[0] == 0x00 &amp;&amp; pHead[1] == 0x00 &amp;&amp; pHead[2] == 0x01 &amp;&amp; pHead[3] == 0xba) &#123;</div><div class="line">		return 1;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void ChangeEndian(void* pBuffer, int nBufSize)</div><div class="line">&#123;</div><div class="line">	if (!pBuffer || !nBufSize)</div><div class="line">		return;</div><div class="line"></div><div class="line">	char temp;</div><div class="line">	for (int i = 0; i &lt; nBufSize / 2; i++)</div><div class="line">	&#123;</div><div class="line">		temp = ((char*)pBuffer)[i];</div><div class="line">		((char*)pBuffer)[i] = ((char*)pBuffer)[nBufSize - i - 1];</div><div class="line">		((char*)pBuffer)[nBufSize - i - 1] = temp;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void writefilehead(WAVEFORMATEX&amp; head, int sz, FILE* pwrite)</div><div class="line">&#123;</div><div class="line">	int bits = head.wBitsPerSample;</div><div class="line">	char *data = (char*)"RIFF";</div><div class="line">	short short_temp;</div><div class="line">	int long_temp;</div><div class="line">	int fileSize;</div><div class="line">	int size = sz;</div><div class="line"></div><div class="line">	fileSize = size + 36;</div><div class="line"></div><div class="line">	data = (char*)"RIFF";</div><div class="line">	fwrite(data, sizeof(char), 4, pwrite);</div><div class="line">	fwrite(&amp;fileSize, sizeof(int), 1, pwrite);</div><div class="line">	data = (char*)"WAVE";</div><div class="line">	fwrite(data,sizeof(char),4,pwrite);</div><div class="line">	data = (char*)"fmt ";</div><div class="line">	fwrite(data,sizeof(char),4,pwrite);</div><div class="line">	long_temp = 16;</div><div class="line">	fwrite(&amp;long_temp, sizeof(int), 1, pwrite);</div><div class="line">	short_temp = 0x01;</div><div class="line">	fwrite(&amp;short_temp,sizeof(int),1,pwrite);</div><div class="line"></div><div class="line">	short_temp = (head.nChannels);</div><div class="line">	fwrite(&amp;short_temp, sizeof(short), 1,pwrite);</div><div class="line">	long_temp=(head.nSamplesPerSec);</div><div class="line">	fwrite(&amp;long_temp,sizeof(int),1,pwrite);</div><div class="line">	long_temp=(bits/8)*(head.nChannels)*(head.nSamplesPerSec);</div><div class="line">	fwrite(&amp;long_temp,sizeof(int),1,pwrite);</div><div class="line">	short_temp=(bits/8)*(head.nChannels);</div><div class="line">	fwrite(&amp;short_temp,sizeof(short),1,pwrite);</div><div class="line">	short_temp=(bits);</div><div class="line">	fwrite(&amp;short_temp,sizeof(short),1,pwrite);</div><div class="line"></div><div class="line">	data=(char*)"data";</div><div class="line">	fwrite(data,sizeof(char),4,pwrite);</div><div class="line">	fwrite(&amp;size,sizeof(int),1,pwrite);</div><div class="line">	fseek(pwrite,44,SEEK_SET);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int CBmp2Video::ReadMP3(int lengh)</div><div class="line">&#123;</div><div class="line">	#define Release_And_Return() &#123; fclose(m_pAudioInfo-&gt;pFile);\</div><div class="line">	delete m_pAudioInfo;\</div><div class="line">	m_pAudioInfo = NULL;\</div><div class="line">	return 0;&#125;\</div><div class="line"></div><div class="line">	if (m_pAudioInfo-&gt;pFile == NULL)</div><div class="line">		return 0;</div><div class="line"></div><div class="line">	int nReadPos = 0;</div><div class="line">	int v2headsz = 0;</div><div class="line">	SBT_MPGABufferDecode decode;</div><div class="line">	MP3FRAMEHEADER frameHead = &#123;0&#125;;</div><div class="line">	MP3ID3V2TAG v2tag = &#123;0&#125;;</div><div class="line"></div><div class="line">	int rd = fread_s(&amp;v2tag, sizeof(MP3ID3V2TAG), sizeof(MP3ID3V2TAG), 1, m_pAudioInfo-&gt;pFile);</div><div class="line">	if (rd &lt; 1)</div><div class="line">		Release_And_Return();</div><div class="line"></div><div class="line">	if (v2tag.Header[0] == 'I' &amp;&amp;//</div><div class="line">		v2tag.Header[1] == 'D' &amp;&amp;</div><div class="line">		v2tag.Header[2] == '3')</div><div class="line">	&#123;</div><div class="line">		if (v2tag.Ver != 3)</div><div class="line">			Release_And_Return();</div><div class="line"></div><div class="line">		v2headsz = GetID3V2Size(v2tag);</div><div class="line"></div><div class="line">		rd = fseek(m_pAudioInfo-&gt;pFile, v2headsz, SEEK_CUR);</div><div class="line">		</div><div class="line">		bool bfind = false;</div><div class="line">		int nBlockPos = 0;</div><div class="line">		BYTE headbuffer[10] = &#123;0&#125;;</div><div class="line">		while (true)//部分MP3，会对标签到第一帧进行多余填充，此时长度无法定位第一帧，只能一个一个读取寻找</div><div class="line">		&#123;</div><div class="line">			if (bfind)</div><div class="line">				break;</div><div class="line"></div><div class="line">			rd = fread_s(&amp;headbuffer, sizeof(headbuffer) * sizeof(BYTE), sizeof(headbuffer) * sizeof(BYTE), 1, m_pAudioInfo-&gt;pFile);</div><div class="line">			for (int i = 0; i &lt; 10; i++)</div><div class="line">			&#123;</div><div class="line">				if (headbuffer[i] == 255)</div><div class="line">				&#123;</div><div class="line">					bfind = true;</div><div class="line">					break;</div><div class="line">				&#125;</div><div class="line">				nBlockPos++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		nReadPos = v2headsz + nBlockPos + 10;</div><div class="line">		rd = fseek(m_pAudioInfo-&gt;pFile, nReadPos, SEEK_SET);</div><div class="line">	&#125;</div><div class="line">	else//当没有标签头时</div><div class="line">	&#123;</div><div class="line">		rd = fseek(m_pAudioInfo-&gt;pFile, 0-sizeof(MP3ID3V2TAG), SEEK_CUR);</div><div class="line">		nReadPos = 0;</div><div class="line">	&#125;</div><div class="line">	if (rd == 0)</div><div class="line">	&#123;</div><div class="line">		m_pAudioInfo-&gt;nDataType = MP3_TYPE;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	SBT_MPGABufferDecode decode;</div><div class="line"></div><div class="line">	FILE* writewave = NULL;</div><div class="line">	int allsize = 0;</div><div class="line">	int nsamplerate = 0;</div><div class="line">	int outlen = 0;</div><div class="line">	int nbitrate = 0;</div><div class="line">	int nframebyte = 0;</div><div class="line">	bool bhavehead = false;</div><div class="line">	WAVEFORMATEX writeformat = &#123;0&#125;;</div><div class="line">	MP3FRAMEHEADER frameHead = &#123;0&#125;;</div><div class="line"></div><div class="line">	decode.Initialize();</div><div class="line">	decode.StartDecode();</div><div class="line"></div><div class="line">	fopen_s(&amp;writewave, "www.wav", "wb");</div><div class="line"></div><div class="line">	rd = fread_s(&amp;frameHead, sizeof(MP3FRAMEHEADER), sizeof(MP3FRAMEHEADER), 1, m_pAudioInfo-&gt;pFile);</div><div class="line"></div><div class="line">	while (rd &gt; 0)</div><div class="line">	&#123;</div><div class="line">		if (rd &lt; 1)</div><div class="line">			return -1;</div><div class="line">		else if (Is_Mp3FrameHead((const unsigned char*)&amp;frameHead))</div><div class="line">		&#123;</div><div class="line">			fseek(m_pAudioInfo-&gt;pFile, 0-sizeof(MP3FRAMEHEADER), SEEK_CUR);</div><div class="line"></div><div class="line">			ChangeEndian(&amp;frameHead, 4);</div><div class="line"></div><div class="line">			nsamplerate = g_SampleRate[frameHead.samplefreq][frameHead.MPEGID];</div><div class="line">			nbitrate	= GetBitRate(frameHead.layer, frameHead.MPEGID, frameHead.bitrateindx);</div><div class="line"></div><div class="line">			if (frameHead.layer == 3)</div><div class="line">				nframebyte = (12000 * nbitrate / nsamplerate + frameHead.paddingbit) * 4;</div><div class="line">			else</div><div class="line">				nframebyte = 144000 * nbitrate / nsamplerate + frameHead.paddingbit;</div><div class="line"></div><div class="line">			int noutDecodelen = 0;</div><div class="line">			BYTE* poutDecodebuffer = NULL;</div><div class="line">			BYTE* pReadbuffer = new BYTE[nframebyte];</div><div class="line">			rd = fread_s(pReadbuffer, nframebyte, nframebyte, 1, m_pAudioInfo-&gt;pFile);</div><div class="line">			</div><div class="line">			//解码</div><div class="line">			nReadPos += nframebyte;</div><div class="line">			MPEG_AUDIO_FRAME_INFO mpginfo = &#123;0&#125;;</div><div class="line">			decode.GetAudioFrameInfo(pReadbuffer, nframebyte, mpginfo);</div><div class="line">			rd = decode.SetInputBuffer(pReadbuffer, nframebyte);</div><div class="line">			rd = decode.GetOutputBufferFormat(&amp;noutDecodelen, &amp;writeformat);</div><div class="line">			rd = decode.GetOutputBuffer(&amp;poutDecodebuffer, &amp;noutDecodelen);</div><div class="line"></div><div class="line">			allsize += noutDecodelen;</div><div class="line">			if (!bhavehead)</div><div class="line">			&#123;</div><div class="line">				bhavehead = true;</div><div class="line">				writefilehead(writeformat, noutDecodelen, writewave);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			fwrite(poutDecodebuffer, noutDecodelen, 1, writewave);</div><div class="line"></div><div class="line">			delete pReadbuffer;</div><div class="line"></div><div class="line">			if (nReadPos &gt;= lengh)</div><div class="line">			&#123;</div><div class="line">				break;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		else if (Is_Mp3V1Head((const unsigned char*)&amp;frameHead))</div><div class="line">		&#123;</div><div class="line">			return -1;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		rd = fread_s(&amp;frameHead, sizeof(MP3FRAMEHEADER), sizeof(MP3FRAMEHEADER), 1, m_pAudioInfo-&gt;pFile);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	fseek(writewave, 40, SEEK_SET);</div><div class="line">	fwrite(&amp;allsize, 1, sizeof(int), writewave);</div><div class="line">	allsize += 36;</div><div class="line">	fseek(writewave, 4, SEEK_SET);</div><div class="line">	fwrite(&amp;allsize, 1, sizeof(int), writewave);</div><div class="line">	fclose(writewave);</div><div class="line"></div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="SBT_CutlistV2"> SBT_CutlistV2 <h2><br><figure class="highlight c"><figcaption><span>测试代码：++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="keyword">int</span> allsize = <span class="number">0</span>;</div><div class="line">*FILE* writewave = <span class="literal">NULL</span>;</div><div class="line">fopen_s(&amp;writewave, <span class="string">"D:\\wwq.wav"</span>, <span class="string">"wb"</span>);*/</div><div class="line">SBT_WAVFileWriter wavewrite;</div><div class="line">SBT_MEDIA_INFO2 info2;</div><div class="line">SBT_MediaDetect2 detect2;</div><div class="line">detect2.SetInputFile(lpPath);</div><div class="line">detect2.GetMediaInfo2(&amp;info2);</div><div class="line"></div><div class="line">WAVEFORMATEX outhead = info2.AudioInfo(<span class="number">0</span>).stWavFormat;</div><div class="line">outhead.nSamplesPerSec = <span class="number">48000</span>;</div><div class="line">Calcute_Block_SamplesPer(outhead);</div><div class="line"></div><div class="line">AM_MEDIA_TYPE meditype = &#123;<span class="number">0</span>&#125;;</div><div class="line">meditype.majortype = MEDIATYPE_Audio;</div><div class="line">meditype.formattype = FORMAT_WaveFormatEx;</div><div class="line">meditype.cbFormat = <span class="keyword">sizeof</span>(WAVEFORMATEX);</div><div class="line">meditype.pbFormat = <span class="keyword">new</span> BYTE[meditype.cbFormat];</div><div class="line">memcpy_s(meditype.pbFormat, <span class="keyword">sizeof</span>(WAVEFORMATEX), &amp;outhead, <span class="keyword">sizeof</span>(WAVEFORMATEX));</div><div class="line"></div><div class="line">ST_CUTLIST_ITEM* pItemList = <span class="keyword">new</span> ST_CUTLIST_ITEM[<span class="number">1</span>];</div><div class="line"><span class="keyword">int</span> nFrameNum = (<span class="keyword">int</span>)((info2.AudioInfo(<span class="number">0</span>).llDuration*<span class="number">25</span>/(<span class="number">1000</span>*<span class="number">10</span>*<span class="number">1000</span>))+<span class="number">0.001</span>);</div><div class="line">pItemList[<span class="number">0</span>].llMediaOut = nFrameNum;</div><div class="line">pItemList[<span class="number">0</span>].llTimelineIn = <span class="number">0</span>;</div><div class="line">pItemList[<span class="number">0</span>].llTimelineOut = pItemList[<span class="number">0</span>].llMediaOut;</div><div class="line">pItemList[<span class="number">0</span>].bstrFileName = strPath;</div><div class="line">pItemList[<span class="number">0</span>].dwFileFormatID = info2.FileFormatID();</div><div class="line">pItemList[<span class="number">0</span>].dwMediaTypeID = info2.AudioInfo(<span class="number">0</span>).nMediaID;</div><div class="line">pItemList[<span class="number">0</span>].dwItemType = SBT_CUTLIST_ITEM_AUDIO;</div><div class="line">pItemList[<span class="number">0</span>].dwReserved1 = pItemList[<span class="number">0</span>].dwReserved2 = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">//////////////////函数执行</span></div><div class="line"><span class="comment">//////////////////设置参数</span></div><div class="line">wavewrite.Initialize();</div><div class="line">wavewrite.SetOutputFile(<span class="number">_</span>T(<span class="string">"D:\\qqw.wav"</span>));</div><div class="line">wavewrite.SetInputWAVEFormat(&amp;outhead);</div><div class="line">wavewrite.SetOutputWAVEFormat(&amp;outhead);</div><div class="line">wavewrite.StartWrite();</div><div class="line"></div><div class="line"><span class="comment">//writefilehead(outhead, 22, writewave);</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> rd = m_pSbCutList-&gt;Initialize(SBT_CUTLIST_ITEM_AUDIO);</div><div class="line">rd = m_pSbCutList-&gt;SetBufferingMode(TRUE);</div><div class="line">rd = m_pSbCutList-&gt;SetBufferPoolSize(<span class="number">25</span>, <span class="number">100</span>);</div><div class="line">rd = m_pSbCutList-&gt;SetFPS(<span class="number">0L</span>);</div><div class="line">rd = m_pSbCutList-&gt;SetOutputFormat(SBT_CUTLIST_ITEM_AUDIO, &amp;meditype);</div><div class="line">rd = m_pSbCutList-&gt;SetItemList(pItemList, <span class="number">1</span>);</div><div class="line">rd = m_pSbCutList-&gt;SetStatus(SBT_CUTLIST_STATUS_PLAY);</div><div class="line"></div><div class="line"><span class="comment">/////////////////////获取数据</span></div><div class="line">ST_CUTLISTV2_DECODE_OUT stDecout;</div><div class="line">ST_CUTLISTV2_DECODE_IN stDecIn;</div><div class="line"></div><div class="line">stDecIn.llTimelinePos = <span class="number">0</span>;</div><div class="line">stDecIn.pUserBuffer = <span class="literal">NULL</span>;</div><div class="line">stDecIn.pUserBuffer2 = <span class="literal">NULL</span>;</div><div class="line">stDecIn.nUserBufSize = <span class="number">0</span>;</div><div class="line">stDecIn.nUserBufStride =  <span class="number">0</span>;</div><div class="line">stDecIn.dwMask = <span class="number">0xFFFF</span>;</div><div class="line">stDecIn.dwReserved  = <span class="number">0x00</span>;</div><div class="line">stDecIn.dwParameter  = <span class="number">0x01</span>;</div><div class="line"></div><div class="line">ErrorInfo errinfo;</div><div class="line">ST_CUTLIST_PROCESS_INFO proinfo;</div><div class="line"><span class="keyword">while</span> ((rd = m_pSbCutList-&gt;GetOutputBuffer(&amp;stDecIn, stDecout)) &gt; <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">	rd = m_pSbCutList-&gt;GetCutlistProInfo(proinfo);</div><div class="line">	rd = m_pSbCutList-&gt;GerLastErrorCodeInfo(errinfo);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (proinfo.nDecodedBufferNum == <span class="number">0</span>)</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">if</span> (stDecout.pDestBuffer == <span class="literal">NULL</span>)</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">if</span> (stDecIn.llTimelinePos == nFrameNum)</div><div class="line">		<span class="keyword">break</span>;</div><div class="line"></div><div class="line">	stDecIn.llTimelinePos++;</div><div class="line"></div><div class="line">	allsize += stDecout.nActualDataSize;</div><div class="line">	wavewrite.SetInputBuffer(stDecout.pDestBuffer, stDecout.nActualDataSize);</div><div class="line">	<span class="comment">//fwrite(stDecout.pDestBuffer, stDecout.nActualDataSize, 1, writewave);</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">wavewrite.StopWrite();</div><div class="line">fseek(writewave, <span class="number">40</span>, SEEK_SET);</div><div class="line">fwrite(&amp;allsize, <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), writewave);</div><div class="line">allsize += <span class="number">36</span>;</div><div class="line">fseek(writewave, <span class="number">4</span>, SEEK_SET);</div><div class="line">fwrite(&amp;allsize, <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), writewave);</div><div class="line">fclose(writewave);</div><div class="line"></div><div class="line"><span class="keyword">delete</span> meditype.pbFormat;</div><div class="line"><span class="comment">//delete pItemList;</span></div><div class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////</span></div><div class="line"></div></pre></td></tr></table></figure><p></p>
</h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo新博客搭建177]]></title>
      <url>https://xuecat.github.io/2016/08/29/177/</url>
      <content type="html"><![CDATA[<h1 id="搭建坑"><a href="#搭建坑" class="headerlink" title="搭建坑"></a>搭建坑</h1><p><strong><em>1. favior坑</em></strong><br>和配置文件里面说的不一样，必须要给个路径，不然简直呵呵。</p>
<p><strong><em>2. about页面坑</em></strong><br>我想用photos对about页面进行修饰，我去。NexT对所有属性页面都处理了不支持photos；<br><br>气死人。只有两种方式：<br>1、改布局，头上写layout:post；</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">layout: post</div><div class="line">title: 关于</div><div class="line"><span class="keyword">tags:</span> </div><div class="line">comment: false</div><div class="line">photos:</div><div class="line">- /picture/a.jpg</div><div class="line">- /picture/r.jpg</div></pre></td></tr></table></figure>
<p>2、加本地图片<code>&lt;img&gt;</code>属性，但是有个坑就是无法水平布局</p>
<p>3、用gp属性，见7</p>
<p><strong><em>3. 最强之坑</em></strong><br>url问题，对于几个menu的访问，我一直访问不到。<br><br>一直以为是其他问题(本来该访问<code>https:\\</code>的，它直接访问了站点，所以找不到网页) <br><br>搞了一天，我了个去！！。最后发现长城这坑货做了访问缓存的。。。。。。。。<br><br>它对国外所有站都做了缓存，，，也就是说发现要耗资源，要么从以前的post取一个随便发，要么用以前的页面来展示。</p>
<p><strong><em>4. 代码高亮坑</em></strong><br>普通makedown的tab识别有问题，只能加上标注了<br></p>
<pre><code>{% codeblock [title] [lang:language] [url] [link text] %}  
    code snippet  
    {% endcodeblock %}
</code></pre><p>另外终于发现了，可以用  三个` 来表示如：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  ```c</span></div><div class="line"><span class="comment">//  此处放入代码，这就表示用c语言代码高亮</span></div><div class="line"><span class="comment">//</span></div></pre></td></tr></table></figure></p>
<p>```</p>
<p><strong><em>5. swiftype坑</em></strong><br>我想把按钮改成编辑框，晕了没法,还好有好人写的博客 <a href="http://www.wuxubj.cn/2016/05/Hexo-build-personal-blog-advance/#%E6%B7%BB%E5%8A%A0swiftype%E6%90%9C%E7%B4%A2%E5%B9%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E6%90%9C%E7%B4%A2%E6%A1%86" target="_blank" rel="external">http://www.wuxubj.cn/2016/05/Hexo-build-personal-blog-advance/#%E6%B7%BB%E5%8A%A0swiftype%E6%90%9C%E7%B4%A2%E5%B9%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E6%90%9C%E7%B4%A2%E6%A1%86</a><br><br>居然没法用<a href="https://github.com/iissnan/hexo-theme-next/pull/721/files" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next/pull/721/files</a></p>
<p><strong><em>6. 加载缓慢</em></strong><br>这个坑也是害我不浅，最后没法去<code>layout\_partials\head</code>里面把最后一块关于font_families删除了，才好点。<br><br>坏处就是，字体不好看了。</p>
<p><strong><em>7. 多图模式坑</em></strong></p>
<ol>
<li><p>多图模式下：</p>
<p> ‘% gp 5-3 %’ //这句里，图片数必须超过2，不然就显示错误。就算只有俩个图源，也没关系，可以正常显示。</p>
</li>
<li><p>正文图片显示布局永远是竖直布局，只有在<code>归档</code>里的缩略里才按照正常布局显示。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[sobey音频视频(176)]]></title>
      <url>https://xuecat.github.io/2016/08/27/176/</url>
      <content type="html"><![CDATA[<h4 id="WAV文件解析："><a href="#WAV文件解析：" class="headerlink" title="WAV文件解析："></a>WAV文件解析：<br></h4><p>wBitsPerSample 样本位深（每次采样样本大小，bit单位）<br><br>nBlockAlig 字节单位设置块对齐。即最小数据的原子大小。当为pcm时 此值为（nchaaneels<em>wbitspersample）/8可以看出这是以byte为单位<br>所以码率就是字节块</em>采样率</p>
<p>AMFS中对音频的放置是按帧放置平面pcm数据的。且帧数也是参照视频P、N制来的。<br>也就是说，每帧大小就是码率/视频帧数     P制25帧、N制29.5帧</p>
<p><strong>链接：</strong> <a href="http://blog.sina.com.cn/s/blog_68fea30801017fzx.html" target="_blank" rel="external">音频码率和采样率解析</a><br><strong>链接：</strong> <a href="http://infiniteccq.blog.163.com/blog/static/208214034201301743627217/" target="_blank" rel="external">wave代码头解析</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[STL算法函数(175)]]></title>
      <url>https://xuecat.github.io/2016/08/20/175/</url>
      <content type="html"><![CDATA[<h4 id="算法记录"><a href="#算法记录" class="headerlink" title="算法记录"></a>算法记录</h4><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><table>
<thead>
<tr>
<th>算法名</th>
<th style="text-align:center">算法用途</th>
<th style="text-align:center">算法名</th>
<th style="text-align:center">算法用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#accumulate">accumulate</a></td>
<td style="text-align:center">元素累计</td>
<td style="text-align:center"><a href="#fill">fill</a></td>
<td style="text-align:center">改填元素值</td>
</tr>
<tr>
<td><a href="#adjacent_find">adjacent_find</a></td>
<td style="text-align:center">查找相邻而重复的元素</td>
<td style="text-align:center"><a href="#fill_n">fill_n</a></td>
<td style="text-align:center">改填元素值，n次</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"></td>
<td style="text-align:center"><a href="#find">find</a></td>
<td style="text-align:center">循序查找</td>
</tr>
<tr>
<td><a href="#binary_search">binary_search</a></td>
<td style="text-align:center">二分查找</td>
<td style="text-align:center"><a href="#find_if">find_if</a></td>
<td style="text-align:center">循序查找符合特定条件者</td>
</tr>
<tr>
<td><a href="#copy">copy</a></td>
<td style="text-align:center">复制</td>
<td style="text-align:center"><a href="#find_end">find_end</a></td>
<td style="text-align:center">查找某个子序列最后一次出现点</td>
</tr>
<tr>
<td><a href="#copy_backward">copy_backward</a></td>
<td style="text-align:center">逆向复制</td>
<td style="text-align:center"><a href="#find_first_of">find_first_of</a></td>
<td style="text-align:center">查找某些元素的首次出现点</td>
</tr>
<tr>
<td><a href="#copy_n">copy_n</a></td>
<td style="text-align:center">复制n个元素</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="#count">count</a></td>
<td style="text-align:center">计数</td>
<td style="text-align:center"><a href="#for_each">for_each</a></td>
<td style="text-align:center">代码见</td>
</tr>
<tr>
<td><a href="#count_if">count_if</a></td>
<td style="text-align:center">特定条件下计数</td>
<td style="text-align:center"><a href="#generate">generate</a></td>
<td style="text-align:center">以特定操作之运算结果填充特定区间内的元素</td>
</tr>
<tr>
<td><a href="#equal">equal</a></td>
<td style="text-align:center">判断两个区间相等与否</td>
<td style="text-align:center"><a href="#generate_n">generate_n</a></td>
<td style="text-align:center">同上，多个n个元素内容</td>
</tr>
<tr>
<td><a href="#equal_range">equal_range</a></td>
<td style="text-align:center">在有序区间中寻找某值</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="#includes">includes</a></td>
<td style="text-align:center">是否涵盖于某序列中</td>
<td style="text-align:center"><a href="#max_element">max_element</a></td>
<td style="text-align:center">最大值所在位置</td>
</tr>
<tr>
<td><a href="#inplace_merge">inplace_merge</a></td>
<td style="text-align:center">合并并就地替换上去</td>
<td style="text-align:center"><a href="#merge">merge</a></td>
<td style="text-align:center">合并俩个序列</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="#is_sorted">is_sorted</a></td>
<td style="text-align:center">判断区间是否已排序</td>
<td style="text-align:center"><a href="#min_element">min_element</a></td>
<td style="text-align:center">同理</td>
</tr>
<tr>
<td><a href="#iter_swap">iter_swap</a></td>
<td style="text-align:center">元素互换</td>
<td style="text-align:center"><a href="#mismatch">mismatch</a></td>
<td style="text-align:center">找出不匹配点</td>
</tr>
<tr>
<td><a href="#lower_bound">lower_bound</a></td>
<td style="text-align:center">将指定元素插入区间之内<br>而不影响区间之原本排序的最低位置</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="#partial_sort">partial_sort</a></td>
<td style="text-align:center">局部排序</td>
<td style="text-align:center"><a href="#partition">partition</a></td>
<td style="text-align:center">分割</td>
</tr>
<tr>
<td><a href="#partial_sort_copy">partial_sort_copy</a></td>
<td style="text-align:center">局部排序并复制到他处</td>
<td style="text-align:center"><a href="#power">power</a></td>
<td style="text-align:center">幂次方</td>
</tr>
<tr>
<td><a href="#partial_sum">partial_sum</a></td>
<td style="text-align:center">局部求和</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="#remove">remove</a></td>
<td style="text-align:center">删除（假的）</td>
<td style="text-align:center"><a href="#replace">replace</a></td>
<td style="text-align:center">替换某类元素</td>
</tr>
<tr>
<td><a href="#remove_copy">remove_copy</a></td>
<td style="text-align:center">删除某类元素并将结果复制到另一个容器</td>
<td style="text-align:center"><a href="#replace_copy">replace_copy</a></td>
<td style="text-align:center">替换某类元素将结果复制到另一个容器</td>
</tr>
<tr>
<td><a href="#remove_if">remove_if</a></td>
<td style="text-align:center">有条件删除（也是假的）</td>
<td style="text-align:center"><a href="#replace_if">replace_if</a></td>
<td style="text-align:center">同</td>
</tr>
<tr>
<td><a href="#remove_copy_if">remove_copy_if</a></td>
<td style="text-align:center">同</td>
<td style="text-align:center"><a href="#replace_copy_if">replace_copy_if</a></td>
<td style="text-align:center">同</td>
</tr>
<tr>
<td><a href="#reverse">reverse</a></td>
<td style="text-align:center">反转元素次序</td>
<td style="text-align:center"><a href="#swap">swap</a></td>
<td style="text-align:center">置换</td>
</tr>
<tr>
<td><a href="#reverse_copy">reverse_copy</a></td>
<td style="text-align:center">同</td>
<td style="text-align:center"><a href="#transform">transform</a></td>
<td style="text-align:center">一俩序列为基础，交互作用产生第三个序列</td>
</tr>
<tr>
<td><a href="#sort">sort</a></td>
<td style="text-align:center">排序</td>
<td style="text-align:center"><a href="#unique">unique</a></td>
<td style="text-align:center">将重复的元素折叠缩编，使成唯一</td>
</tr>
<tr>
<td><a href="#rotate">rotate</a></td>
<td style="text-align:center">从middle俩端分开，进行交换</td>
<td style="text-align:center"><a href="#rotate_copy">rotate_copy</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="#search">search</a></td>
<td style="text-align:center">从序列一中寻找序列二首次出现点</td>
<td style="text-align:center"><a href="#search_n">search_n</a></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="#swap_ranges">swap_ranges</a></td>
<td style="text-align:center">区间互换</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="#next_permutation">next_permutation</a></td>
<td style="text-align:center">下一个排序序列</td>
<td style="text-align:center"><a href="#prev_permutation">prev_permutation</a></td>
<td style="text-align:center">上一个排序序列</td>
</tr>
<tr>
<td><a href="#random_shuffle">random_shuffle</a></td>
<td style="text-align:center">将区间元素次序随机重排</td>
<td style="text-align:center"><a href="#nth_element">nth_element</a></td>
<td style="text-align:center">以middle为中线，op返回false放middle右边，true放左边,比sort快</td>
</tr>
<tr>
<td><a href="#front_inserter">front_inserter</a></td>
<td style="text-align:center">头插入(迭代器必须支持push_front (“vector无”))</td>
<td style="text-align:center"><a href="#back_inserter">back_inserter</a></td>
<td style="text-align:center">尾插入（迭代器必须支持push_back）</td>
</tr>
<tr>
<td><a href="#inserter">inserter</a></td>
<td style="text-align:center">指定位置插入（迭代器必须支持insert）</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="xfunctional文件里面实现了为大多数的一般算法提供的仿函数"><a href="#xfunctional文件里面实现了为大多数的一般算法提供的仿函数" class="headerlink" title="xfunctional文件里面实现了为大多数的一般算法提供的仿函数"></a>xfunctional文件里面实现了为大多数的一般算法提供的仿函数</h4><hr>
<p></p><h2 id="accumulate"> accumulate <h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">std</span>::accumulate(iv.begin(), iv.end(), da, plus&lt;<span class="keyword">int</span>&gt;()) == <span class="built_in">std</span>::accumulate(iv.begin(), iv.end(), da);</div><div class="line"><span class="keyword">return</span>值为da + <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span>;</div><div class="line"><span class="built_in">std</span>::accumulate(iv.begin(), iv.end(), da, minus&lt;<span class="keyword">int</span>&gt;());</div><div class="line"><span class="keyword">return</span>值为da - <span class="number">1</span> - <span class="number">2</span> - <span class="number">3</span> - <span class="number">4</span> - <span class="number">5</span>;&lt;br/&gt;&lt;</div><div class="line"><span class="comment">//把da作为第一个左值，一个一个获取右值。运算后再返回为下一个左值</span></div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="equal"> equal <h2><p></p>
<blockquote>
<p>判断之前最好先比较元素个数是否相等。<br>判断原作就是 if (<em>first1 != </em>first2) return false;</p>
</blockquote>
<hr>
<p></p><h2 id="fill"> fill <h2><p></p>
<p></p><h2 id="fill_n"> fill_n <h2><p></p>
<blockquote>
<p>这俩个真没啥说的。</p>
</blockquote>
<hr>
<p></p><h2 id="iter_swap"> iter_swap <h2><p></p>
<blockquote>
<p>这个调用要重写 operator= 函数</p>
</blockquote>
<hr>
<p></p><h2 id="mismatch"> mismatch <h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">while</span>(first1 != last1 &amp;&amp; *first1 == *first2) &#123; ++first1; ++first2; &#125;</div><div class="line"><span class="keyword">return</span> pair&lt;InputIterator1, InputIterator2&gt;&lt;first1, first2&gt;;</div><div class="line">返回值很有意思可以探究</div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="copy"> copy <h2><p></p>
<p></p><h2 id="copy_backward"> copy_backward <h2><p></p>
<blockquote>
<p>后者是逆向复制。<br><br>copy是允许覆盖的即copy(p.begin(), p.end() - 1, p.begin() + 1);这种形式。<br>但是有注意点：</p>
<blockquote>
<p>1、对第三个参数是没有边界判断的，如果小了，会崩溃。<br>2、对deque无效，会全部变成第一参数的值；只vector才行。 (具体原因没细究)</p>
</blockquote>
</blockquote>
<hr>
<h1 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h1><p><strong>这些函数有set，表面看上去像给set用的，然而不止这么简单。只要有序，就都可以<br><br>s1由于只是访问，可以set、vector等；s2同；<br><br>s3由于需要被赋值，vector等可以，但set是不行的。s3还有个限制，如果没有resize的空间，赋值会错误。</strong></p>
<p></p><h2 id="set_union"> set_union </h2><p></p>
<blockquote>
<p>它是set的操作<br>合并俩个set为一个set，第三个set依旧需要给与足够空间，不然也会运行错误。</p>
</blockquote>
<hr>
<p></p><h2 id="set_intersection"> set_intersection </h2><p></p>
<blockquote>
<p>它是set的操作<br>它求俩个set的交集，第三个set依旧需要给与足够空间，不然也会运行错误。</p>
</blockquote>
<hr>
<p></p><h2 id="set_difference"> set_difference </h2><p></p>
<blockquote>
<p>它是set的操作<br>它是求两个set的不同，出现于s1但不出现于s2的元素，赋值到s3。s3依旧需要空间。</p>
</blockquote>
<hr>
<p></p><h2 id="adjacent_find"> adjacent_find </h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">cout</span> &lt;&lt; *adjacent_find(iv.begin(), iv.end());<span class="comment">//这个默认是找iv中相邻元素值相等的第一个元素</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; *adjacent_find(iv.begin(), iv.end(), equal_to&lt;<span class="keyword">int</span>&gt;());<span class="comment">//第三个是自定义，比较函数，会把相邻元素传入，自己函数比较返回bool</span></div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="count"> count </h2><p></p>
<p></p><h2 id="count_if"> count_if </h2><p></p>
<ol>
<li>依旧使用的是 if (*first == value),operator ==</li>
<li>count_if第三个参数是函数，也就循环传入元素进函数，自己判断bool，函数再++</li>
<li><code>bind2nd(less&lt;int&gt;(), 7)</code>， <code>bind2nd(greater&lt;int&gt;(), 2)</code></li>
</ol>
<hr>
<p></p><h2 id="find"> find </h2><p></p>
<p></p><h2 id="find_if"> find_if </h2><p></p>
<p></p><h2 id="find_end"> find_end </h2><p></p>
<p></p><h2 id="find_first_of"> find_first_of </h2><p></p>
<ol>
<li>not1(bind2nd(modulus<int>(),3))。//<code>vector_finder(13,1003)</code>，类型要有有构造函数和bool operator ()( value_type &amp;value)就好</int></li>
<li>find_end查找first1到last1中最后一次出现first2到last2区间的元素，返回first2在first1区间中最后一次出现元素。</li>
<li>find_end支持自定义仿函数如<code>equal_to&lt;int&gt; ()</code></li>
<li>find_first_of则相反</li>
</ol>
<hr>
<p></p><h2 id="generate"> generate </h2><p></p>
<p></p><h2 id="generate_n"> generate_n </h2><p></p>
<ol>
<li>将仿函数运算结果填写在first到last中，仿函数是无参数传入</li>
</ol>
<hr>
<p></p><h2 id="max_element"> max_element </h2><br>返回区间中的最大值<p></p>
<hr>
<p></p><h2 id="min_element"> min_element </h2><br>返回区间中的最小值<p></p>
<hr>
<p></p><h2 id="merge"> merge </h2><p></p>
<ol>
<li>将两个有序集合，合并放入另一段空间</li>
<li>第5个参数result作为放入空间，必须resize足够大</li>
<li>支持第6个参数，自定义比较函数来排序摆放</li>
</ol>
<hr>
<p></p><h2 id="partition"> partition </h2><p></p>
<ol>
<li>所有被第三个参数pred判断为true元素会被放在区间的前段，被判断为false的元素会被仿在后段。</li>
<li>没有排序功能，无返回</li>
</ol>
<hr>
<p></p><h2 id="remove"> remove </h2><p></p>
<p></p><h2 id="remove_if"> remove_if </h2><p></p>
<p></p><h2 id="remove_copy"> remove_copy </h2><p></p>
<p></p><h2 id="remove_copy_if"> remove_copy_if </h2><p></p>
<ol>
<li>remove老特性，不说了，remove调用的是remove_copy,它只管赋值到新目标，不管保护数据</li>
<li>remove_copy如果不等第四个参数，就赋值给第三个参数。所以第三个参数要保证能++,能有足够多的空间去容纳</li>
<li>remove_if调用的是<code>remove_copy_if</code>,把前面的value值全替换成了pred仿函数</li>
</ol>
<hr>
<p></p><h2 id="replace"> replace </h2><p></p>
<p></p><h2 id="replace_copy"> replace_copy </h2><p></p>
<p></p><h2 id="replace_if"> replace_if </h2><p></p>
<p></p><h2 id="replace_copy_if"> replace_copy_if </h2><p></p>
<ol>
<li>replace 从区间中寻找第三个参数，用第四个参数替换了。</li>
<li>replace_copy 与上相比多个把寻找结果放入result中</li>
<li>replace_if 自定义仿函数</li>
<li>需要resize</li>
</ol>
<hr>
<p></p><h2 id="reverse"> reverse </h2><p></p>
<p></p><h2 id="reverse_copy"> reverse_copy </h2><p></p>
<ol>
<li>颠倒重排</li>
<li>新序列结果放入result，同样需要resize</li>
</ol>
<hr>
<p></p><h2 id="rotate"> reverse </h2><p></p>
<p></p><h2 id="rotate_copy"> reverse_copy </h2><p></p>
<ol>
<li>[first, middle), [middle, last)，对这俩个数组进行互换。</li>
</ol>
<hr>
<p></p><h2 id="search"> search </h2><p></p>
<p></p><h2 id="search_n"> search_n </h2><p></p>
<ol>
<li>如果未找到要返回，last1</li>
<li>search_n查找连续n个符合条件的元素(他只能找元素不能找区间)，如果找不到就返回last1</li>
</ol>
<hr>
<p></p><h2 id="swap_ranges"> swap_ranges </h2><br>将[first1, last1)区间内的元素与”从first2开始、个数相同”的元素互换。这两个序列可位于同一容器中，也可位于不同容器（长度不好说）<p></p>
<hr>
<p></p><h2 id="transform"> transform </h2><p></p>
<ol>
<li>第一个版本，把first到last区间执行op，结果放入result;返回result最后被赋值元素（result需要resize）</li>
<li>第二个版本，把俩个区间执行op（op，第一个参数是f1区间里的，第二个参数f2区间的），放入result里</li>
</ol>
<hr>
<p></p><h2 id="unique"> unique </h2><p></p>
<ol>
<li>移除重复的元素</li>
<li>它只能移除相邻元素的重复元素，所以要想移除所有的，必须先排序。</li>
</ol>
<hr>
<p></p><h2 id="lower_bound"> lower_bound </h2><p></p>
<ol>
<li>试图在已排序的[first, last)中找value</li>
<li>如果有就返回第一个指向元素，如果没有便返回指向第一个“不小于value”的元素<br>这就意味着总是要返回值的。</li>
</ol>
<hr>
<p></p><h2 id="upper_bound"> upper_bound </h2><p></p>
<ol>
<li>返回可插入value的最后一个合适位置<br>也就是说，如果value存在，返回的是指向value的下一个位置，而不是value。不存在则和上同理。</li>
</ol>
<hr>
<p></p><h2 id="binary_search"> binary_search </h2><p></p>
<ol>
<li>这个函数本质是调用<code>lower_bound</code>,但是它返回的是true和false，</li>
<li>第二个版本，允许自己指定comp比较函数。</li>
</ol>
<hr>
<p></p><h2 id="next_permutation"> next_permutation </h2><p></p>
<p></p><h2 id="prev_permutation"> prev_permutation </h2><p></p>
<ol>
<li>获取下一个排序序列。</li>
<li>允许op自定义函数，官方解释说：返回的值表示第一个参数是否被认为是在特定的严格弱排序它定义的第二个之前</li>
</ol>
<hr>
<p></p><h2 id="partial_sort"> partial_sort </h2><p></p>
<p></p><h2 id="partial_sort_copy"> partial_sort_copy </h2><p></p>
<ol>
<li>从first到last找middle-first个最小元素，进行排序(默认递增<code>less&lt;int&gt;()</code> 可用<code>greater&lt;int&gt;()</code>等自定义)。</li>
<li>只能保证[first, middle)是递增排序，不能保证[middle, last)是排序序列</li>
<li>当用sort对整个排序，再取前middle-first; 能达到同等效果，但是效率没有此函数高。</li>
<li>允许自定义比较函数</li>
<li><code>partial_sort_copy</code>复制到result.begin(),result.end();</li>
</ol>
<hr>
<p></p><h2 id="equal_range"> equal_range </h2><p></p>
<ol>
<li><code>lower_bound</code>和<code>upper_bound</code>的结合，返回一个pair，pair记录的就是前俩函数的结果</li>
</ol>
<hr>
<p></p><h2 id="front_inserter"> front_inserter </h2><p></p>
<p></p><h2 id="back_inserter"> back_inserter </h2><p></p>
<p></p><h2 id="inserter"> inserter </h2><p></p>
<ol>
<li>正如标题所说的那样，如果相关迭代器没有对应的函数，执行会错误。</li>
<li>如果单独使用 <code>std::back_inserter(numbers) = 6;</code> <code>std::inserter(numbers, numbers.begin()+1) = 6</code>这样，numbers的size会增加，并且最后的值被赋值为6</li>
<li>一般无单独使用，多是配合copy; <code>copy(ia, ia + 3, back_inserter(id))</code>这样id后面就插入了ia到ia+3的数据</li>
</ol>
</h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Placement new(174)]]></title>
      <url>https://xuecat.github.io/2016/08/16/174/</url>
      <content type="html"><![CDATA[<h1 id="Placement-new"><a href="#Placement-new" class="headerlink" title="Placement new"></a>Placement new</h1><figure class="highlight c"><figcaption><span>先看一段代码：++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="number">_</span>construct(T1* p,<span class="keyword">const</span> T2&amp; value)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">new</span>(p) T1(value);</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> <span class="number">_</span>tmain(<span class="keyword">int</span> argc, <span class="number">_</span>TCHAR* argv[])</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="number">_</span>construct(&amp;p, <span class="number">3</span>);</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;p &lt;&lt; <span class="built_in">endl</span> &lt;&lt; &amp;t &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    system(<span class="string">"pause"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//神奇的new的用法</span></div><div class="line"><span class="comment">//居然对p进行返回了</span></div><div class="line"><span class="comment">//这个使用的就是Placement new</span></div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><h2 id="先回顾下知识"><a href="#先回顾下知识" class="headerlink" title="先回顾下知识 "></a>先回顾下知识 <br></h2><p>new和delete操作符我们应该都用过，它们是对堆中的内存进行申请和释放，而这两个都是不能被重载的。<br>要实现不同的内存分配行为，需要重载operator new和operator delete，而不是new和delete。<br>operator new就像operator+一样，是可以重载的。<br>但是不能在全局对原型为void operator new(size_t size)这个原型进行重载，一般只能在类中进行重载。<br>如果类中没有重载operator new，那么调用的就是全局的::operator new来完成堆的分配。<br><br>同理，operator new[]、operator delete、operator delete[]也是可以重载的。</p>
</li>
<li><h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解 "></a>讲解 <br></h2></li>
<li>placement new，只是operator new的一个重载的版本</li>
<li>placement new允许你在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。<br>原型中void*p实际上就是指向一个已经分配好的内存缓冲区的的首地址。</li>
<li>placement new非常适合那些对时间要求比较高，长时间运行不希望被打断的应用程序(因为没有new去查询空间内存了，直接提前预定义好了)</li>
</ul>
</blockquote>
<ol>
<li>缓冲区提前分配，可以使用堆的空间，也可以使用栈的空间。所以分配方式有如下两种：</li>
</ol>
<p>class MyClass {…};<br>char <em>buf=new char[N</em>sizeof(MyClass)+sizeof(int)];<br>char buf[N*sizeof(MyClass)+sizeof(int)];</p>
<ol>
<li><p>对象的构造<br>MyClass * pClass=new(buf) MyClass; //new(buf) MyClass(int) 这里还可以这样用，给个传递值</p>
</li>
<li><p>对象的销毁<br> 一旦这个对象使用完毕，你必须显式的调用类的析构函数进行销毁对象。但此时内存空间不会被释放，以便其他的对象的构造。<br>pClass-&gt;~MyClass();</p>
</li>
<li><p>内存的释放<br> 如果缓冲区在堆中，那么调用delete[] buf 进行内存的释放。如果在栈中，那么在其作用域内有效，跳出作用域，内存自动释放。</p>
</li>
</ol>
<figure class="highlight c"><figcaption><span>先看一段代码：++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="number">_</span>construct(T1* p,<span class="keyword">const</span> T2&amp; value)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">new</span>(p) T1(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</div><div class="line"><span class="keyword">inline</span> T1* <span class="number">_</span>constructs(T1* p,<span class="keyword">const</span> T2&amp; value)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span>(p) T1[<span class="number">3</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> MemT &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> m_a;</div><div class="line"></div><div class="line">    MemT(<span class="keyword">size_t</span> a) &#123; m_a = a; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;&#125;</div><div class="line">    ~MemT() &#123;&#125;</div><div class="line">    <span class="keyword">void</span> * (<span class="keyword">operator</span> <span class="keyword">new</span>) (<span class="keyword">size_t</span> t, <span class="keyword">void</span> *location)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> location;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="number">_</span>tmain(<span class="keyword">int</span> argc, <span class="number">_</span>TCHAR* argv[])</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> d[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    MemT* da = <span class="keyword">new</span> (&amp;p) MemT(<span class="number">2</span>);<span class="comment">//先走操作符，再走构造 别忘了析构</span></div><div class="line"></div><div class="line">    <span class="number">_</span>construct(&amp;p, <span class="number">3</span>);</div><div class="line">    <span class="number">_</span>constructs(&amp;d, <span class="number">2</span>);</div><div class="line"></div><div class="line">    system(<span class="string">"pause"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//类的那块，本来就没啥代码，最多给个分配内存的判断和内存的再开辟吧。</span></div><div class="line"><span class="comment">//数组那块_constructs，有个遗憾，无法像第一个那样给参数进去。</span></div><div class="line"><span class="comment">//能用的场景：1、基本数据配子（给基类数据都开辟大小，通过这个来构造析构）也就STL敢用！</span></div><div class="line"><span class="comment">//2、节约内存，对已经使用了的内存，再次使用。感觉并无多大用</span></div><div class="line"></div></pre></td></tr></table></figure>
<p>原作：<br><a href="http://www.cnblogs.com/younes/archive/2010/04/26/1721528.html" target="_blank" rel="external">http://www.cnblogs.com/younes/archive/2010/04/26/1721528.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[STL源码剖析(172)]]></title>
      <url>https://xuecat.github.io/2016/08/10/172/</url>
      <content type="html"><![CDATA[<blockquote>
<p>最近被git上一个项目打击了；想想自己c++书籍都看了十多本了，以为可以睥睨了。唉！！虽然公司编程不允许模板，但是身为程序员还是有学的必要。这本书一定要看完。</p>
<hr>
<h4 id="1、STL版本众多"><a href="#1、STL版本众多" class="headerlink" title="1、STL版本众多"></a>1、STL版本众多</h4><p>stl版本众多，但是有些头文件有很大一长串的版权注释（以前在codeproject也发现的）。这些都是参照HP版本的。允许任何人免费使用、拷贝、修改、传播、贩卖这份文件，唯一需要遵守的是必须在所有文件加上HP版本声明。<strong>哈哈看来国外人也喜欢装逼，都希望往自己开源代码放版权声明。</strong></p>
</blockquote>
<h4 id="2、模板中的静态变量"><a href="#2、模板中的静态变量" class="headerlink" title="2、模板中的静态变量"></a>2、模板中的静态变量</h4><pre><code>template &lt;typename T&gt;
class testclass P{
    public:
        static int _data;
};
int testclass&lt;int&gt;::_data = 1;
int testclass&lt;char&gt;::_data = 2;

testclass&lt;int&gt; ob1;//ob1._data 1
testclass&lt;char&gt; ob2;//ob2._data 2
//我想,我如果我再用一层typedef来换容的话。这代码就好看多了！
</code></pre><h4 id="3、模板中的特殊设计"><a href="#3、模板中的特殊设计" class="headerlink" title="3、模板中的特殊设计"></a>3、模板中的特殊设计</h4><pre><code>template &lt;class i, class o&gt;
struct dd {};//由于是模板，可以运行任何类型，要判断指针，可以用ispont的std函数

template &lt;class T&gt;
struct dd &lt;T*, T*&gt; {};

template &lt;class T&gt;
struct dd &lt;const T*, T*&gt; {};
</code></pre><h4 id="4、模板类型可赋值"><a href="#4、模板类型可赋值" class="headerlink" title="4、模板类型可赋值"></a>4、模板类型可赋值</h4><pre><code>template&lt;class T, class R, size_t Bufsize = 0&gt;
struct deq{}
    deq() {cout &lt;&lt;ｂufsize;};
;
</code></pre><h4 id="5、模板操作函数"><a href="#5、模板操作函数" class="headerlink" title="5、模板操作函数"></a>5、模板操作函数</h4><pre><code>bool operator== &lt;&gt; (const stack&amp;, const stack&amp;);
</code></pre><h4 id="6、构造函数特例化"><a href="#6、构造函数特例化" class="headerlink" title="6、构造函数特例化"></a>6、构造函数特例化</h4><pre><code>template &lt;class key&gt; struct hash {
    void operator()() {cout &lt;&lt;＂ｈｅｈｅ＂ &lt;&lt; endl;}
};
template &lt;&gt; struct hash&lt;char&gt; {
    void operator()() {cout &lt;&lt;＂ｉｓ　ｃｈａｒ＂ &lt;&lt; endl;}
}
hash&lt;long&gt; t;//hehe
hash&lt;char&gt; d;//is char
</code></pre><h4 id="7、迭代器"><a href="#7、迭代器" class="headerlink" title="7、迭代器"></a>7、迭代器</h4><ul>
<li>vector就不讲了。<ul>
<li>template <class t="" ,="" class="" alloc="alloc"> <br>class vector {…};</class></li>
</ul>
</li>
<li>list环状双向链表<ul>
<li>template <class t,="" class="" alloc="alloc"> <br> class list {…};</class></li>
</ul>
</li>
<li>deque双向开口连续空间，可头尾操作。内存结构：元素是指针，指向一个更大的连续空间map，数据就放在map中。通过参数赋值来定义map大小。<ul>
<li>template<class t,="" class="" alloc="alloc," size_t="" bufsize="0"> <br> class deque{…};</class></li>
</ul>
</li>
<li>stack先进后出，不允许遍历行为（严格不是迭代器）</li>
<li>queue先进先出。</li>
<li>slist单向链表，空间更小，操作更快。</li>
<li>set 它的实值就是键值。自动排序 ,切不允许键值重复现象<ul>
<li>template <class key,="" class="" compare="less<key">, class Alloc = alloc&gt;<br> class set {…};</class></li>
</ul>
</li>
<li>map所有元素会根据元素键值自动排序。不允许键值重复现象<ul>
<li>template <class key,="" class="" t,="" compare="less" <key="">, class Alloc = alloc&gt;<br>class map {…};</class></li>
<li>map<int, int=""> d;<br><br>d.insert(make_pair(2, 3));<br><br>d.insert(map<int, int="">::value_type(2, 3));</int,></int,></li>
</ul>
</li>
<li>multiset、multimap都允许键值重复现象。</li>
</ul>
<h4 id="8、hash"><a href="#8、hash" class="headerlink" title="8、hash"></a>8、hash</h4><h4 id="普及下hash表知识"><a href="#普及下hash表知识" class="headerlink" title="普及下hash表知识"></a>普及下hash表知识</h4><p>迭代器多用于数据的存储，添加，删除，操作等；（而关联器set，map等）大多以红黑树为基础；<br> 但是当对存储数据希望以常数时间来搜寻时，<br>特别是大量的无序数据，使用hash表的时间优势便有了。</p>
<p><br>hash表是通过数组记录的方式来存储，之后又有一次探测、二次探测来对同一位置记录成一链表（具体可以看stl源码）</p>
<h5 id="简单表述"><a href="#简单表述" class="headerlink" title="简单表述"></a>简单表述</h5><p><br>一个a数组有10个元素，这些元素个个是100以内的数。如果要快速记录和查询方式是：开辟一个100大小的b数组，从a数组中遍历，执行b[a[i]]++操作<br><br>这些无论什么操作都在b中执行，统计、查找等。因为b那边是常数级的。b便是hash表<br><br>当对b大小进行限制为50的时候，每个b就必须存俩个记录了，这便是探测算法需要的。</p>
<ul>
<li>hash_set　<ul>
<li>template <class value,="" class="" hashfcn="hash<Value">, class EqualKey = equal_to<value>, class Alloc = alloc&gt;<br><br>class hash_set {…};</value></class></li>
</ul>
</li>
<li>hash_map<ul>
<li>template <class key,="" class="" t,="" hashfcn="hash<Key">, class EqualKey = equal_to<key>, class Alloc = alloc&gt;<br><br>class hash_map {…};</key></class></li>
</ul>
</li>
<li>hash_multiset<ul>
<li>template <class value,="" class="" hashfcn="hash<Value">, class EqualKey = equal_to<key>, class Alloc = alloc&gt;<br><br>class hash_multiset {…};</key></class></li>
</ul>
</li>
<li>hash_multimap<ul>
<li>template <class key,="" class="" hashfcn="hash<Key">, class EqualKey = equal_to<key>, class Alloc = alloc&gt;<br><br>class hash_multimap {…};</key></class></li>
</ul>
</li>
</ul>
<h4 id="9、组合序列"><a href="#9、组合序列" class="headerlink" title="9、组合序列"></a>9、组合序列</h4><p>vector分别push: {a, b, c}; 那“abc”就是它的组合序列<br><br>当根据less-than(<code>less&lt;T&gt;()</code>)的字典排序后，它的下一序列便是：acb、bac、bca<br>如175的next<code>_permutation和prev_permutation</code>；</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[STL函数学习(173)]]></title>
      <url>https://xuecat.github.io/2016/08/10/173/</url>
      <content type="html"><![CDATA[<h2 id="更多函数讲解在175，这里只放置大众，让人注意的函数。"><a href="#更多函数讲解在175，这里只放置大众，让人注意的函数。" class="headerlink" title="更多函数讲解在175，这里只放置大众，让人注意的函数。"></a>更多函数讲解在175，这里只放置大众，让人注意的函数。</h2><h4 id="std-enable-if"><a href="#std-enable-if" class="headerlink" title="std::enable_if"></a>std::enable_if</h4><p>源代码：</p>
<pre><code>template&lt;class _Ty&gt;
struct enable_if&lt;true, _Ty&gt;
{    // type is _Ty for _Test
typedef _Ty type;
};
</code></pre><p>其实它和static_assert一样，都是为了编译期间检查。常用使用在函数前，表面上给个函数返回值，但之前要进行判断。</p>
<h4 id="std-find"><a href="#std-find" class="headerlink" title="std::find"></a>std::find</h4><p>find第三个参数是value，如果要找自定义的类，只有重载函数</p>
<pre><code>template &lt;typename T&gt;
bool operator !=(const MyClass&lt;T&gt;&amp; item, T n)
{return ;}
</code></pre><h4 id="traits编程法"><a href="#traits编程法" class="headerlink" title="traits编程法"></a>traits编程法</h4><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">	<span class="number">1</span>：<span class="keyword">template</span> &lt;<span class="keyword">class</span> numT&gt;</div><div class="line">   <span class="number">2</span>: <span class="keyword">struct</span> float_traits &#123; &#125;;</div><div class="line">   <span class="number">3</span>:  </div><div class="line">   <span class="number">4</span>: <span class="keyword">struct</span> float_traits&lt;<span class="keyword">float</span>&gt; &#123;</div><div class="line">   <span class="number">5</span>:     <span class="keyword">typedef</span> <span class="keyword">float</span> float_type;</div><div class="line">   <span class="number">6</span>:     <span class="keyword">enum</span> &#123; max_exponent = FLT_MAX_EXP &#125;;</div><div class="line">   <span class="number">7</span>:     <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> float_type <span class="title">epsilon</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> FLT_EPSILON; &#125;</div><div class="line">   <span class="number">8</span>:     ...</div><div class="line">   <span class="number">9</span>: &#125;;</div><div class="line">  <span class="number">10</span>:  </div><div class="line">  <span class="number">11</span>: <span class="keyword">struct</span> float_traits&lt;<span class="keyword">double</span>&gt; &#123;</div><div class="line">  <span class="number">12</span>:     <span class="keyword">typedef</span> <span class="keyword">double</span> float_type;</div><div class="line">  <span class="number">13</span>:     <span class="keyword">enum</span> &#123; max_exponent = DBL_MAX_EXP &#125;;</div><div class="line">  <span class="number">14</span>:     <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> float_type <span class="title">epsilon</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> DBL_EPSILON; &#125;</div><div class="line">  <span class="number">15</span>:     ...</div><div class="line">  <span class="number">16</span>: &#125;;</div><div class="line">现在不管啥类型，模板的使用者都可以无差别使用max_exponent了。比如这儿有个矩阵类模板：</div><div class="line"></div><div class="line">   <span class="number">1</span>: <span class="keyword">template</span> &lt;<span class="keyword">class</span> numT&gt;</div><div class="line">   <span class="number">2</span>: <span class="keyword">class</span> matrix &#123;</div><div class="line">   <span class="number">3</span>:     <span class="keyword">public</span>:</div><div class="line">   <span class="number">4</span>:       <span class="keyword">typedef</span> numT num_type;</div><div class="line">   <span class="number">5</span>:       <span class="keyword">typedef</span> float_traits&lt;num_type&gt; traits_type;</div><div class="line">   <span class="number">6</span>:       <span class="function"><span class="keyword">inline</span> num_type <span class="title">epsilon</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> traits_type::epsilon(); &#125;</div><div class="line">   <span class="number">7</span>:       ...</div><div class="line">   <span class="number">8</span>: &#125;;</div></pre></td></tr></table></figure>
<h4 id="typename"><a href="#typename" class="headerlink" title="typename"></a>typename</h4><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="number">_</span>InputIter, <span class="keyword">class</span> <span class="number">_</span>Tp&gt;</div><div class="line"><span class="keyword">typename</span> iterator_traits&lt;<span class="number">_</span>InputIter&gt;::<span class="function">difference_type</span></div><div class="line"><span class="title">count</span><span class="params">(<span class="number">_</span>InputIter <span class="number">__f</span>irst, <span class="number">_</span>InputIter <span class="number">__l</span>ast, <span class="keyword">const</span> <span class="number">_</span>Tp&amp; <span class="number">__</span>value)</span> &#123;</div><div class="line">  <span class="number">__</span>STL_REQUIRES(<span class="number">_</span>InputIter, <span class="number">_</span>InputIterator);</div><div class="line">  <span class="number">__</span>STL_REQUIRES(<span class="keyword">typename</span> iterator_traits&lt;<span class="number">_</span>InputIter&gt;::value_type,</div><div class="line">                 <span class="number">_</span>EqualityComparable);</div><div class="line">  <span class="number">__</span>STL_REQUIRES(<span class="number">_</span>Tp, <span class="number">_</span>EqualityComparable);</div><div class="line">  <span class="keyword">typename</span> iterator_traits&lt;<span class="number">_</span>InputIter&gt;::difference_type <span class="number">__</span>n = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> ( ; <span class="number">__f</span>irst != <span class="number">__l</span>ast; ++<span class="number">__f</span>irst)</div><div class="line">    <span class="keyword">if</span> (*<span class="number">__f</span>irst == <span class="number">__</span>value)</div><div class="line">      ++<span class="number">__</span>n;</div><div class="line">  <span class="keyword">return</span> <span class="number">__</span>n;</div><div class="line">&#125;</div><div class="line"><span class="comment">//1、用在模板中，来声明是类型</span></div><div class="line"><span class="comment">//2、用在类型声明，表示下面的是个类型。不然typename T::iterator *iter就会被解析为俩数相乘。</span></div><div class="line"></div></pre></td></tr></table></figure>
<h4 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h4><p>这个函数是必须和function一起讲的，但是多个绑定情况就有点特殊，先列出来：</p>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestFunc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> c, <span class="keyword">float</span> f)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">auto</span> bindFunc1 = bind(TestFunc, <span class="built_in">std</span>::placeholders::<span class="number">_1</span>, <span class="string">'A'</span>, <span class="number">100.1</span>);</div><div class="line">    bindFunc1(<span class="number">10</span>);</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"=================================\n"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> bindFunc2 = bind(TestFunc, <span class="built_in">std</span>::placeholders::<span class="number">_2</span>, <span class="built_in">std</span>::placeholders::<span class="number">_1</span>, <span class="number">100.1</span>);</div><div class="line">    bindFunc2(<span class="string">'B'</span>, <span class="number">10</span>);</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"=================================\n"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> bindFunc3 = bind(TestFunc, <span class="built_in">std</span>::placeholders::<span class="number">_2</span>, <span class="built_in">std</span>::placeholders::<span class="number">_1</span>, <span class="built_in">std</span>::placeholders::<span class="number">_3</span>);</div><div class="line">    bindFunc3(<span class="string">'C'</span>, <span class="number">30</span>, <span class="number">100.1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;<span class="comment">//绑定第几个placeholders就按照参数顺序输入第几个。</span></div><div class="line"></div></pre></td></tr></table></figure>
<h4 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h4><p>看到这个函数（表明是函数其实是对象），我只想说叼到没朋友！！！！！！<br><br>代码伺候：</p>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::function&lt; <span class="keyword">int</span>(<span class="keyword">int</span>)&gt; Functional;</div><div class="line"></div><div class="line"><span class="comment">// 普通函数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestFunc</span><span class="params">(<span class="keyword">int</span> a)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Lambda表达式</span></div><div class="line"><span class="keyword">auto</span> lambda = [](<span class="keyword">int</span> a)-&gt;<span class="keyword">int</span>&#123; <span class="keyword">return</span> a; &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 仿函数(functor)</span></div><div class="line"><span class="keyword">class</span> Functor</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 1.类成员函数</span></div><div class="line"><span class="comment">// 2.类静态函数</span></div><div class="line"><span class="keyword">class</span> TestClass</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">VirtualMember</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ClassMember</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">StaticMember</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//多态</span></div><div class="line"><span class="keyword">class</span> DemoClass : <span class="keyword">public</span> TestClass &#123;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">VirtualMember</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 普通函数</span></div><div class="line">    Functional = TestFunc;</div><div class="line">    <span class="keyword">int</span> result = Functional(<span class="number">10</span>);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"普通函数："</span>&lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Lambda表达式</span></div><div class="line">    Functional = lambda;</div><div class="line">    result = Functional(<span class="number">20</span>);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Lambda表达式："</span>&lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 仿函数</span></div><div class="line">    Functor testFunctor;</div><div class="line">    Functional = testFunctor;</div><div class="line">    result = Functional(<span class="number">30</span>);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"仿函数："</span>&lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 类成员函数</span></div><div class="line">    TestClass testObj;</div><div class="line">    Functional = <span class="built_in">std</span>::bind(&amp;TestClass::ClassMember, testObj, <span class="built_in">std</span>::placeholders::<span class="number">_1</span>);</div><div class="line">    result = Functional(<span class="number">40</span>);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"类成员函数："</span>&lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 类静态函数</span></div><div class="line">    Functional = TestClass::StaticMember;</div><div class="line">    result = Functional(<span class="number">50</span>);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"类静态函数："</span>&lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="comment">//多态</span></div><div class="line">	TestClass* p = <span class="keyword">new</span> DemoClass;</div><div class="line">	Functional = <span class="built_in">std</span>::bind(&amp;TestClass::VirtualMember, p, <span class="number">2</span>);</div><div class="line">	<span class="built_in">cout</span> &lt;&lt;Functional(<span class="number">5</span>);<span class="comment">//3</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//又一个灵活用法</span></div><div class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops = </div><div class="line">&#123;</div><div class="line">	&#123; <span class="string">'+'</span>, add &#125;,</div><div class="line">	&#123; <span class="string">'-'</span>, minus&lt;<span class="keyword">int</span>&gt;() &#125;,</div><div class="line">	&#123; <span class="string">'*'</span>, [](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;<span class="keyword">return</span> i - j; &#125; &#125;,</div><div class="line">	&#123; <span class="string">'/'</span>, divide() &#125;,</div><div class="line">	&#123; <span class="string">'%'</span>, mod &#125;,</div><div class="line">&#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; binops[<span class="string">'+'</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; binops[<span class="string">'-'</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; binops[<span class="string">'*'</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; binops[<span class="string">'/'</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; binops[<span class="string">'%'</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div></pre></td></tr></table></figure>
<h4 id="reserve、resize、capacity、size"><a href="#reserve、resize、capacity、size" class="headerlink" title="reserve、resize、capacity、size"></a>reserve、resize、capacity、size</h4><blockquote>
<p>内容就不讲了，一一对应的！！！点下就好，vector和string都是一样的，只增长，2*n。</p>
</blockquote>
<h4 id="unary-function-一元函数，binary-function-二元函数"><a href="#unary-function-一元函数，binary-function-二元函数" class="headerlink" title="unary_function 一元函数，binary_function 二元函数"></a>unary_function 一元函数，binary_function 二元函数</h4><blockquote>
<p>binder2nd和函数适配器是必须要他们的<br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> t&gt;</div><div class="line"><span class="keyword">struct</span> negate : <span class="keyword">public</span> unary_function&lt;t, t&gt; &#123;</div><div class="line">	<span class="function">t <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> t&amp; x)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> -x;&#125;<span class="comment">//此const是必须的</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> t&gt;</div><div class="line"><span class="keyword">struct</span> plus : <span class="keyword">public</span> binary_funcion&lt;t, t, t&gt; &#123;</div><div class="line">	<span class="function">t <span class="title">operator</span><span class="params">()</span> <span class="params">(constt t&amp; x, <span class="keyword">const</span> t&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x + y;&#125;<span class="comment">//此const是必须的</span></div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微软的莫名好用的类(171)]]></title>
      <url>https://xuecat.github.io/2016/08/04/171/</url>
      <content type="html"><![CDATA[<blockquote>
<p>最近要写个控件，要运行时动态改变。我去！！发现微软有个莫名好用的类，完全可以达到。<br><br>Crecttracker这个类。只是注意它的可能有以下问题：<br></p>
<p>1、SetCursor无果，这个版本不对，要自己添加鼠标资源，并把资源ID改成以下<br>AFX_IDC_TRACK4WAY<br><br>AFX_IDC_TRACKNESW    <br><br>AFX_IDC_TRACKNS<br><br>AFX_IDC_TRACKNWSE<br><br>AFX_IDC_TRACKWE<br></p>
<p>2、只能响应Lbuttondown，因为Track是个阻塞函数。哈哈！剩下的自己百度了。。</p>
<p>cwaitcursor类，这个类很好用的，自动析构。把鼠标变成等待的状态。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[工具代码(170)]]></title>
      <url>https://xuecat.github.io/2016/08/04/170/</url>
      <content type="html"><![CDATA[<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">	<span class="meta">#<span class="meta-keyword">pragma</span> once</span></div><div class="line">	<span class="keyword">class</span> CSeparaString</div><div class="line">	&#123;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		CSeparaString() &#123; m_strBuffer.Empty(); &#125;</div><div class="line">		~CSeparaString() &#123;&#125;</div><div class="line">	</div><div class="line">		<span class="function">VOID	<span class="title">SetBuffer</span><span class="params">(LPCTSTR lpsz)</span> </span>&#123; m_strBuffer = lpsz; &#125;</div><div class="line">		<span class="function">CString <span class="title">GetBuffer</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_strBuffer; &#125;</div><div class="line">	</div><div class="line">		<span class="function">VOID	<span class="title">SetSepara</span><span class="params">(TCHAR ch)</span> </span>&#123; m_chSepara = ch; &#125;</div><div class="line">		</div><div class="line">		<span class="function">VOID	<span class="title">AppendElement</span><span class="params">(<span class="keyword">int</span> ne)</span> </span>&#123;</div><div class="line">			TCHAR buffer[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">			<span class="number">_</span>itot_s(ne, buffer, <span class="number">4</span>, <span class="number">10</span>);</div><div class="line">			m_strBuffer.Append(CString(m_chSepara)); </div><div class="line">			m_strBuffer.Append(buffer);</div><div class="line">		&#125;</div><div class="line">		<span class="function">VOID	<span class="title">AppendElement</span><span class="params">(LPCTSTR lpsz)</span> </span>&#123; m_strBuffer.Append(CString(m_chSepara)); m_strBuffer.Append(lpsz); &#125;</div><div class="line">		<span class="function">VOID	<span class="title">GetElement</span><span class="params">(CStringArray &amp;arry)</span> </span>&#123;</div><div class="line">			<span class="keyword">int</span> npos = m_strBuffer.Find(m_chSepara);</div><div class="line">			<span class="keyword">while</span> (npos != m_strBuffer.GetLength())</div><div class="line">			&#123;</div><div class="line">				<span class="keyword">int</span> epos = m_strBuffer.Find(m_chSepara, npos + <span class="number">1</span>);</div><div class="line">				(epos == <span class="number">-1</span>) &amp;&amp; (epos = m_strBuffer.GetLength());</div><div class="line">				arry.Add(m_strBuffer.Mid(npos + <span class="number">1</span>, epos - npos - <span class="number">1</span>));</div><div class="line">				npos = epos;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="function">CString <span class="title">GetElement</span><span class="params">(<span class="keyword">int</span> nelement)</span> </span>&#123;</div><div class="line">			<span class="keyword">int</span> npos = <span class="number">-1</span>;</div><div class="line">			<span class="keyword">int</span> epos = m_strBuffer.Find(m_chSepara);</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nelement; i++)</div><div class="line">			&#123;</div><div class="line">				npos = epos;</div><div class="line">				epos = m_strBuffer.Find(m_chSepara, npos + <span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">			(epos == <span class="number">-1</span>) &amp;&amp; (epos = m_strBuffer.GetLength());</div><div class="line">			<span class="keyword">return</span> m_strBuffer.Mid(npos + <span class="number">1</span>, epos - npos - <span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		TCHAR	m_chSepara;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		CString m_strBuffer;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	CRect CDlgImportPicture::CalculateMaxRect(<span class="keyword">const</span> CRect *prect, <span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</div><div class="line">	&#123;</div><div class="line">		CRect rtRE;</div><div class="line">		<span class="keyword">if</span> (prect)</div><div class="line">		&#123;</div><div class="line">			rtRE = prect;</div><div class="line">	</div><div class="line">			<span class="comment">//先算宽高度基准</span></div><div class="line">			<span class="keyword">if</span> (prect-&gt;Width() * denominator &gt; numerator * prect-&gt;Height())<span class="comment">//宽过多,高基准</span></div><div class="line">			&#123;</div><div class="line">				<span class="keyword">int</span> offset = prect-&gt;Width() - ((prect-&gt;Height() * numerator)/denominator);</div><div class="line">				rtRE.left += offset/<span class="number">2</span>;</div><div class="line">				rtRE.right -= offset/<span class="number">2</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span><span class="comment">//高过多,宽基准</span></div><div class="line">			&#123;</div><div class="line">				<span class="keyword">int</span> offset = prect-&gt;Height() - ((prect-&gt;Width() * denominator)/numerator);</div><div class="line">				rtRE.top += offset/<span class="number">2</span>;</div><div class="line">				rtRE.bottom -= offset/<span class="number">2</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> rtRE;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"># 时间</div><div class="line">	<span class="meta">#<span class="meta-keyword">define</span> TickStart() DWORD dwstart = GetTickCount(), dwend = 0;\</span></div><div class="line">		TCHAR buffer[1024] = &#123;0&#125;;\</div><div class="line">		TCHAR thisname[1024] = &#123;0&#125;;\</div><div class="line">		_ltot_s(int(this), thisname, 1024, 10);\</div><div class="line">	</div><div class="line">	<span class="meta">#<span class="meta-keyword">define</span> TickOutName(str) OutputDebugString(CString(thisname) + _T(<span class="meta-string">" :"</span>) + str);\</span></div><div class="line">		OutputDebugString(_T(<span class="meta-string">"\n"</span>));\</div><div class="line">	</div><div class="line">	<span class="meta">#<span class="meta-keyword">define</span> TickOutPut(str) dwend = GetTickCount();\</span></div><div class="line">		_ltot_s(dwend - dwstart, buffer, 1024, 10);\</div><div class="line">		OutputDebugString(CString(thisname) + _T(<span class="meta-string">" :"</span>) + str);\</div><div class="line">		OutputDebugString(buffer);\</div><div class="line">		OutputDebugString(_T(<span class="meta-string">"\n"</span>));\</div><div class="line">		dwstart = dwend;\</div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++11再次陪读(169)]]></title>
      <url>https://xuecat.github.io/2016/07/16/169/</url>
      <content type="html"><![CDATA[<h3 id="最近无聊，读下c-11发现有些东西都忘了。开个页面，来和书同步更新"><a href="#最近无聊，读下c-11发现有些东西都忘了。开个页面，来和书同步更新" class="headerlink" title="最近无聊，读下c++11发现有些东西都忘了。开个页面，来和书同步更新"></a>最近无聊，读下c++11发现有些东西都忘了。开个页面，来和书同步更新</h3><h4 id="1、static-assert-条件，提示字符-这个函数会在编译期间执行。"><a href="#1、static-assert-条件，提示字符-这个函数会在编译期间执行。" class="headerlink" title="1、static_assert(条件，提示字符); 这个函数会在编译期间执行。"></a>1、static_assert(条件，提示字符); 这个函数会在编译期间执行。</h4><p><img src="/picture/img/169.jpg" alt=""><br><br>如上图；<br><br>编译器在预编译期间就会报错，无法编译下去。所以里面的条件无法是动态的变量之类的。</p>
<h4 id="2、noexcept和throw-，这个是11和98两个不同的表示方式而已。都一样，如果在函数里面抛的话都会导致程序强制中断。（vs2013无法识别noexcept）"><a href="#2、noexcept和throw-，这个是11和98两个不同的表示方式而已。都一样，如果在函数里面抛的话都会导致程序强制中断。（vs2013无法识别noexcept）" class="headerlink" title="2、noexcept和throw()，这个是11和98两个不同的表示方式而已。都一样，如果在函数里面抛的话都会导致程序强制中断。（vs2013无法识别noexcept）"></a>2、noexcept和throw()，这个是11和98两个不同的表示方式而已。都一样，如果在函数里面抛的话都会导致程序强制中断。（vs2013无法识别noexcept）</h4><h4 id="3、final、override、-declspec-novtable"><a href="#3、final、override、-declspec-novtable" class="headerlink" title="3、final、override、__declspec(novtable)."></a>3、final、override、__declspec(novtable).</h4><ul>
<li>这个是11的，基类使用。专门放声明虚函数后面（定义放不下）；基类对虚函数使用这个修饰符后，子类就无法继承重写那个函数（连同名函数都不允许）</li>
<li>这个是11的，派生类使用。专门放声明虚函数后面；派生类对虚函数使用这个修饰符后，编译器会从基类去找此函数是否是要继承的虚函数（就是和编译器一个君子协定而已），不是就报错。</li>
<li>这个是Microsoft c++。作为接口的基类虽然有纯虚函数声明，但是被继承过后依旧会被分配虚函数表的空间。由于接口基类本来就是可以完全忽略的，所以用这个限定符来把那个表去掉。 <strong>但是使用的时候，最好和纯虚函数一起使用（网上说编译器会默认把函数全变成纯虚，但是试了下vs2013，完全不是的。发现它的作用只在去表，没其他的。）</strong></li>
</ul>
<h4 id="4、using构造特性"><a href="#4、using构造特性" class="headerlink" title="4、using构造特性"></a>4、using构造特性</h4><p>struct A {A(int i){} A(int d, double j)}；<br><br>struct B :　Ａ{using A::A}；<br><br>派生类的构造函数要和基类一样（包括内容），为了方便书写而使用的语法。</p>
<h4 id="5、构造函数委派"><a href="#5、构造函数委派" class="headerlink" title="5、构造函数委派"></a>5、构造函数委派</h4><p>个人十分赞扬这种思维：</p>
<pre><code>class Info {
    public:
        Info() : Info(1) {}
        Info(int i):Info(i, &apos;a&apos;) {}
        Info(char e):Info(1, e){}
    private:
        Info(int i, char e):type(i), name(e) {}
        int type;
        char name;
}
//暴漏的接口全委托给private的构造函数了。唉，这个模板好合适哟！！！
</code></pre><h4 id="6、右值和左值"><a href="#6、右值和左值" class="headerlink" title="6、右值和左值"></a>6、右值和左值</h4><figure class="highlight"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class testto</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	testto(int n):m_p(new int(n)) &#123;</div><div class="line">		int d = 5;</div><div class="line">	&#125;</div><div class="line">	~testto() &#123; </div><div class="line">		delete m_p; </div><div class="line">	&#125;</div><div class="line">	testto(testto&amp; d)&#123;</div><div class="line">		int a = 32;</div><div class="line">	&#125;</div><div class="line">	testto(testto&amp;&amp; e) :m_p(e.m_p) &#123;</div><div class="line">		e.m_p = NULL;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">public:</div><div class="line">	int * m_p;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class sudtest</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	sudtest() :p(new int(3)), h(2)&#123;</div><div class="line">		int da = 45;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	~sudtest()&#123; </div><div class="line">		delete p; </div><div class="line">	&#125;</div><div class="line">	sudtest&amp; operator = (sudtest&amp; d) &#123;</div><div class="line">		int a = 2;</div><div class="line">	&#125;</div><div class="line">	sudtest(sudtest &amp;&amp; e) : p(e.p), h(std::move(e.h))&#123;</div><div class="line">		e.p = NULL; </div><div class="line">	&#125;</div><div class="line"></div><div class="line">public:</div><div class="line">	testto h;</div><div class="line">	int *p;</div><div class="line">&#125;;</div><div class="line">sudtest gettem() &#123; </div><div class="line">	sudtest t = sudtest(); </div><div class="line">	return t; &#125;</div><div class="line"></div><div class="line">int _tmain(int argc, _TCHAR* argv[])</div><div class="line">&#123;</div><div class="line">	</div><div class="line">	sudtest a(gettem());</div><div class="line"></div><div class="line">	cout &lt;&lt; *a.p &lt;&lt; endl;</div><div class="line">	system("pause");</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>《C++ 0x 之左值与右值》文中提到 std::forward() 和 std::move()。本文开头对之补充一句：</p>
<pre><code>在操作函数返回值或函数参数时，匿名左值仍然为左值，左值可以具名；匿名右值仍然为右值，右值一旦具名成功，立即转变为左值
</code></pre><ul>
<li>先谈move吧，为了节约拷贝函数的空间，要使它走移动构造函数；</li>
<li>1、e由于被命名了所以是左值，必须用move把e.h从左值转化成右值才能调用到testto的移动构造函数。</li>
<li>2、本身传进来的e和t是一样的都是0x71f48a。临时变量就是指源。</li>
<li>3、gettem（）函数本身返回的就是临时变量，因为没有移动函数才会去寻复制函数。所以sudtest的移动函数是理所当然的，testto的移动函数是move使之。</li>
</ul>
<blockquote>
<p>在看c++折叠规则：总是优先为左值引用，再右值。int&amp; &amp;&amp;t -&gt; int&amp; t, int&amp;&amp; &amp;&amp;t -&gt; int&amp;&amp; t </p>
</blockquote>
<pre><code>fun(int &amp;&amp;m)
fun(int &amp; m)

template&lt;typename T&gt;
fun1(T&amp;&amp; t) {fun(forward&lt;T&gt;(t);)}

int a = 4;
fun1(a)//a此时是左值，调用和fun(t);无区别。
fun1(move(a))//要使用右值了，fun1中对t命名了所以是左值，所以要用forward来转换一下。这就是完美转发。
</code></pre><h4 id="7、隐式转换"><a href="#7、隐式转换" class="headerlink" title="7、隐式转换"></a>7、隐式转换</h4><p>对类进行</p>
<pre><code>operator bool() const {
    return ;
}

//如果对这个隐式转化加个explicit，那么只有构造函数才会传递了。
</code></pre><h4 id="8、POD模型"><a href="#8、POD模型" class="headerlink" title="8、POD模型"></a>8、POD模型</h4><p>1、不定义基本默认函数（构造、析构、移动、复制等）。<br>2、没有虚函数、<br>3、父类和成员是POD类型。</p>
<h4 id="9、智能指针"><a href="#9、智能指针" class="headerlink" title="9、智能指针"></a>9、智能指针</h4><p>太多了，就说下：</p>
<pre><code>auto_ptr、unique_ptr、shared_ptr、
</code></pre><h4 id="10、For"><a href="#10、For" class="headerlink" title="10、For"></a>10、For</h4><pre><code>for(int &amp;e : a) {}//引用;&apos;/[
for(int e: a){}
</code></pre><h4 id="11、多线程"><a href="#11、多线程" class="headerlink" title="11、多线程"></a>11、多线程</h4><p>c++11是支持多线程编程的。专门使用它的c++函数，这样就可以在多平台使用了。</p>
<h4 id="12、NULL"><a href="#12、NULL" class="headerlink" title="12、NULL"></a>12、NULL</h4><p>不同编译器会对NULL不同解释，gcc就是__null，mfc就是0。所以c++11用nullptr来统一。</p>
<h4 id="13、类与默认函数"><a href="#13、类与默认函数" class="headerlink" title="13、类与默认函数"></a>13、类与默认函数</h4><p>6个基本函数（移动多了构造和拷贝）、8个默认操作符函数。</p>
<h4 id="14、内存对齐描述符alignas、alignof"><a href="#14、内存对齐描述符alignas、alignof" class="headerlink" title="14、内存对齐描述符alignas、alignof"></a>14、内存对齐描述符alignas、alignof</h4><pre><code>struct alignas(32) T {
    int r;
    int g;
    int b;
};
alignof(T)；//32;前者是设置对齐字节大小，后者是获取对齐字节大小。
</code></pre><h4 id="15、Unicode支持"><a href="#15、Unicode支持" class="headerlink" title="15、Unicode支持"></a>15、Unicode支持</h4><pre><code>u8&quot;asdf&quot;//utf8字符;
u&quot;asdf&quot;//utf16字符；
U&quot;asdf&quot;//utf32字符;

11说c++支持各种字符的互相转换了，使用codecvt；但是相关资料和代码却一直没看到，只好先放放吧。
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[树莓派(168)]]></title>
      <url>https://xuecat.github.io/2016/07/01/168/</url>
      <content type="html"><![CDATA[<h4 id="1、系统"><a href="#1、系统" class="headerlink" title="1、系统"></a>1、系统</h4><ul>
<li>官方的noobs系统要有界面才行，不然安装就没法进行了。所以我喜欢直接写raspbin系统</li>
<li>noobs系统安装最简单，直接先用SDFormat格式化了复制文件进去就好。其他系统用格式化后用Win32DiskImager去写。</li>
</ul>
<h4 id="2、WiFi路由器坑点"><a href="#2、WiFi路由器坑点" class="headerlink" title="2、WiFi路由器坑点"></a>2、WiFi路由器坑点</h4><ul>
<li>sudo service hostapd restart完全无法启动dhcpdc服务，就算激活也是退出的。只能用sudo hostapd -dd /etc/hostapd/hostapd.conf来启动。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS语法(167)]]></title>
      <url>https://xuecat.github.io/2016/05/25/167/</url>
      <content type="html"><![CDATA[<p>  大部分的语法记录在笔记本上，现在写烦了，blog上面写点吧。</p>
<h4 id="function的this指针"><a href="#function的this指针" class="headerlink" title="function的this指针"></a>function的this指针</h4><pre><code>void function() { var a = 3; this.a = 5; console.log(a, this.a);}();
//以上是执行一个匿名函数。
//js来说，确实函数也是一个对象。但是像这种调用匿名函数，好像开辟的空间是开辟在全局上面的，
//所以this指向的是全局this。另外如果使用严格模式的话，如果this指向全局就会出错，
//    所以上面句子全局模式下一定错误。

function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.sayname = function() {console.log(this.name)};
}
var persion = new Person(&quot;wq&quot;, 22, &quot;programmar&quot;);
这个时候，用了一个new，使得开辟了一个新的对象。这时的this就是函数本身了。
第二个this，是因为function函数拥有了对象，this就一定指向那个对象呀。
</code></pre><h4 id="原型模式和实例模式"><a href="#原型模式和实例模式" class="headerlink" title="原型模式和实例模式"></a>原型模式和实例模式</h4><p>对于对象的构造函数，其属性有两种：<br></p>
<pre><code>function person() {
    this.name = &quot;ta&quot;;//实例模式的属性
    person.prototype.name = &quot;ba&quot;;//原型模式的属性
}
//上面俩个属性都可以被var per = new person(); per.name访问到
//per.name = &quot;tc&quot;;是实例属性 
//区别：当对象添加一个实例属性时，就会屏蔽原型的同名属性。
//判断：per.hasOwnProperty(&quot;name&quot;);是否存在实例属性
//hasPrototypeProperty（per, &quot;name&quot;）原型是否拥有且未被屏蔽
</code></pre><p>原型的弊端：它如同c++类里面的static变量一样。<br>定义的属性属于person.prototype，而不是属于var变量对象。</p>
<p>原型必要：constructor属性最好必须设置，这样就能动态识别对象类型了。</p>
<h4 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h4><p>先看代码比较：</p>
<pre><code>1function createfun() {
    var result = new Array();
    for (var i = 0； i &lt; 10; i++) {
        return [i] = function() {return i;};
    }
}
//数组结果：全10；

2function createfun() {
    var result = new Array();
    for (var i = 0; i &lt; 10; i++) {
        result[i] = function(num) {return function () {return num;};}(i);
    }
}
//数组结果:按照i来分配
//这样写的好处是调用时，直接result[i]()就行了。即使有个num参数，也会默认进入的。
</code></pre><p>原因：函数创建时，会产生作用链。内部活动对象第一位，外部活动对象依次递增。<br></p>
<p>当执行匿名函数时，匿名函数依旧能找到在作用链中找到i，而此时的i在经过循环玩了后是10，所以一直返回10；<br><br><br>值得一提的是，就是外部函数执行完了，但是内部函数只有拥有引用，就不会对对作用链进行销毁，所以匿名函数依旧能访问到i；</p>
<h4 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h4><pre><code>var name = &quot;all&quot;;
var ob = {
    name: &quot;simple&quot;;
    getname:function() {
        return function() {return this.name;}
    };
};

//匿名函数的默认this通常是全局的，所以这个不能达到预期效果。
//var that = this;
//return function() {return that.name;}这句替换了便好。
</code></pre><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><pre><code>var objectRef = new Object();
objectRef.testNumber = 5;
/* - or:- */
objectRef[&quot;testNumber&quot;] = 5;//这俩句是一样的
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数组和指针进阶(166)]]></title>
      <url>https://xuecat.github.io/2016/05/18/166/</url>
      <content type="html"><![CDATA[<p>来看一个代码和结果（比较新奇的写法吧，数组）：</p>
<p><img src="/picture/img/166.jpg" alt=""></p>
<p>1、先讲下数组的初始化赋值。结果是<br><br>0 0 0 0<br><br>1 0 0 0<br><br>2 0 0 0<br><br>4 0 0 0<br><br>结果自己想，很有意思！</p>
<p>2、从输出结果讲下。</p>
<p>这是栈的特性，从相邻内存中开辟空间。</p>
<p>所以造成了，位置相近的情况。再说位置相近的情况下，用指针直接访问全部边可以访问到数据了。<br><br>（另外，直接访问编译器是不允许的。所以要用void<em> ，int </em>指针来转换一下，骗过编译器能编译过。）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[拖拽事项(165)]]></title>
      <url>https://xuecat.github.io/2016/05/05/165/</url>
      <content type="html"><![CDATA[<pre><code>dodragdrop 一直出发不了拖拽事件，后面发现是没有初始化ole。
</code></pre><p>mfc程序调用：afxoleinit。<br><br>但是这个函数只能用于主进程，且程序会自动释放。</p>
<p>dll的话用：看情况使用CoInitialize和OleInitialize（当然必须自己调用 OleUninitialize、CoUninitialize来释放）<br><br>前者是com环境初始化，后者是前者的更近一步，ole环境初始化。当然剪切板是ole环境下的哟！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[restrict关键字(163)]]></title>
      <url>https://xuecat.github.io/2016/04/01/163/</url>
      <content type="html"><![CDATA[<pre><code>int f (int *restrict x, int *restrict y)
{
    ...
    *x = 0;
    *y = 1;
    return 0;
}
//这个关键字是编译器优化关键字。
//首先，x和y这两个参数是相同类型的
//所以执行的时候可能，x，y指向同一个地方，y改变定会改变x
//所以编译器为了正确，在x，y每次操作都会重新读取一次。
//restrict为此而生，告诉编译器，这两个相同类型的不指向同一地方，你可以自己优化。所以接下来的操作就会直接读缓存。
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Electron学习(164)]]></title>
      <url>https://xuecat.github.io/2016/02/27/164/</url>
      <content type="html"><![CDATA[<h1 id="process-platform"><a href="#process-platform" class="headerlink" title="process.platform"></a>process.platform</h1><p>The variable to use would be process.platform</p>
<p>On Mac the variable returns darwin. On Windows, it returns win32 (even on 64 bit).</p>
<p>Possible values are: ‘darwin’, ‘freebsd’, ‘linux’, ‘sunos’ or ‘win32’</p>
<p>I just set this at the top of my jakeFile:</p>
<p>var isWin = /^win/.test(process.platform);</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React Native CSS(162)]]></title>
      <url>https://xuecat.github.io/2016/02/27/162/</url>
      <content type="html"><![CDATA[<h2 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h2><p>就是说，所有带flex属性的子容器，flex值相加得到一个总数，该容器占父容器的比重就是这个容器flex值除以总flex值</p>
<p>举个例子，<br>你要实现一排图片，平分父容器的宽度，就可以先设置父容器的flexDirection:’row’<br>然后所有图片设为flex:1</p>
<p> 要和flexDirection，alignItems,justyContent这些属性配合</p>
<h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><pre><code>&lt;Image source={require(&apos;./android/app/src/main/res/drawable/ic_launcher.png&apos;)} /&gt;
&lt;/br&gt; **./** 指的是当前js代码文件的当前路径

&lt;Image source={{uri:'http://i1.s.hjfile.cn/entry/201405/0d2b3417-c6fe-48cd-9199-6278fa0e6041.jpg'}}  style={{width:100,height:100}} /&gt;
</code></pre><h2 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h2><p><a href="http://jamestw.logdown.com/posts/257890-257890-reactjs-prop" target="_blank" rel="external">查看链接学习地址！！！</a></p>
<p>这个只是为了规范属性用的，比如数字属性用 number:’string’机会出错。</p>
<h2 id="dexDug"><a href="#dexDug" class="headerlink" title="dexDug"></a>dexDug</h2><p>错误一次编译，它会在修改后继续编译其他。所以有些错误可以删除 app/build 文件，再重新编译就好了</p>
<h2 id="Bind函数"><a href="#Bind函数" class="headerlink" title="Bind函数"></a>Bind函数</h2><p>情况是这样：</p>
<p>1、chat要添加文件就要新开一个navigator，chat有个回调函数提供给新开的navigator调用（功能是给chat添加数据）。</p>
<p>2、回调函数里面必须修改chat的数据所以用了this。</p>
<p>3、结果调用回调函数报错：this setstate is not a function。</p>
<p>分析原因是找不到this吧，因为回调函数传了几次，this该搞乱了吧。</p>
<p>问题解决：extrafun:this.addFileMessage.bind(this)</p>
<p>传值得时候就绑定this，这样就不会乱了！！！！！！！！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React active(161)]]></title>
      <url>https://xuecat.github.io/2016/02/23/161/</url>
      <content type="html"><![CDATA[<p><a href="http://www.lcode.org/react-native%E7%96%91%E9%9A%BE%E7%82%B9%E9%97%AE%E9%A2%98%E6%B7%B1%E5%9D%91%E6%9C%80%E5%BC%BA%E6%80%BB%E7%BB%93%E5%B8%96%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/" target="_blank" rel="external">大部分的错误，辅助页面</a></p>
<h2 id="我遇到的错误"><a href="#我遇到的错误" class="headerlink" title="我遇到的错误"></a>我遇到的错误</h2><p>   npm版本不对，升级。</p>
<p>gredle本地安装，zip包要是all，且放在当前目录。</p>
<pre><code>distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
#distributionUrl=https\://services.gradle.org/distributions/gradle-2.4-all.zip
distributionUrl=gradle-2.4-all.zip
</code></pre><p>别用git bash页面，最好用cmd，别用户权限</p>
<p>先开虚拟机，再start服务器。</p>
<p>一直红色，就删除配置文件，再重启。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[windows使用js库(160)]]></title>
      <url>https://xuecat.github.io/2016/02/18/160/</url>
      <content type="html"><![CDATA[<p>主流有：hex cef nw（node-webkit）Electron</p>
<p>Atom、Visual Studio Code用的是Electron<br></p>
<p>倘若你的桌面版应用没有跟底层挂钩，也就是没有使用到消息推送、版本升级、打印功能之类的东西，那么没关系。但是一旦使用到这些功能，你就彻底调到坑里了，nw有个致命的缺陷在于所有的非javascript编写的模块都需要重新用nw-gyp重新编译一下，这个编译的过程会出现各种各样的问题。而Electron几乎可以使用所有的node模块，只需要node-gyp编译的即可。主要深坑就在这！！！<br></p>
<p>有道自己有个项目叫 heX 。这是其官网的介绍：<br>heX 项目于 2012 年启动，基于开源项目 CEF，它内部整合了开源项目 Chromium 及 Node.JS，将两者的 V8 引擎和消息循环合并，从而达到了在 Chromium 所展现的 Web 页面内可以直接使用 Node.JS 原生和及第三方扩展的 API 以及 Node.JS 最大的特色——异步回调与事件循环。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[生活认识(159)]]></title>
      <url>https://xuecat.github.io/2016/01/28/159/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Artistic Style:<br><br><br>D:\AStyle_2.05.1_windows\AStyle\bin\AStyle.exe<br><br>–options=D:\AStyle_2.05.1_windows\AStyle\bin\astylerc <em>.h </em>.cpp <em>.hpp </em>.c<br><br>$(ItemDir)<br></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[高低字节宏(157)]]></title>
      <url>https://xuecat.github.io/2016/01/25/157/</url>
      <content type="html"><![CDATA[<figure class="highlight"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#define MAKEWORD(a, b)      ((WORD)(((BYTE)((DWORD_PTR)(a) &amp; 0xff)) | ((WORD)((BYTE)((DWORD_PTR)(b) &amp; 0xff))) &lt;&lt; 8))</div><div class="line">#define MAKELONG(a, b)      ((LONG)(((WORD)((DWORD_PTR)(a) &amp; 0xffff)) | ((DWORD)((WORD)((DWORD_PTR)(b) &amp; 0xffff))) &lt;&lt; 16))</div><div class="line">#define LOWORD(l)           ((WORD)((DWORD_PTR)(l) &amp; 0xffff))</div><div class="line">#define HIWORD(l)           ((WORD)((DWORD_PTR)(l) &gt;&gt; 16))</div><div class="line">#define LOBYTE(w)           ((BYTE)((DWORD_PTR)(w) &amp; 0xff))</div><div class="line">#define HIBYTE(w)           ((BYTE)((DWORD_PTR)(w) &gt;&gt; 8))</div><div class="line"></div></pre></td></tr></table></figure>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>从上面加粗部分可以看出 LOWORD 和 HIWORD 返回值是WORD型，即unsigned short，因此不能表示负数，在使用的时候可能就要注意了。<br><br>对于一般情况，用它们是没有问题的，但有一个特例，就是利用它们取当前鼠标的坐标时，因为鼠标有时候会移出窗口，因此我们得到的值本应该是负数，但是利用这两个宏得出的值始终是正值。我们可以用以下的宏来代替。</p>
 <figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>       DWORD;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>       BYTE;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>      WORD;</div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python 等问题解决(155)]]></title>
      <url>https://xuecat.github.io/2016/01/14/155/</url>
      <content type="html"><![CDATA[<p>python安装某些模块的时候，老是出错（当然错误是Unicode和ascii字符的问题）</p>
<p><strong>1、安装模块字符错误</strong><br><br>在python的Lib\site-packages文件夹下新建一个sitecustomize.py，内容为：</p>
<pre><code> # encoding=utf8  
import sys  

reload(sys)  
sys.setdefaultencoding(&apos;utf8&apos;)
</code></pre><p>此时重启python解释器，可以解决了。</p>
<p><strong>pip的国内源</strong><br><br>这里，我只说下指令，其它百度吧。感觉这个华中科大的源最快；<br><br>pip install ** -i <a href="http://pypi.mirrors.ustc.edu.cn/simple" target="_blank" rel="external">http://pypi.mirrors.ustc.edu.cn/simple</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[调试技巧(154)]]></title>
      <url>https://xuecat.github.io/2016/01/14/154/</url>
      <content type="html"><![CDATA[<p>  自从在153文章的认识后，自己要好好熟悉下那个工具<br></p>
<h2 id="调试篇"><a href="#调试篇" class="headerlink" title="调试篇"></a>调试篇</h2><blockquote>
<p><strong>1、运行中，就直接调试改变</strong>（以前一直用的是悬浮时看值，都不敢改值）<br><img src="/picture/img/1541.png" alt=""></p>
<p><strong>2、黄色箭头的使用</strong>（首先可以上拉和下拉）<br><strong>上拉</strong>：假如我有一句看漏了想在看一遍，直接上拉，拉回到某个地方，再继续F10，编译器又会继续走的；<br><strong>下拉</strong>：假如我中间有一句不想执行，想直接跳过，下拉超过那一句便好！！！<br><img src="/picture/img/1542.png" alt=""></p>
<p><strong>3、编辑后继续执行</strong><br>这个的话，vs2008我试了下是会重新编译的；vs2013也分情况，但是这个功能依旧要自己使用。</p>
<p><strong>4、监听窗口伪变量；如：当前error的值</strong>。一般窗口运行错误的时候，我以前的做法是用getlasterror来赋值。然而监视窗口却有个值可以直接获取到的<br><img src="/picture/img/1543.png" alt=""></p>
<p>最后提下：<br><br>$tid—–当前线程的线程ID<br><br>$pid——进程ID<br><br>$cmdline———-启动程序的命令行字符串<br><br>$user———-正在运行程序的账户信息<br><br>$registername—–显示寄存器registername 的内容<br><br>不管怎么样，关于最后一个错误的伪变量是非常有用的：<br><br><br><br>$err——–显示最后一个错误的错误码<br><br>$err,hr—显示最后一个错误的错误信息<br><br><br><br><strong>5、多线程调试</strong>，这个暂时不说，我那点贫瘠的多线程调试也写不多，希望以后能补充上<br><a href="http://blog.jobbole.com/45447/" target="_blank" rel="external">http://blog.jobbole.com/45447/</a></p>
<p><strong>6、条件断点</strong> 我暂时也就只会一些简单的条件语法<br><img src="/picture/img/1544.png" alt=""><br><br><br></p>
<p><strong>7、使用命令窗口来测试函数有效性</strong><br><img src="/picture/img/1545.jpg" alt=""></p>
<p><strong>比如，有个time_t的变量（它当然是个int），要看它的时间格式，就可以用这个来</strong><br><img src="/picture/img/1546.jpg" alt=""></p>
<p><strong>8、自定义中断，这个我感觉还用不上，跳过了</strong></p>
<p><strong>9、远程调试</strong><br>先去IDE的 Common7\IDE\Remote Debugger，找到合适的64位或32位工具。直接复制到远程机器上；远程机器运行后设置允许任何人连接。如此，本地通过附加进程的方式可以远程调试。</p>
<p><strong>10、调试时数据信息格式化</strong><br><br>想要改变显示类型可在变量前加以下前缀：<br></p>
<p>by –unsigned char (又称为unsigned byte)<br><br>wo – unsigned shot(又称为 unsigned word)<br><br>dw – unsigned long（又称为 unsigned double word）<br><br>要改变显示的进制数在变量前加下列前缀：<br></p>
<p>d 或者 i– 有符号十进制数<br><br>u – 无符号十进制数<br><br>o -  无符号八进制数<br><br>x – 小写十六进制数<br><br>X – 大写十六进制数<br><br><img src="/picture/img/154a.png" alt=""></p>
<blockquote>
<p>字符串的格式化<br><br>mb 或者 m – 十六进制显示的16字节数据，后跟16个ASCII 字符<br><br>mw – 8 words<br><br>md – 4 double words<br><br>mq -  2 quad-words<br><br>ma – 64个ASCII字符<br><br>mu – 2字节的UNICODE字符<br><br><img src="/picture/img/154b.png" alt=""></p>
</blockquote>
</blockquote>
<h2 id="有趣的快捷键"><a href="#有趣的快捷键" class="headerlink" title="有趣的快捷键"></a>有趣的快捷键</h2><blockquote>
<p><strong>1、同名跳转</strong><br>vs对双击的变量和函数等，会高亮当前文档的所有；以前我一般用 ctrl + f来一个一个跳转翻看。今天发现可以ctrl +　shift + 上箭头/下箭头来跳转翻看。<br><img src="/picture/img/1547.jpg" alt=""><br><br><br><br><br><strong>2、自动生成类</strong> 当然，你写个clas +名 vs会自动给你生成类。我说的是没有声明的情况下。<br>当写到某句时，我想新建一个类，又不想跳过去一个一个新建说明；<br>直接 ctrl+shirft+c就新建好了<br><img src="/picture/img/1548.jpg" alt=""></p>
</blockquote>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><blockquote>
<blockquote>
<p>1、有一段时间我的vs全是16进制的，解决方法：随便弄个调试窗口出来，右键调试窗口，把选中的16进制显示 取消掉<br><br><br></p>
<p>2、实时监控的时候，可以把某个变量某个值 的监控钉在编辑框上<br><img src="/picture/img/1549.png" alt=""><br><br><br></p>
<p>3、查看某个函数被哪些函数调用过，选中，右键.查看调用层次结构（view call Hierarchy）</p>
<p>::OutputDebugString(_T(“debug information!”));</p>
</blockquote>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vs调试(153)]]></title>
      <url>https://xuecat.github.io/2016/01/11/153/</url>
      <content type="html"><![CDATA[<blockquote>
<p>今天虽然熬夜，但是学了个新东西！！！！！！<br><br>以前，release和release项目工程；有个缺点就是没法调试到mfc的动态库，只能自己调试自己的代码。<br></p>
</blockquote>
<p><strong>调试mfc库代码</strong></p>
<blockquote>
<p>调试-&gt;窗口-&gt;模块-&gt;有很多的dll-&gt;windows的库就右键加载服务器的库，自己的库就找到pdb文件，链接上！！！</p>
</blockquote>
<p><strong><em>注意有个大前提，一定要设置 c/c++-&gt;优化-&gt;优化 设置禁止  c/c++-&gt;常规-&gt;调试信息格式 设置程序数据库 才行</em></strong></p>
<p><strong>调试发行版</strong></p>
<ul>
<li>配置C/C++ &gt;General&gt;Debug Information Format 应该为 “Program Database(/Zi)”</li>
<li>配置C/C++ &gt;Optimization&gt;Optimization 应该为”Disabld(/Od)”</li>
<li>配置Linker&gt;Debugging&gt;Generate Debug Info 应该为”Yes/(DEBUG)”</li>
</ul>
<p><strong>远程调试</strong></p>
<p>算了以上俩个用了太多了，直接上别人写的：<a href="http://blog.jobbole.com/45249/" target="_blank" rel="external">http://blog.jobbole.com/45249/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[afx文件的使用（152）]]></title>
      <url>https://xuecat.github.io/2016/01/06/152/</url>
      <content type="html"><![CDATA[<blockquote>
<p>首先，windows对所有的afx是有源码的，也就是说mfc框架是源码出来的。</p>
<p>然后调试的时候，debug，Use MFC in a Static Library。或者下载符号文件。这样才可以正常调试进去。</p>
</blockquote>
<p>CRectTracker类的源代码在Trckrect.cpp里面。藏得够深！！！！！！！！！<br><br>CFrameWnd类的源代码在winfrm.cpp里面。<br><br>CMDIFrameWnd类的源代码在winmdi.cpp里面。<br><br>Afx系列的线程以及CWinThread类的源代码在thrdcore.cpp里面<br><br>cview的代码在viewcore.cpp里面</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[各类map效率比较实用2(151)]]></title>
      <url>https://xuecat.github.io/2015/11/27/151/</url>
      <content type="html"><![CDATA[<p><img src="/picture/img/151.png" alt=""></p>
<blockquote>
<p>1、果然大数据hash表虐红黑树了。<br><br><br>2、但是唯一确定的是unordered_map &gt; hash_map &gt; map,官方也是如此认为的，前面map虽然高效，但是开辟的内存却是更多，也更难使用。（见146使用方法）</p>
<p>3、使用数据，50000存储，2000查询</p>
<p>4、现象，map在上万的查询就各种内存泄露了，cmap依旧需要removeall释放。map性能可能更差，上千未测试map的数据；</p>
</blockquote>
<figure class="highlight"><figcaption><span>下面是代码：++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// test.cpp : 定义控制台应用程序的入口点。</div><div class="line">//</div><div class="line"></div><div class="line">#include "stdafx.h"</div><div class="line">#include &lt;afx.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;deque&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">#include &lt;unordered_map&gt;</div><div class="line">#include &lt;hash_map&gt;</div><div class="line">#include &lt;xhash&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;stdarg.h&gt;</div><div class="line">#include &lt;afxtempl.h&gt;</div><div class="line">#include &lt;functional&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line"></div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">typedef struct TDATA0 &#123;</div><div class="line">	int year;</div><div class="line">	int month;</div><div class="line">	int day;</div><div class="line">&#125; *PTDATA0;</div><div class="line">typedef struct TDATA1 &#123;</div><div class="line">	TDATA1&amp; operator= (TDATA1&amp; t) &#123;</div><div class="line">		name = t.name;</div><div class="line">		adress = t.adress;</div><div class="line">		parents = t.parents;</div><div class="line">		brithday = t.brithday;</div><div class="line">		return *this;</div><div class="line">	&#125;</div><div class="line">	CString name;</div><div class="line">	CString adress;</div><div class="line">	CString parents;</div><div class="line">	TDATA0 brithday;</div><div class="line">&#125; *PTDATA1;</div><div class="line"></div><div class="line">typedef struct FINDDATA &#123;</div><div class="line">	FINDDATA(int in) &#123;</div><div class="line">		index = in;</div><div class="line">		::CoCreateGuid(&amp;findguid);</div><div class="line">	&#125;</div><div class="line">	~FINDDATA() &#123;&#125;</div><div class="line">	operator int () &#123;</div><div class="line">		return index;</div><div class="line">	&#125;</div><div class="line">	int index;</div><div class="line">	GUID findguid;</div><div class="line">&#125; *PFINDDATA;</div><div class="line"></div><div class="line">std::wstring GUIDToWstring(GUID* guid) &#123;</div><div class="line">	wchar_t guid_string[37];</div><div class="line">	swprintf(</div><div class="line">		guid_string, sizeof(guid_string) / sizeof(guid_string[0]),</div><div class="line">		L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",</div><div class="line">		guid-&gt;Data1, guid-&gt;Data2, guid-&gt;Data3,</div><div class="line">		guid-&gt;Data4[0], guid-&gt;Data4[1], guid-&gt;Data4[2],</div><div class="line">		guid-&gt;Data4[3], guid-&gt;Data4[4], guid-&gt;Data4[5],</div><div class="line">		guid-&gt;Data4[6], guid-&gt;Data4[7]);</div><div class="line">	return guid_string;</div><div class="line">&#125;</div><div class="line">struct WCharLess : public binary_function&lt;const wchar_t*, const wchar_t*, bool&gt;  </div><div class="line">&#123;  </div><div class="line">public:  </div><div class="line">	result_type operator()(const first_argument_type&amp; _Left, const second_argument_type&amp; _Right) const  </div><div class="line">	&#123;  </div><div class="line">		return(_wcsicmp(_Left, _Right) &lt; 0 ? true : false);</div><div class="line">	&#125;  </div><div class="line">&#125;;</div><div class="line">//struct KeyHasher</div><div class="line">//&#123;</div><div class="line">//	std::size_t operator()(const CString&amp; k) const</div><div class="line">//	&#123;</div><div class="line">//		using std::size_t;</div><div class="line">//		using std::tr1::hash;</div><div class="line">//</div><div class="line">//		return (hash&lt;CString&gt;()(k));</div><div class="line">//	&#125;</div><div class="line">//&#125;;</div><div class="line">typedef std::queue&lt;FINDDATA&gt; stru_find;</div><div class="line">typedef std::map&lt;CString, TDATA1&gt; map_d_type;</div><div class="line">typedef stdext::hash_map&lt;CString, TDATA1, stdext::hash_compare&lt;const wchar_t*, WCharLess&gt;&gt; hashmap_d_type;</div><div class="line">typedef std::tr1::unordered_map&lt;wstring, TDATA1&gt; unordemap_d_type;</div><div class="line">typedef std::vector&lt;std::pair&lt;CString, TDATA1&gt;&gt; vecpair_d_type;</div><div class="line">typedef CMap&lt;CString, LPCTSTR, TDATA1, TDATA1&amp;&gt; cmap_d_type;</div><div class="line"></div><div class="line">void createfinddata(stru_find&amp; find) &#123;</div><div class="line">	for (int i = 2000; i &lt; 4000; i++)</div><div class="line">	&#123;</div><div class="line">		find.push(FINDDATA(i));</div><div class="line">	&#125;</div><div class="line">	find.push(0);</div><div class="line">&#125;</div><div class="line">size_t loadCmapData(stru_find find, cmap_d_type &amp;test_data) &#123;</div><div class="line">	for (int i = 1; i &lt;= 50000; i++)</div><div class="line">	&#123;</div><div class="line">		GUID guid;</div><div class="line">		wchar_t strbuffer[10] = &#123;0&#125;;</div><div class="line"></div><div class="line">		_itow(i, strbuffer, 10);</div><div class="line"></div><div class="line">		TDATA1 t ;</div><div class="line">		t.name = _T("name");</div><div class="line">		t.name += strbuffer;</div><div class="line">		t.adress = _T("address");</div><div class="line">		t.adress += strbuffer;</div><div class="line">		t.parents = _T("parents");</div><div class="line">		t.parents += strbuffer;</div><div class="line">		t.brithday.year = t.brithday.month = t.brithday.day = i;</div><div class="line"></div><div class="line"></div><div class="line">		::CoCreateGuid(&amp;guid);</div><div class="line">		if (i == find.front()) &#123;</div><div class="line">			guid = find.front().findguid;</div><div class="line">			find.pop();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		CString temp(GUIDToWstring(&amp;guid).c_str());</div><div class="line">		test_data.SetAt(temp, t);</div><div class="line">	&#125;</div><div class="line">	return test_data.GetSize();</div><div class="line">&#125;</div><div class="line">void printfcmap(stru_find&amp; find, cmap_d_type &amp;test_data) &#123;</div><div class="line">	TDATA1 out;</div><div class="line">	BOOL b;</div><div class="line">	CString temp;</div><div class="line"></div><div class="line">	int n = find.size();</div><div class="line">	for (int i = 0; i &lt; n; i++)</div><div class="line">	&#123;</div><div class="line">		temp.Empty();</div><div class="line">		temp.Append(GUIDToWstring(&amp;find.front().findguid).c_str());</div><div class="line">		b = test_data.Lookup(temp, out);</div><div class="line">		if (b) &#123;</div><div class="line">			wcout &lt;&lt; endl &lt;&lt; L"find count: " &lt;&lt; find.size() &lt;&lt; "find index:"&lt;&lt; find.front() &lt;&lt; endl</div><div class="line">				&lt;&lt; "data key :" &lt;&lt; temp.GetString()  &lt;&lt; endl</div><div class="line">				&lt;&lt; L"name :" &lt;&lt; out.name.GetString()&lt;&lt; endl</div><div class="line">				&lt;&lt; L"address :"&lt;&lt; out.adress.GetString() &lt;&lt;endl</div><div class="line">				&lt;&lt; L"parents :"&lt;&lt;out.parents.GetString() &lt;&lt; endl</div><div class="line">				&lt;&lt; L"birthday :" &lt;&lt; out.brithday.year &lt;&lt; " "&lt;&lt; out.brithday.month&lt;&lt;" "&lt;&lt;out.brithday.day &lt;&lt; endl;</div><div class="line">			find.pop();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">size_t loadMapData(stru_find findata, map_d_type&amp; mapdata) &#123;</div><div class="line">	for (int i = 1; i &lt;= 50000; i++)</div><div class="line">	&#123;</div><div class="line">		GUID guid;</div><div class="line">		wchar_t strbuffer[10] = &#123;0&#125;;</div><div class="line">		_itow(i, strbuffer, 10);</div><div class="line"></div><div class="line">		TDATA1 t ;</div><div class="line">		t.name = _T("name");</div><div class="line">		t.name += strbuffer;</div><div class="line">		t.adress = _T("address");</div><div class="line">		t.adress += strbuffer;</div><div class="line">		t.parents = _T("parents");</div><div class="line">		t.parents += strbuffer;</div><div class="line">		t.brithday.year = t.brithday.month = t.brithday.day = i;</div><div class="line"></div><div class="line"></div><div class="line">		::CoCreateGuid(&amp;guid);</div><div class="line">		if (i == findata.front()) &#123;</div><div class="line">			guid = findata.front().findguid;</div><div class="line">			findata.pop();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		CString temp(GUIDToWstring(&amp;guid).c_str());</div><div class="line">		mapdata.insert(map_d_type::value_type(temp, t));</div><div class="line">	&#125;</div><div class="line">	return mapdata.size();</div><div class="line">&#125;</div><div class="line"></div><div class="line">void printfmap(stru_find&amp; find, map_d_type &amp;test_data) &#123;</div><div class="line">	</div><div class="line">	CString temp;</div><div class="line"></div><div class="line">	int n = find.size();</div><div class="line">	for (int i = 0; i &lt; n; i++)</div><div class="line">	&#123;</div><div class="line">		temp.Empty();</div><div class="line">		temp.Append(GUIDToWstring(&amp;find.front().findguid).c_str());</div><div class="line">		map_d_type::iterator ifind = test_data.find(temp);</div><div class="line">		//map_d_type::iterator ifind ;</div><div class="line">		//out = (*ifind).second;</div><div class="line">		if (ifind != test_data.end()) &#123;</div><div class="line">			wcout &lt;&lt; endl &lt;&lt; L"left find count: " &lt;&lt; find.size() &lt;&lt; " find index:"&lt;&lt; find.front() &lt;&lt; endl</div><div class="line">				&lt;&lt; "data key :" &lt;&lt; temp.GetString()  &lt;&lt; endl</div><div class="line">				&lt;&lt; L"name :" &lt;&lt; (*ifind).second.name.GetString()&lt;&lt; endl</div><div class="line">				&lt;&lt; L"address :"&lt;&lt; (*ifind).second.adress.GetString() &lt;&lt;endl</div><div class="line">				&lt;&lt; L"parents :"&lt;&lt;(*ifind).second.parents.GetString() &lt;&lt; endl</div><div class="line">				&lt;&lt; L"birthday :" &lt;&lt; (*ifind).second.brithday.year &lt;&lt; " "&lt;&lt; (*ifind).second.brithday.month&lt;&lt;" "&lt;&lt;(*ifind).second.brithday.day &lt;&lt; endl;</div><div class="line">			find.pop();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">size_t loadUnoderMapData(stru_find findata, unordemap_d_type&amp; test_data) &#123;</div><div class="line">	test_data.rehash(50000);</div><div class="line">	for (int i = 1; i &lt;= 50000; i++)</div><div class="line">	&#123;</div><div class="line">		GUID guid;</div><div class="line">		wchar_t strbuffer[10] = &#123;0&#125;;</div><div class="line">		_itow(i, strbuffer, 10);</div><div class="line"></div><div class="line">		TDATA1 t ;</div><div class="line">		t.name = _T("name");</div><div class="line">		t.name += strbuffer;</div><div class="line">		t.adress = _T("address");</div><div class="line">		t.adress += strbuffer;</div><div class="line">		t.parents = _T("parents");</div><div class="line">		t.parents += strbuffer;</div><div class="line">		t.brithday.year = t.brithday.month = t.brithday.day = i;</div><div class="line"></div><div class="line"></div><div class="line">		::CoCreateGuid(&amp;guid);</div><div class="line">		if (i == findata.front()) &#123;</div><div class="line">			guid = findata.front().findguid;</div><div class="line">			findata.pop();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		wstring temp(GUIDToWstring(&amp;guid).c_str());</div><div class="line"></div><div class="line">		test_data.insert(unordemap_d_type::value_type(temp, t));</div><div class="line">	&#125;</div><div class="line">	return test_data.size();</div><div class="line">&#125;</div><div class="line"></div><div class="line">void printUnoderMap(stru_find findata, unordemap_d_type&amp; test_data) &#123;</div><div class="line">	wstring temp;</div><div class="line"></div><div class="line">	int n = findata.size();</div><div class="line">	for (int i = 0; i &lt; n; i++)</div><div class="line">	&#123;</div><div class="line">		//temp.empty();</div><div class="line">		temp = (GUIDToWstring(&amp;findata.front().findguid));</div><div class="line">		unordemap_d_type::iterator ifind = test_data.find(temp);</div><div class="line">		</div><div class="line">		if (ifind != test_data.end()) &#123;</div><div class="line">			wcout &lt;&lt; endl &lt;&lt; L"left find count: " &lt;&lt; findata.size() &lt;&lt; " find index:"&lt;&lt; findata.front() &lt;&lt; endl</div><div class="line">				&lt;&lt; "data key :" &lt;&lt; temp  &lt;&lt; endl</div><div class="line">				&lt;&lt; L"name :" &lt;&lt; (*ifind).second.name.GetString()&lt;&lt; endl</div><div class="line">				&lt;&lt; L"address :"&lt;&lt; (*ifind).second.adress.GetString() &lt;&lt;endl</div><div class="line">				&lt;&lt; L"parents :"&lt;&lt;(*ifind).second.parents.GetString() &lt;&lt; endl</div><div class="line">				&lt;&lt; L"birthday :" &lt;&lt; (*ifind).second.brithday.year &lt;&lt; " "&lt;&lt; (*ifind).second.brithday.month&lt;&lt;" "&lt;&lt;(*ifind).second.brithday.day &lt;&lt; endl;</div><div class="line">			findata.pop();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">size_t loadHashMapData(stru_find findata, hashmap_d_type&amp; test_data) &#123;</div><div class="line">	test_data.rehash(50000);</div><div class="line">	for (int i = 1; i &lt;= 50000; i++)</div><div class="line">	&#123;</div><div class="line">		GUID guid;</div><div class="line">		wchar_t strbuffer[10] = &#123;0&#125;;</div><div class="line">		_itow(i, strbuffer, 10);</div><div class="line"></div><div class="line">		TDATA1 t ;</div><div class="line">		t.name = _T("name");</div><div class="line">		t.name += strbuffer;</div><div class="line">		t.adress = _T("address");</div><div class="line">		t.adress += strbuffer;</div><div class="line">		t.parents = _T("parents");</div><div class="line">		t.parents += strbuffer;</div><div class="line">		t.brithday.year = t.brithday.month = t.brithday.day = i;</div><div class="line"></div><div class="line"></div><div class="line">		::CoCreateGuid(&amp;guid);</div><div class="line">		if (i == findata.front()) &#123;</div><div class="line">			guid = findata.front().findguid;</div><div class="line">			findata.pop();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		CString temp(GUIDToWstring(&amp;guid).c_str());</div><div class="line"></div><div class="line">		test_data.insert(hashmap_d_type::value_type(temp, t));</div><div class="line">	&#125;</div><div class="line">	return test_data.size();</div><div class="line">&#125;</div><div class="line"></div><div class="line">void printHashMap(stru_find findata, hashmap_d_type&amp; test_data) &#123;</div><div class="line">	CString temp;</div><div class="line"></div><div class="line">	int n = findata.size();</div><div class="line">	for (int i = 0; i &lt; n; i++)</div><div class="line">	&#123;</div><div class="line">		temp.Empty();</div><div class="line">		temp.Append(GUIDToWstring(&amp;findata.front().findguid).c_str());</div><div class="line">		hashmap_d_type::iterator ifind = test_data.find(temp);</div><div class="line">		</div><div class="line">		if (ifind != test_data.end()) &#123;</div><div class="line">			wcout &lt;&lt; endl &lt;&lt; L"left find count: " &lt;&lt; findata.size() &lt;&lt; " find index:"&lt;&lt; findata.front() &lt;&lt; endl</div><div class="line">				&lt;&lt; "data key :" &lt;&lt; temp.GetString()  &lt;&lt; endl</div><div class="line">				&lt;&lt; L"name :" &lt;&lt; (*ifind).second.name.GetString()&lt;&lt; endl</div><div class="line">				&lt;&lt; L"address :"&lt;&lt; (*ifind).second.adress.GetString() &lt;&lt;endl</div><div class="line">				&lt;&lt; L"parents :"&lt;&lt;(*ifind).second.parents.GetString() &lt;&lt; endl</div><div class="line">				&lt;&lt; L"birthday :" &lt;&lt; (*ifind).second.brithday.year &lt;&lt; " "&lt;&lt; (*ifind).second.brithday.month&lt;&lt;" "&lt;&lt;(*ifind).second.brithday.day &lt;&lt; endl;</div><div class="line">			findata.pop();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">int _tmain(int argc, _TCHAR* argv[])</div><div class="line">&#123;</div><div class="line">	size_t loadsize = 0;</div><div class="line">	string loadtype;</div><div class="line"></div><div class="line">	stru_find finddata;</div><div class="line">	map_d_type	test_mapdata;</div><div class="line">	cmap_d_type test_cmapdata;</div><div class="line">	hashmap_d_type test_hashmapdata;</div><div class="line">	unordemap_d_type test_unordermapdata;</div><div class="line"></div><div class="line">	createfinddata(finddata);</div><div class="line"></div><div class="line">	time_t start = clock();</div><div class="line">	//loadsize = loadMapData(finddata, test_mapdata);loadtype.empty();loadtype.append("In map type:");</div><div class="line">	//loadsize = loadCmapData(finddata, test_cmapdata);loadtype.empty();loadtype.append("In cmap type:");</div><div class="line">	//loadsize = loadHashMapData(finddata, test_hashmapdata); loadtype.empty();loadtype.append("In hash_map type:");</div><div class="line">	loadsize = loadUnoderMapData(finddata, test_unordermapdata); loadtype.empty();loadtype.append("In unordered_map type:");</div><div class="line">	time_t end = clock();</div><div class="line">	cout &lt;&lt; loadtype &lt;&lt; endl &lt;&lt; "load "&lt;&lt; loadsize &lt;&lt;" data useing time:" &lt;&lt; end - start &lt;&lt; "/ms" &lt;&lt; endl;</div><div class="line">	</div><div class="line">	start = clock();</div><div class="line">	//printfmap(finddata, test_mapdata);</div><div class="line">	//printfcmap(finddata, test_cmapdata);</div><div class="line">	//printHashMap(finddata, test_hashmapdata);</div><div class="line">	printUnoderMap(finddata, test_unordermapdata);</div><div class="line">	end = clock();</div><div class="line">	test_mapdata.clear();</div><div class="line">	test_cmapdata.RemoveAll();</div><div class="line">	cout &lt;&lt; endl &lt;&lt; "find "&lt;&lt;finddata.size()&lt;&lt;" data using time:" &lt;&lt; end - start &lt;&lt; "/ms" &lt;&lt; endl;</div><div class="line">	</div><div class="line">	system("pause");</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[函数学习]]></title>
      <url>https://xuecat.github.io/2015/11/26/150/</url>
      <content type="html"><![CDATA[<figure class="highlight c"><figcaption><span>弄个函数学习++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function">BOOL WINAPI <span class="title">PostThreadMessage</span><span class="params">(<span class="number">_</span>In_ DWORD idThread,<span class="number">_</span>In_ UINT Msg,<span class="number">_</span>In_ WPARAM wParam,<span class="number">_</span>In_ LPARAM lParam)</span></span>;</div><div class="line"><span class="comment">//向指定线程ID，发送消息，高低字节参数。</span></div><div class="line"></div><div class="line"><span class="comment">//嘿嘿，线程可以完全像消息机制；</span></div><div class="line"><span class="function">DWORD <span class="title">ThreadProc</span><span class="params">(LPVOID lParam)</span></span></div><div class="line">&#123;</div><div class="line">               MSG msg;</div><div class="line">               <span class="keyword">while</span>(GetMessage(&amp;msg,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</div><div class="line">               &#123;</div><div class="line">                       <span class="keyword">if</span>(msg.message == TALK_MESSAGE)</div><div class="line">                       &#123;</div><div class="line">                               MessageBox(<span class="literal">NULL</span>,<span class="string">L"Hi"</span>,<span class="string">L"Worker Thread"</span>,MB_OK);</div><div class="line">                       &#125;</div><div class="line">                       DispatchMessage(&amp;msg);<span class="comment">//下发消息，好像线程没有消息注册窗口。</span></div><div class="line">               &#125;</div><div class="line">               MessageBox(<span class="literal">NULL</span>,<span class="string">L"Thread will close by pressing OK"</span>,<span class="string">L"From Worker Thread"</span>,MB_OK);</div><div class="line">               AfxGetApp()-&gt;m_pMainWnd-&gt;PostMessageW(TALK_MESSAGE+<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">               <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[文章笔记（大部分来源于CSDN）(149)]]></title>
      <url>https://xuecat.github.io/2015/11/26/149/</url>
      <content type="html"><![CDATA[<p><strong>csdn文章一般都会放书签里面，但是多了就又记不住了，算了，开个页面吧：</strong></p>
<p>1、<br><img src="/picture/img/149a.jpg" alt=""></p>
<p>2、</p>
<p><img src="/picture/img/149b.jpg" alt=""></p>
<p>查了下，居然是google的东西，貌似浏览器和Android都用它，屌屌，，google大大的东东就是牛逼</p>
<p>3、</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vs编译器，宏展开选项(148)]]></title>
      <url>https://xuecat.github.io/2015/11/20/148/</url>
      <content type="html"><![CDATA[<p>  开发的时候，宏展开，动态调试简直没法玩。</p>
<p>今天遇见一个。最好单个文件设置，整个项目设置简直没法玩，随便就是几十万行。</p>
<p>cpp右键,属性，c/c++,预编译宏，预编译到文件，“/p”<br><br>这样会生成一个.i的文件，里面就全是cpp的代码宏展开，调试时替换就好，<br>反正是个然并卵的东西。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[日记1]]></title>
      <url>https://xuecat.github.io/2015/11/16/147/</url>
      <content type="html"><![CDATA[<p>  本来就没有什么优点，平凡而又卑微的人生，回首过去是羞愧不已，展望未来却又愁眉不展；时光的流逝唯独对自己的厌恶却是日渐增加；既如此不堪却也只好本着不给别人添加麻烦，不用对别人负责的理念，做一个骄傲的孤独者罢了！！！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[STL实用(146)]]></title>
      <url>https://xuecat.github.io/2015/11/12/146/</url>
      <content type="html"><![CDATA[<h3 id="最近懈怠了STL，弄得都要翻资料了，赶紧弄点笔记："><a href="#最近懈怠了STL，弄得都要翻资料了，赶紧弄点笔记：" class="headerlink" title="最近懈怠了STL，弄得都要翻资料了，赶紧弄点笔记："></a>最近懈怠了STL，弄得都要翻资料了，赶紧弄点笔记：</h3><hr>
<p><strong>建议</strong></p>
<ul>
<li><p>vector，等容器指针，真心是坑；要写就一定要保证，所有复制，赋值，创建，删除，自己写，所有的stl函数要留意点，比如remove这种移动函数。不然，用默认函数就特么操作指针，后面简直叫妈妈！！！</p>
</li>
<li><p>vector比deque多了capacity（能容纳的元素数量，就是开辟内存），reserve。可以看出vector的虚拟预定义分配。<br>vector对内存的处理是开辟后，clear并不释放，而是在析构函数上释放；所以要动态回收大多内存就要用swap来。vec.swap(vector<int>());注意这段代码只能和clear连用，因为它同样能清空容器数据。</int></p>
</li>
</ul>
<ul>
<li>容器指针，老是需要自己写新函数，并自己调用它。所以STL提供智能指针来解决问题.<br><br>Effective stl指出了几个问题：<br><br>1、auto_ptr不能共享所有权<br><br>2、auto_ptr不能用数组初始化<br><br>3、auto_ptr不能作为容器成员<br><br>4、不能通过赋值操作来初始化auto_ptr<br><br>5、不要把auto_ptr放入容器。<br><br>shared_ptr就解决了1个问题而已。</li>
</ul>
<figure class="highlight c"><figcaption><span>代码演示++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>*&gt; v_pint;</div><div class="line"><span class="built_in">auto_ptr</span>&lt;v_pint&gt; auto_p(<span class="keyword">new</span> v_pint<span class="comment">/*, 这里可以指定析构函数*/</span>);</div><div class="line">auto_p-&gt;push_back(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</div><div class="line">auto_p-&gt;push_back(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>));</div><div class="line">auto_p-&gt;push_back(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>));</div><div class="line">auto_p-&gt;push_back(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">4</span>));</div><div class="line"></div><div class="line">v_pint auto_pt;</div><div class="line">auto_pt.push_back(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>));</div><div class="line">auto_pt.push_back(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">6</span>));</div><div class="line">auto_pt.push_back(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">7</span>));</div><div class="line"></div><div class="line"><span class="keyword">bool</span> bequal = <span class="built_in">std</span>::equal(auto_pt.begin(), auto_pt.end(), auto_p-&gt;begin());<span class="comment">//这里比较的是指针，注意。永远是错误</span></div><div class="line">pair&lt;v_pint::iterator, v_pint::iterator&gt; it = <span class="built_in">std</span>::mismatch(auto_pt.begin(), auto_pt.end(), auto_p-&gt;begin());<span class="comment">//第一个是auto_pt第二个是auto_p</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//干脆下面开写各种函数</span></div><div class="line"><span class="keyword">struct</span> dd</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> d_;</div><div class="line">	<span class="keyword">int</span> a_;</div><div class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> dd&amp; d) &#123; </div><div class="line">		<span class="keyword">if</span> (d.a_ == a_ &amp;&amp; d.d_ == d_) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>; </div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">bequal</span><span class="params">(dd*&amp; d1, dd*&amp; d2)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (d1-&gt;a_==d2-&gt;a_&amp;&amp;d1-&gt;d_==d2-&gt;d_) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">static</span> dd* <span class="title">copydata</span><span class="params">(dd* p)</span> </span>&#123;</div><div class="line">		dd* rp = <span class="keyword">new</span> dd;</div><div class="line">		rp-&gt;a_ = p-&gt;a_;</div><div class="line">		rp-&gt;d_ = p-&gt;d_;</div><div class="line">		<span class="keyword">return</span> rp;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> RemoveTranData :</div><div class="line">	<span class="keyword">public</span> <span class="built_in">std</span>::binary_function&lt;T*&amp;, T* , <span class="keyword">void</span>&gt;</div><div class="line">&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(T*&amp; p, T*)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (*T == *p) &#123;</div><div class="line">			DEL_P(p);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> RemoveAllTranData :</div><div class="line">	<span class="keyword">public</span> <span class="built_in">std</span>::unary_function&lt;T*, <span class="keyword">void</span>&gt;</div><div class="line">&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(T* p)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</div><div class="line">			<span class="keyword">delete</span> p;</div><div class="line">			p = <span class="literal">NULL</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="number">_</span>tmain(<span class="keyword">int</span> argc, <span class="number">_</span>TCHAR* argv[])</div><div class="line">&#123;</div><div class="line">	<span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;dd*&gt; v_pint;</div><div class="line">	v_pint v_int;</div><div class="line">	v_int.push_back(<span class="keyword">new</span> dd&#123;<span class="number">2</span>,<span class="number">3</span>&#125;);</div><div class="line">	v_int.push_back(<span class="keyword">new</span> dd&#123;<span class="number">3</span>,<span class="number">4</span>&#125;);</div><div class="line">	v_int.push_back(<span class="keyword">new</span> dd&#123;<span class="number">4</span>,<span class="number">5</span>&#125;);</div><div class="line">	v_int.push_back(<span class="keyword">new</span> dd&#123;<span class="number">6</span>,<span class="number">7</span>&#125;);</div><div class="line"></div><div class="line">	dd* pt = <span class="keyword">new</span> dd&#123; <span class="number">6</span>, <span class="number">7</span> &#125;;</div><div class="line">	v_pint::iterator i = find_if(v_int.begin(), v_int.end(), bind2nd(mem_fun(&amp;dd::<span class="keyword">operator</span>==), *pt));<span class="comment">//指针的find</span></div><div class="line">	<span class="keyword">bool</span> b = <span class="built_in">std</span>::equal(v_int.begin(), v_int.end(), v_int2.begin(), (&amp;dd::bequal));<span class="comment">//指针的比较equl，最好更新成成员函数，待修改吧</span></div><div class="line">	</div><div class="line">	v_int3.resize(v_int2.size());<span class="comment">//注意这里哟</span></div><div class="line">	<span class="built_in">std</span>::transform(v_int2.begin(), v_int2.end(), v_int3.begin(), (&amp;dd::copydata));<span class="comment">//指针的复制， 想用上面find那种类型来着，发现复制错误了！！！&lt;/br&gt;</span></div><div class="line">	<span class="comment">//值得一提的是stl虽然有copy，但是却对容器指针依旧只是指针的赋值；而且使用前必须用resize来分配大小后再使用。</span></div><div class="line">	<span class="comment">//copy_if却是c++11的东西了要配合lamda了；copy_if(arr.begin(), arr.end(), back_inserter(res)//res.begin(),[](const int i) &#123; return i == 5 || i == 7; &#125;);</span></div><div class="line">	<span class="comment">//copy_backward是copy的逆向复制</span></div><div class="line"></div><div class="line">	for_each(<span class="number">_</span>doorVec.begin(), <span class="number">_</span>doorVec.end(), mem_fun_ref(&amp;Door::open));<span class="comment">//留个思想,以后封装用</span></div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p><strong>2</strong></p>
<figure class="highlight c"><figcaption><span>后面就给点有用的东东++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> forwardItr,<span class="keyword">class</span> Type&gt;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace</span><span class="params">(forwardItr first, forwardItr last,<span class="keyword">const</span> Type&amp; oldValue <span class="keyword">const</span> Type&amp; newValue)</span></span>;  </div><div class="line">  </div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> forwardItr, <span class="keyword">class</span> unaryPredicate,<span class="keyword">class</span> Type&gt;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace_if</span><span class="params">(forwardItr first, forwardItr last, unaryPredicate op,<span class="keyword">const</span> Type&amp; newValue)</span></span>;  </div><div class="line">  </div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> inputItr,<span class="keyword">class</span> outputItr,<span class="keyword">class</span> Type&gt;  </div><div class="line"><span class="function">outputItr <span class="title">replace_copy</span><span class="params">(inputItr first1, inputItr last1, outputItr destFirst,<span class="keyword">const</span> Type&amp; oldValue, <span class="keyword">const</span> Type&amp; newValue)</span></span>;  </div><div class="line">  </div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> inputItr,<span class="keyword">class</span> outputItr, <span class="keyword">class</span> unaryPredicate&gt;  </div><div class="line"><span class="function">outputItr <span class="title">replace_copy_if</span><span class="params">(inputItr first1, inputItr last1, outputItr destFirst, unaryPredicate op,<span class="keyword">const</span> Type&amp; newValue)</span></span>;  </div><div class="line"></div></pre></td></tr></table></figure>
<p><strong>3</strong></p>
<blockquote>
<p>首先可供查找的算法大致有count,find,binary_search,lower_bound,upper_bound,equal_range。带有判别式的如count_if,find_if或者binary_search的派别式版本，其用法大致相同</p>
</blockquote>
<p><strong>4</strong></p>
<p>参考：<a href="http://blog.csdn.net/sdhongjun/article/details/4517325/" target="_blank" rel="external">http://blog.csdn.net/sdhongjun/article/details/4517325/</a></p>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//stdext::hash_map等都比map高效多了</span></div><div class="line"><span class="keyword">struct</span> less: <span class="keyword">public</span> binary_funtion&lt;<span class="keyword">const</span> <span class="keyword">char</span>, <span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">bool</span>&gt;</div><div class="line">&#123;</div><div class="line">	<span class="function">result_type <span class="title">opeator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> first_argument_type&amp; <span class="number">_l</span>eft, <span class="keyword">const</span> second_argument_type <span class="number">_</span>right)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> (<span class="number">_</span>wcsicmp(left, right) &lt; <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>);</div><div class="line">	&#125;</div><div class="line">&#125;<span class="comment">//简直太装逼了，result_type first_argument_type second_argument_type。悬浮一看，就特么是前面 const char* bool，只是被内部转换了一些。。。。真装逼。。。。</span></div><div class="line"><span class="comment">//这个是hash_map的比较，因为键不能默认字符，必须自己写比较。</span></div><div class="line">stdext::hash_map&lt;cstring, TDATA1, stdext::hash_compare&lt;<span class="keyword">const</span> <span class="keyword">whcar_t</span>*, less&gt;&gt;</div><div class="line"><span class="comment">//参考 </span></div><div class="line"></div></pre></td></tr></table></figure>
<p><strong>5</strong></p>
<blockquote>
<p>参考来自：stackoverflow :c++ unordered_map using a custom class type as the key</p>
</blockquote>
<pre><code>//std::tr1::unordered_map无序的高效map，貌似虐爆hash_map和map
//boost却要写个hash_value
struct KeyHasher
{
    std::size_t operator()(const CString&amp; k) const
    {
        retrun (hash&lt;wstring&gt;()(k.GetString()));
    }
}
</code></pre><p><strong>6</strong></p>
<p>151对stl所有map和mfc的map做了比较，请看链接</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java学习(145)]]></title>
      <url>https://xuecat.github.io/2015/11/05/145/</url>
      <content type="html"><![CDATA[<p> 1.Java保存的文件名必须与类名一致；<br><br> 2.如果文件中只有一个类，文件名必须与类名一致；<br><br> 3.一个Java文件中只能有一个public类；<br><br> 4.如果文件中不止一个类，文件名必须与public类名一致；<br><br> 5.如果文件中不止一个类，而且没有public类，文件名可与任一类名一致。<br></p>
<p>protected：自身，子类及同一个包中类可以访问。相比c++倒是多了个，访问路径。<br><br>default（默认）：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。c++默认是protected吧，但是也分编译器。<br></p>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><blockquote>
<ul>
<li><p>android:gravity　属性是对该view中内容的限定．比如一个button 上面的text. 你可以设置该text 相对于view的靠左，靠右等位置．<br><br>android:layout_gravity是用来设置该view相对与父view 的位置．比如一个button 在linearlayout里，你想把该button放在linearlayout里靠左、靠右等位置就可以通过该属性设置．</p>
</li>
<li><p>dip: device independent pixels(设备独立像素). 不同设备有不同的显示效果,这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA 推荐使用这个，不依赖像素。<br><br>dp: dip是一样的<br><br>px: pixels(像素). 不同设备显示效果相同，一般我们HVGA代表320x480像素，这个用的比较多。<br><br>pt: point，是一个标准的长度单位，1pt＝1/72英寸，用于印刷业，非常简单易用；<br><br>sp: scaled pixels(放大像素). 主要用于字体显示best for textsize。 </p>
</li>
</ul>
</blockquote>
<h2 id="eclipse"><a href="#eclipse" class="headerlink" title="eclipse"></a>eclipse<br></h2><blockquote>
<p>中断debug，的在左上的debug窗口，选择总进程，再点击红色的中断。<br><br>修改重启的话一定要在java页面点击重启，在xml页面点击重启会不动，跑都不跑。<br></p>
</blockquote>
<h2 id="仅下twicetest"><a href="#仅下twicetest" class="headerlink" title="仅下twicetest"></a>仅下twicetest<br></h2><blockquote>
<p>左上是一个activebar</p>
<p>先走main的oncreate，main里面新建NavigationDrawerFragment，所以就走NavigationDrawerFragment的oncreate，oncreateview，添加menu，item等布局。<br>main就获取title，把title设置到activebar里面去<br><br>程序先加载activemain，里面有FrameLayout和fragment<br>实在不明白前者为何没有，后者就是那个NavigationDrawerFragment的界面。？？？？？？？？？？<br><br>main会在ondrawn里面建立fragment_main，Navigatfragment会在每次点击时显示，俩个布局平分了整个屏幕。</p>
</blockquote>
<h2 id="回调和监听"><a href="#回调和监听" class="headerlink" title="回调和监听"></a>回调和监听</h2><blockquote>
<p>内部监听、外部监听、activity监听、匿名监听（直接new就开写的那个）<br><br>xml定义监听函数</p>
<p>回调函数<br>先调用事件监听器-&gt;对应控件回调方法-&gt;activity对应的回调方法。（如果其中有一个返回false就终止）</p>
</blockquote>
<h2 id="target-sdk-compile-sdk"><a href="#target-sdk-compile-sdk" class="headerlink" title="target sdk compile sdk"></a>target sdk compile sdk</h2><p>v7是5.0以后才有的，所以，compile sdk注意用23(因为我sdk manager里面5.0以后只有23)。不然会资源错误，报r的错误,对了不需要v7支持记住要mini sdk&gt;=14<br></p>
<blockquote>
<p>targetSdkVersion相对复杂一些，如果设置了此属性，那么在程序执行时，如果目标设备的API版本正好等于此数值，他会告诉Android平台：此程序在此版本已经经过充分测，没有问题。不必为此程序开启兼容性检查判断的工作了。也就是说，如果targetSdkVersion与目标设备的API版本相同时，运行效率可能会高一些。</p>
<p>但是，这个设置仅仅是一个声明、一个通知，不会有太实质的作用，比如说，使用了targetSdkVersion这个SDK版本中的一个特性，但是这个特性在低版本中是不支持的，那么在低版本的API设备上运行程序时，可能会报错：java.lang.VerifyError。也就是说，此属性不会帮你解决兼容性的测试问题。你至少需要在minSdkVersion这个版本上将程序完整的跑一遍来确定兼容性是没有问题的。(这个问题确实让人头疼)</p>
<p>在default.properties中的target是指在编译的时候使用哪个版本的API进行编译。</p>
<p>综上，上面的四个值其实是作用于不同的时期：<br>target API level是在编译的时候起作用，用于指定使用哪个API版本(SDK版本)进行编译。<br>minSdkVersion和maxSdkVersion是在程序安装的时候起作用，用于指定哪些版本的设备可以安装此应用。<br>targetSdkVersion是在程序运行的时候起作用，用于提高指定版本的设备上程序运行体验。</p>
<p>这四个数值在程序编译时也没有严格的检查，比如说，你可以将minSdkVersion设置的比maxSdkVersion还大，他会自动忽略掉错误的maxSdkVersion。</p>
<p>但是在Ubuntu下，用Android studio就不存在这些问题，target和source会被一起默认设置为当前platform。</p>
</blockquote>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>   默认情况下Handler会与其被定义时所在线程的Looper绑定，比如，Handler在主线程中定义，那么它是与主线程的Looper绑定。 mainHandler = new Handler() 等价于new Handler（Looper.myLooper()）. Looper.myLooper()：获取当前进程的looper对象，类似的 Looper.getMainLooper() 用于获取主线程的Looper对象。<br><br> 所以handler一开始就被绑定了。变定义就好了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[模板错误（144）]]></title>
      <url>https://xuecat.github.io/2015/11/04/144/</url>
      <content type="html"><![CDATA[<p>  呵呵，写了好久，模板错误。我特么真傻逼。<br>模板是要假设每种情况都要生成的，用个if然后就指向成员。唉！！！！错误哎呀！！！！</p>
<p>以后，结构体，数量不等，类型不同；打死都不想用模板了<br>搞得最后没法弄成这样</p>
<pre><code>static T* createdata(int n1, int n2, int n3, int ncount, va_list args) {
    /*
     *    调试赋值是否完全正确；有无空符号
     */
    T* p = new T;
    if (ncount == 1) {
        changewatchdata((PWATCH_PROCESS_INFORMATION)p, n1, n2, n3, 0, ncount, args);
    }
    else {
        changeconfigdata((PConfigData)p, n1, n2, n3, 0, ncount, args);
    }
    return p;
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++内存区域分配和段寄存器的理解（143）]]></title>
      <url>https://xuecat.github.io/2015/11/03/143/</url>
      <content type="html"><![CDATA[<p>  <em>些许没玩却也遗忘些了，有空就归纳下吧。</em></p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p><strong>附加段ES extra segment</strong></p>
<p><strong>数据段DS data segment</strong>-&gt;普遍说法是和ES 偏移量配合使用，来对数据的读取进行操作</p>
<p><strong>代码段CS code segment</strong>-&gt;IP下一指令偏移量配合使用</p>
<p><strong>堆栈段SS stack segment</strong>-&gt;SP BP；SS记录段通过SP BP来具体压栈;压人SP，压入参数SP随之移动,压人返回值，压入常用寄存器（以上便是堆栈段的压入）;压入BP，SP对其MOV,压入局部变量SP动,SP返回，BP POP(以上便是二进制代码)。 SP为了永远在栈顶只要有压入它就减去相应，BP访问用的</p>
<p><strong>全局段GS global segment</strong></p>
<p><strong>标志段FS flag segment</strong> 这两个stackoverflower给的解释是：多线程TLS等用的，就是系统级的全局结构体</p>
<h2 id="c-程序内存"><a href="#c-程序内存" class="headerlink" title="c++程序内存"></a>c++程序内存</h2><p>也是那些自以的规划罢了，PE文件也确实有描述。实际的访问和执行却要依靠上面的寄存器。</p>
<p>1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于<br>数据结构中的栈。</p>
<p>2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与<br>数据结构中的堆是两回事，分配方式倒是类似于链表，</p>
<p>3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静<br>态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有<br>系统释放</p>
<p>4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放</p>
<p>5、程序代码区—存放函数体的二进制代码。</p>
<h2 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h2><p><strong>dos头</strong>，看的迷迷糊糊的，倒是第一个结构如果是MZ表示所以dos可执行并兼容</p>
<p><strong>PE头</strong> 通过dos头最后一个域用NTSIGNATURE来得到目标系统标志（MZ NE ：win 16； LE win 32）</p>
<p>IMAGE_SIZEOF_FILE_HEADER<br>第一个域：目标机器，表示程序被构建的机器种类<br>是否调试版本<br>段实体和大小，方便提前文件大小。</p>
<p><strong>PE可选段</strong><br>初始堆栈大小，程序入口位置，操作系统版本，段对齐等。<br>SizeOfCode可执行代码大小<br>SizeOfInitializedData已初始化数据大小<br>SizeOfUninitializedData未初始化数据大小<br>AddressOfEntryPoint程序入口地址</p>
<p><strong>可选段和段体</strong></p>
<p><strong>预定义段</strong>：windows NT有9个段，一些程序当然不需要这么多，有的还有特殊段等，所以定义上，表示可用。</p>
<p><strong>可执行代码段</strong>：.text<br><br><strong>数据段</strong><br>.bss程序未初始化数据，包括所有函数或源模块中声明为static的变量<br>.rdata段表示只读数据，比如字符串文字量、常量和调试目录信息。<br>.data其它变量，出现在栈上的自动变量，和全局变量。<br><strong>资源段</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GOOGLE LOG学习(140)]]></title>
      <url>https://xuecat.github.io/2015/11/03/140/</url>
      <content type="html"><![CDATA[<figure class="highlight"><figcaption><span>今日空闲，却也看了下protocolbuffer的代码，发现一个google log模块很有意思，记录下来++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">DECLARE_STREAM_OPERATOR(char         , "%c" )</div><div class="line">DECLARE_STREAM_OPERATOR(int          , "%d" )</div><div class="line">DECLARE_STREAM_OPERATOR(uint         , "%u" )</div><div class="line">DECLARE_STREAM_OPERATOR(long         , "%ld")</div><div class="line">DECLARE_STREAM_OPERATOR(unsigned long, "%lu")</div><div class="line">DECLARE_STREAM_OPERATOR(double       , "%g" )</div><div class="line">common.cc 173</div><div class="line"></div><div class="line">#define GOOGLE_LOG(LEVEL)                                                 \有等级，警告，错误，严重等</div><div class="line">  ::google::protobuf::internal::LogFinisher() =                           \</div><div class="line">    ::google::protobuf::internal::LogMessage(                             \</div><div class="line">      ::google::protobuf::LOGLEVEL_##LEVEL, __FILE__, __LINE__)</div><div class="line">#define GOOGLE_LOG_IF(LEVEL, CONDITION) \</div><div class="line">  !(CONDITION) ? (void)0 : GOOGLE_LOG(LEVEL)</div><div class="line"></div><div class="line">#define GOOGLE_CHECK(EXPRESSION) \</div><div class="line">  GOOGLE_LOG_IF(FATAL, !(EXPRESSION)) &lt;&lt; "CHECK failed: " #EXPRESSION ": "</div><div class="line">//////////////////////////////////在下的示例代码///////////////////////////</div><div class="line">	struct dd</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	dd(string a)&#123;</div><div class="line">		m_ = a;</div><div class="line">		cout &lt;&lt; a&lt;&lt;endl;</div><div class="line">	&#125;;~dd()&#123;</div><div class="line">		cout&lt;&lt; "is end:,,,,,,,,,,"&lt;&lt;endl;</div><div class="line">		cout &lt;&lt; m_&lt;&lt;endl&lt;&lt;d_&lt;&lt;endl;</div><div class="line">	&#125;;</div><div class="line">	dd&amp;	operator&lt;&lt; (string d)&#123;</div><div class="line">		d_ = d;</div><div class="line">		cout &lt;&lt;m_&lt;&lt;endl&lt;&lt; d&lt;&lt;endl;</div><div class="line">		return *this;</div><div class="line">	&#125;</div><div class="line">protected:</div><div class="line">	string m_;</div><div class="line">	string d_;</div><div class="line">private:</div><div class="line">&#125;;</div><div class="line">#define LEVEL_ERROR "error"</div><div class="line">#define ERROR</div><div class="line">#define HP(a) dd(LEVEL_##b)</div><div class="line">#define AH(a, b) a ? (void)0:dd(LEVEL_##b) //只是这里若再取一遍宏，便出错了；确实宏嵌套太多了。</div><div class="line">#define A(c) AH(c&gt;0, ERROR) &lt;&lt; "hehe"</div><div class="line"></div></pre></td></tr></table></figure>
<p>如此log，在函数中使用，当然google封装了更多的东西，比如checklog呀。在构造上记录基本信息，operator上记录tips，析构里进行log文件写入。很好</p>
<pre><code>#define DO(STATEMENT) if (STATEMENT) {} else return false   这个宏。。。差点忘了，这个宏也是非常优秀的
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[WIN7编程(141)]]></title>
      <url>https://xuecat.github.io/2015/11/01/141/</url>
      <content type="html"><![CDATA[<p>  win7编程 <a href="http://blog.csdn.net/ntwilford/article/category/691694" target="_blank" rel="external">http://blog.csdn.net/ntwilford/article/category/691694</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[sobey mfc(139)]]></title>
      <url>https://xuecat.github.io/2015/10/19/139/</url>
      <content type="html"><![CDATA[<p>   不解释，已经<em>*到这种地步了，天天让我写mfc。。。。。想</em>的心都有了。。。。。<br><br>下面说下过程中的事吧</p>
<p>listctrl：</p>
<p>感觉是坑货，要是duilib我特么早就自己写了，不用它的。</p>
<p>1、添加LVS_EX_CHECKBOXES属性，居然默认只能是第一列才能有。。我去。。。<br><br>用下面代码，把内部的链表换了，第一行后最后二行对换来达到其他列显示的效果。</p>
<pre><code>CHeaderCtrl* pHeaderCtrl = m_lt_ShowProgram.GetHeaderCtrl();
INT nCount = pHeaderCtrl-&gt;GetItemCount();
LPINT pOder = (LPINT)malloc(nCount*sizeof(int));
pHeaderCtrl-&gt;GetOrderArray(pOder, nCount);
int nTemp = 0;
nTemp = pOder[0], pOder[0] = pOder[nCount - 2], pOder[nCount - 2] = nTemp;
pHeaderCtrl-&gt;SetOrderArray(nCount, pOder);
free(pOder);
</code></pre><p>2、还是问题，添加图片，你妹第一列老是默认必须添加图片。要想添加到其他列，还必须先添加第一列。晕！！！</p>
<pre><code>ncount = m_lt_ShowProgram.InsertItem(ncount, _T(&quot;&quot;), -1);//后来发现-1就插入空的图片。还行效果。\
</code></pre><p>3、遇见这个问题，反正愁死我了，winhand.cpp 218，，以后记住Object的操作，create要delete，get要release</p>
<p>4、enumwindow这个函数会一直循环遍历，唉！！ 后来发现直接return false后，msdn说这是一个错误返回，好吧，弄成错误返回就立马结束了。</p>
<p>5、一直在纠结变长参数传递，居然用参数va_list 宏用<strong>va_args</strong></p>
<p>6、容器指针简直是个坑，操作一切全是指针；写着写着就忘了，不解释。太坑了</p>
<p>7、switch case可以用tab缩进来达到效果，更本不用括号来。感觉这样倒是美观了。</p>
<p>8、#pragma component(browser, off, references, “ASSERT”)</p>
<p>9、</p>
<pre><code>class property {
public:
    int m_a;
public:
    __declspec(property(get = GetA, put = SetA)) int x;

    int SetA(int x) {
        m_a = x;
        return x;
    }
    int GetA() {
        return m_a;
    }
};
//如此会导致property多拥有一个x的成员属性。
//这种就是把 x 和那俩个函数关联，关联方式就是get、put
//int a = property_class.x,就是get方式，调用GetA，property_class.x=a；就是put方式，调用SetA。
</code></pre><p>10、__declspec(novtable) 只能修饰类等结构。无法修饰函数，表示此类，不用产生虚函数列表，声明的函数却全是虚函数。意思就是，我就是专门为了继承的虚基类，我不用产生多余的空间容纳虚列表，因为实现全在子类。</p>
<p>11、MSVC的关键字__super  和java一样表示父类。</p>
<p>12、今天发现listctrl有个 LVN_BEGINDRAG的一个消息。。也就是说在消息映射里<br>ON_NOTIFY(LVN_BEGINDRAG, IDC_LIST, OnBegindragFilelist)就会自动响应拖拽的事件。以前居然还自己写。。亏了。。。。。</p>
<p>13、以前写MFC的DLL的时候，总会在自动生成的代码框架里看到提示，需要在每一个输出的函数开始添加上AFX_MANAGE_STATE(AfxGetStaticModuleState())<br>切换，今天就遇见了，天的，公司老员工写的皮肤库太坑了。</p>
<p>14、</p>
<pre><code>HBITMAP hbit;
BITMAP bit;
::GetObject(hbit, sizeof(BITMAP), &amp;bit);//如此可以得到bitmap的图片大小

//CImageList需要先create在add，最后俩个参数，是开辟容纳大小，空间增长系数（不够了，扩容开辟多少个）
</code></pre><p>15、<br>基类虚函数，真心里面的成员变量要保证是protected，；<br>不然别人一拿来用，一下就呵呵了。</p>
<p>16、 SetMargins这个edit的控件，嘿嘿，设置左上角用的，加其他图片用的。</p>
<p>17、</p>
<p>我也是醉了，cedit控件必须设置顶层。不然上面16，你设置后重绘就没得玩。还有多行要设置<br>wndBottom：设置为底层窗口；<br>wndTop：设置顶层窗口；<br>wndTopMost：设置为最顶层窗口；<br>wndNoTopMost：设置为仅次于最顶层窗口</p>
<p>18、</p>
<p>来自：<a href="http://blog.csdn.net/lishuhuakai/article/details/18467255" target="_blank" rel="external">http://blog.csdn.net/lishuhuakai/article/details/18467255</a></p>
<p>(1)<br>CRect rect(0, 0, 200, 200);<br>dc.rectangle(rect);<br>上面的语句在屏幕的最左上角绘制一个正方形;(因为此时逻辑坐标与设备坐标没有偏移)</p>
<p>(2)<br>dc.SetViewportOrg(100, 100);<br>CRect rect(0, 0, 200, 200);<br>dc.rectangle(rect);<br>将设备坐标的原点设置到(100, 100)；即设备坐标的原点不在(0, 0)处，而是在(100, 100)处；此时若执行映射的话，逻辑坐标的原点(0, 0)需要与设备坐标的原点(100, 100)重合(参考前提5)；那么此时绘制的矩形(0, 0, 200, 200)的坐标(为逻辑坐标，参考前提1)在设备坐标中就会映射为(100, 100, 300, 300)，最终我们在显示器上看到的会是一个向右下方偏移(100, 100)的一个边长为200的正方形(用户看到的点是在设备坐标中的，参考前提2)</p>
<p>(3)<br>dc.SetWindowOrg(100, 100);<br>CRect rect(0, 0, 200, 200);<br>dc.rectangle(rect);<br>将逻辑坐标的原点设置到(100, 100)；即逻辑坐标的原点不在(0, 0)处，而是在(100, 100)处；此时若执行映射的话，设备坐标的原点(0, 0)需要与逻辑坐标的原点(100, 100)重合(参考前提5)；那么此时绘制的矩形(0, 0, 200, 200)的坐标(为逻辑坐标，参考前提1)在设备坐标中就会映射为(-100, -100, 100, 100)，最终我们在显示器上看到的会是一个只有1/4个大小的矩形的一部分(事实上相当于向左上方偏移(100, 100)的一个边长为200的正方形。</p>
<p>19、<br>CImageList要先Create再add才能成功<br>pImgeList -&gt;Create(rtItem.Width(), rtItem.Height(),ILC_COLORDDB|ILC_MASK,0,1);个数，递增个数<br>    pImgeList-&gt;Add(pbitmapt, TP_GetSysColor(COLOR_MODULE_LISTCTRL_ICONEDGE));</p>
<p>20、</p>
<p>给个拖拽的网址：</p>
<p><a href="http://blog.csdn.net/xianglitian/article/details/6023656" target="_blank" rel="external">http://blog.csdn.net/xianglitian/article/details/6023656</a></p>
<p><a href="http://www.codeguru.com/cpp/controls/treeview/dragdrop/article.php/c707/Drag-and-drop.htm" target="_blank" rel="external">http://www.codeguru.com/cpp/controls/treeview/dragdrop/article.php/c707/Drag-and-drop.htm</a></p>
<p>21、</p>
<p>CDockablePane和CPaneFrameWnd和CMFCCaptionButton，对了，这些是有源码的哟！！！嘿嘿</p>
<p>可以做出很多风格界面来。别忘了SetMiniFrameRTC(自定义::GetThisClass);</p>
<pre><code>afxvisualmanagerofficexp.cpp 147动态获取颜色，创建brush
LOGBRUSH br
pBrush-&gt;GetLogBrush(&amp;br);
CDrawingManager dm(*pDC);
dm.DrawRect(rect, br.lbColor, (COLORREF)-1);//这个是微软的caption按钮默认覆盖后图，因为很好看，保存了,
</code></pre><p>22、</p>
<p>3个消息分别是：WM_SIZE、WM_SIZING、WM_GETMINMAXINFO；分别对应相应的处理函数：OnSize、OnSizing、OnGetMinMaxInfo。</p>
<p>当窗口大小发生变化时，响应的顺序依次是：WM_GETMINMAXINFO–&gt;WM_SIZING–&gt;WM_SIZE</p>
<p>口初始化的时候会被调用一次-&gt;窗口大小发生变化时被调用-&gt;窗口大小改变结束后被调用，通常会在这个函数里重新摆放各个控件的位置及大小</p>
<p>23、</p>
<p>单文档和多文档。中间的view不同，dockpane窗口级别不同。具体细节很多，讲不清，今天代码可是坑苦了。</p>
<p>24、重新生成的项目老是清理其它项目的文件，看了下是中间文件目录的问题，改了就好</p>
<p>25、WM_MENUCHAR消息。在menu进行热键时，这个消息专门给父窗口来传递给menu（从返回值）。</p>
<p>26、CreateProcess，用来开辟新进程的时候。新进程的资源目录会优先寻找父目录（就是代码程序的目录）。为了避免这个情况倒数第三个参数可以专门用来设置。</p>
<p>27、pretranslatemessage这个是消息预处理函数。对于dll来说它的消息是依赖exe的，所以dll是没有这个函数的响应。这个函数的返回值0是消息下发，1是消息不下发。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Createprocess等其他内核函数(138)]]></title>
      <url>https://xuecat.github.io/2015/10/15/138/</url>
      <content type="html"><![CDATA[<p>  CreateProcessTaken 创建其他用户进程，好像可以创建管理员的进程<br><br>  CreateProcessAsUser 创建指定用户进程<br><br>  CreateProcess 创建默认用户进程，好像默认是当前进程用户。<br><br><br><br>  DuplicateHandle </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[错误认识（137）]]></title>
      <url>https://xuecat.github.io/2015/10/14/137/</url>
      <content type="html"><![CDATA[<p>   for循环千万不要</p>
<pre><code>for (int i = 0; i &lt; a.size(); i++)
{
    a.erase();
}
//每次for就减少一次，妈的。是个错误的表示方式。

//应该先赋值n = a.size()；再来for循环。以后一定要当习惯。。。
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Webkit编译（136）]]></title>
      <url>https://xuecat.github.io/2015/10/10/136/</url>
      <content type="html"><![CDATA[<p>  无语了，编译webkit简直无语了。</p>
<p>  先说cygwin的编译方式。最好用库自带的cygwin-download来下载安装cygwin（Python执行）。</p>
<p>  再说perl的问题，老是加载错误模块（郁闷死了）。perl -MCPAN -e’install “LWP::Simple”‘可以解决。</p>
<p>   还有个常识，，哎呀。。。4之后的版本编译基本都很好了，只是Windows的编译是非常依赖编译器的版本。所以必须要下vs编译器能跑的webkit版本才可以。</p>
<p>   在安装perl和配合版的cygwin的时候，对webkit版本很是严格。所以，你安装了某个版本后，想安装另一个版本的很是困难，后面update简直没法进行。<br><br>   所以建议，虚拟机上跑，编译。给个快照后又可以跑其它版本的webkit了。</p>
<p>   最后一个建议吧，update后。现在项目已经可以找到windows下能需要的所以库了。但是，如果用vs直接去编译的话，依旧是错误不断。<br>所以建议用控制台敲指令来编译。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[内核函数（135）]]></title>
      <url>https://xuecat.github.io/2015/10/09/135/</url>
      <content type="html"><![CDATA[<pre><code>//今天看了下定时内核对象

//先创建内核对象（未触发状态）
HANDLE hTimer = CreateWaitableTimer(NULL, TRUE, NULL);
BOOL WINAPI SetWaitableTimer(htimer, pduetime,lperiod, pfncompletionroutine, lpargtocompletionroutine, fresume);
//使用APC回调来处理定时器对象触发事件
//我想这就是原始的api函数吧。
//不能用WaitForSingleObjectEx来设置等待
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[限定域基础知识（134）]]></title>
      <url>https://xuecat.github.io/2015/09/23/134/</url>
      <content type="html"><![CDATA[<figure class="highlight c"><figcaption><span>结构填充++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">struct</span> &#123;<span class="keyword">int</span> a; <span class="keyword">int</span> b; <span class="keyword">int</span> c;&#125; d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</div><div class="line"><span class="keyword">int</span> b[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</div><div class="line"><span class="comment">//默认填充用的是0，所以剩下的全是0；</span></div><div class="line"></div><div class="line">**<span class="keyword">sizeof</span>数组**</div><div class="line"></div><div class="line"><span class="keyword">char</span> p[] = <span class="string">"asdf"</span>;<span class="keyword">sizeof</span>(p);结果是<span class="number">5</span>，要多个空的结尾符号。</div><div class="line"></div><div class="line">**<span class="keyword">static</span>重复**</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> d = <span class="number">1</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> d = <span class="number">12</span>;</div><div class="line">	d += i;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; d;</div><div class="line"><span class="comment">//	d的结果是1，可以看出和限定域有关。。。</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> d = <span class="number">4</span>;</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> d = <span class="number">3</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; d;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span>  &lt;&lt;d;<span class="comment">//一样的道理， 限定域的限制，结果不同；</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> (<span class="number">0</span> == number++) &#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"ok"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;<span class="comment">//一样和限定域有关，number虽是个static，但只能让fun访问。也正因为是static，所以每次遍历一定会++number值。做个唯一的东东。。</span></div><div class="line"></div><div class="line">	</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Unicode编码(133)]]></title>
      <url>https://xuecat.github.io/2015/09/02/133/</url>
      <content type="html"><![CDATA[<blockquote>
<blockquote>
<p>心血来潮，想了个问题，并测试了下。</p>
</blockquote>
</blockquote>
<p><em>预备知识</em></p>
<p>Unicode是字符集合ascii相对，，编码指的是utf8 utf16 utf32 gb3121（历史等相关都了解了，就不说了）。操作系统中windows是utf16，Linux mac是utf8</p>
<p><strong>说明</strong><br><br>第一，，我认为wchar_t只是指字符集，指的是这种字符串是用Unicode的字符集。在编译的时候再按照编码翻译。</p>
<p>第二，，问题描述，先说个沾边的情况Linux和Windows的换行符问题，这个也引出到了git里面的知识，李纳斯的自动换行符转换是个坑。<br>由于编码的不同导致传输中文字符的出错，一般网络传输用unsigned char或者char（wchar大了） ，数据传输过去如果两个的源文件不是同一种编码格式，必定出现乱码（中文情况）</p>
<pre><code>mbrtowc//msvc貌似只有这个函数支持
std::codecvt&lt;char, char, std::mbstate_t&gt;
std::codecvt&lt;char16_t, char, std::mbstate_t&gt;
std::codecvt&lt;char32_t, char, std::mbstate_t&gt;
std::codecvt&lt;wchar_t, char, std::mbstate_t&gt;
codecvt_utf8   codecvt_utf16  codecvt_utf8_utf16  wstring_convert配合转换    
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[11右值引用下的移动构造(132)]]></title>
      <url>https://xuecat.github.io/2015/09/01/132/</url>
      <content type="html"><![CDATA[<figure class="highlight c"><figcaption><span>先看代码++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> HasPem &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	HasPem() : d(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>)) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"construct:"</span> &lt;&lt; ++n_cstr &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">	HasPem(<span class="keyword">const</span> HasPem&amp; h) : d(<span class="keyword">new</span> <span class="keyword">int</span>(*h.d))&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct:"</span> &lt;&lt; ++n_cptr &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">	HasPem(HasPem&amp;&amp; h) :d(h.d)&#123; h.d = <span class="literal">nullptr</span>; <span class="built_in">cout</span> &lt;&lt; <span class="string">"move construct:"</span> &lt;&lt; ++n_mvtr &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">	HasPem&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPem&amp; h) &#123; d = h.d; <span class="keyword">delete</span> h.d; <span class="built_in">cout</span> &lt;&lt; <span class="string">"deque construct:"</span> &lt;&lt; ++n_mvtr &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</div><div class="line">	~HasPem() &#123;</div><div class="line">		<span class="keyword">delete</span> d;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"destruct:"</span> &lt;&lt; ++n_dstr &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">int</span>* d;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> n_cstr;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> n_dstr;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> n_cptr;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> n_mvtr;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">int</span> HasPem::n_cstr = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> HasPem::n_dstr = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> HasPem::n_cptr = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> HasPem::n_mvtr = <span class="number">0</span>;</div><div class="line"><span class="function">HasPem <span class="title">getemp</span><span class="params">()</span> </span>&#123;</div><div class="line">	HasPem h;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"resource form"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> h;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> <span class="number">_</span>tmain(<span class="keyword">int</span> argc, <span class="number">_</span>TCHAR* argv[])</div><div class="line">&#123;</div><div class="line">	HasPem d = getemp();</div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>先说下自己的错误</em></strong></p>
<p>居然会忘：</p>
<pre><code>HasPem d;HasPem p = d;//这个调用的是复制函数；
HasPem d; HasPem p; d=p;//这个才是调用的赋值函数；
//也就是只要跟类初始化没关的才走赋值，其他就复制。
</code></pre><p><strong><em>再说下移动函数</em></strong></p>
<p>首先，移动构造函数是基于右值引用。<br>第一它是为了操作临时变量，（98里面，函数结束会对临时变量内存释放）。第二当出现减少复制函数带来的多余内存开辟。（当然如果用指针new就可以解决，但是对象可以自己释放内存）</p>
<p>然后，复制函数为了安全等考虑一般会开辟内存的复制。<br><br>当程序猿希望在复制的时候能走节约内存的移动函数路线时，就可以用std::move<br></p>
<pre><code>Moveable a; Moveable c(std::move(a));//这样c就完全是走a的移动路线得到的。
//但是依旧有内存问题，那就是a的成员改变，生命周期内的调用。
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[wdm接口过程中的错误(131)]]></title>
      <url>https://xuecat.github.io/2015/08/27/131/</url>
      <content type="html"><![CDATA[<blockquote>
<blockquote>
<p>先说windbag那个系统变量设置，<br></p>
</blockquote>
</blockquote>
<p><em>第一步 是从 <a href="http://www.microsoft.com/ddk/debugging" target="_blank" rel="external">http://www.microsoft.com/ddk/debugging</a> 下载最新版本的 WinDBG，因为符号服务器二进制文件是由 WinDBG 小组开发的。</em></p>
<p><em>您将需要检查是否有 WinDBG 更新版本，因为该小组似乎具有相当紧凑的发布日程安排，并且每隔几个月就会发布更新版本。</em></p>
<p><em>第二步 双击下载的文件安装 windbg .安装时注意记住安装到那里了.</em></p>
<p><em>第三步 windbg 访问符号需要两个文件(SYMSRV.DLL 和 SYMSTORE.EXE)所以添加主 path 环境变量中它们的路径进去,即:你的 windbg 安装目录.</em></p>
<p><em>操作方法:在桌面我的电脑点右键–属性–高级–环境变量,在系统变量列表框中找到 path 双击,在变量值最后面加一个分号再把你的安装目录写上.点确定.</em><br><em>这一步是告诉 windbg 那两个文件放在什么地方.</em></p>
<p><em>第四步 新建一个环境变量_NT_SYMBOL_PATH 值为: SRV</em>c:\mysymbol<em> <a href="http://msdl.microsoft.com/download/symbols" target="_blank" rel="external">http://msdl.microsoft.com/download/symbols</a></em> </p>
<p><em>操作方法:桌面我的电脑点右键–属性–高级–环境变量 ,点击新建,把上面的变量名和变量值填上.这一步的意思是说告诉 windbg ,我的符号文件存放在c:\mysymbol 中(当然其实里面什么也没有,甚至这个文件夹也不存在,不过没关系,系统找不到的话会给你创建一个,并在上面的网址中去帮你下载符号文件放在里面)</em></p>
<p><em>第五步 运行 windbg 打开一个exe文件或者附加到一个进程里去, 你会看到 Symbol search path is: SRV</em>c:\mysymbol<em> <a href="http://msdl.microsoft.com/download/symbols" target="_blank" rel="external">http://msdl.microsoft.com/download/symbols</a></em></p>
<blockquote>
<blockquote>
<p>再说ioregisterdeviceinterface接口的使用<br>书上说wdm一般用的是接口来访问驱动程序，一个驱动可以有多个设备（虚拟，实际），对于irp每个设备栈对应一个i/o栈。<br><br>wdm的adddevice的第二参数是顶层的设备栈吧（这个我在自定义的class安装后，貌似是空的）。<br><br>问题描述：1、没有ioattach，好像新建的自定义类就没有设备，导致读取驱动时失败的。2、没有ioregisterdeviceinterface注册adddevice的第二个参数，而是去注册自己创建的设备。也会导致注册失败。这个问题让我无法想明白，留上吧，以后解决。</p>
</blockquote>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[取反进阶(130)]]></title>
      <url>https://xuecat.github.io/2015/08/04/130/</url>
      <content type="html"><![CDATA[<p>先看图：<br>    <img src="/picture/img/130.png" alt=""></p>
<p>unsigned是无符号的，所以是正数。补码存储形式就是它本身。所以取反是那个。</p>
<p>其它的就同理了，用补码去取反。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[生活认识(129)]]></title>
      <url>https://xuecat.github.io/2015/07/04/129/</url>
      <content type="html"><![CDATA[<p>   <em>没有惊险和放纵。</em><br><br>   <em>没有<em>**</em>和期望。</em><br><br>   <em>更没有《大亨小传》苦涩的悲情，或许连《友情》单纯的被渴望着也不存在。</em><br><br>   <em>只是平淡、单调、无聊着。</em><br><br>   <em>就算这样，也不想重新来过。</em><br><br>   <em>我不想再看到那个懵懂的少年，也不想再体会坎坷的努力。</em><br><br>   <em>我害怕，，，害怕自己再走一遍原来的路。</em><br><br>   <em>即使是错误的，可以痛苦可以流泪，也绝不要后悔。这才是英雄！！！</em><br></p>
<p><br><br>   <em>闭上眼睛</em><br><br>   <em>宁人Identity crisis的事也是随处累积着</em><br><br>   <em>讨厌自己漠然、无知、虚伪以及趑趄嗫嚅；这些黏在身上的劣根性让我厌恶、憎恨到无以复加。</em><br><br>   <em>害怕被赤裸裸的揭露，觉得自己就像白羊群中那只最不协调的黑羊。</em><br><br>   <em>想通过训练压抑住自己的本质，害怕成为拉尔夫（《蝇王》），而努力的扮演着【人类】这个角色。</em><br><br>   <em>只是，，，契可尼效应</em><br><br>  （黑羊与白羊：无法跟同伴一起感到喜悦、一起悲伤、吃相同的食物，同伴内心的感动==爱情、温柔、体贴等情意都无法理解的悲伤的黑羊能做的事，就是对身上的黑皮撒上白粉，假装自己也是一只白羊。<br><br>    如果同伴知道我是一只地道的黑羊，会不会用羊角刺我？用羊蹄踩我？希望不会被暴露。<br><br>    每当雨滴打下来，每当风吹过来，撒在身上的白粉是不是会脱落？会不会有人大声说：“原来它是只黑羊”?）</p>
<p><br><br>   <em>回忆过去会让人后悔的想去死，展望未来又会让人担心得愁眉不展，同时又害怕自己原地回转、滞留不前。 多么矛盾！！</em><br><br>   <em>这让我想起了叶藏（《人间失格》）。太多的共同点让我每次阅读体内有一股像是胃都要绞起来似的羞耻感与耻辱感油然而生。</em><br><br>   <em>最终被磨损下的只是，只是逞强罢了。心灵深处丑恶着扭曲着，大概已经被切碎的破烂的垃圾的渣滓般的小小固执。</em><br><br>   <em>为了不否定自己的过去，行动；为了不否定信念，为了我的，仅属于我的小小固执。</em><br></p>
<p><br><br>   **<br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[函数命名规则（128）]]></title>
      <url>https://xuecat.github.io/2015/07/01/128/</url>
      <content type="html"><![CDATA[<p>  主要的前缀有：<br>Zw：Zw 和同名的 Nt 函数具有相同的功能，中间是从 Zw 到 Nt 函数的简单跳转。本系列内核函数用于文件和注册表方面的操作，比如文件操作、注册表操作、访问进程、事件操作、令牌操作、进程操作和端口操作等。</p>
<p>Ex：管理层，Ex 是 Executive 的开头两个字母。<br>Ke：核心层，Ke 是 Kernel 的开头两个字母。<br>Hal：硬件抽象层，Hal 是 Hardware Abstranction Layer 的缩写。<br>Ob：对象管理，Ob 是 Object 的开头两个字母。<br>Mm：内存管理，Mm 是 Memory Manager 的缩写。<br>Ps：进程（线程）管理，Ps 表示Process。<br>Se：安全管理，Se 是 Security 的开头两个字母。<br>Io：I/O管理。<br>Fs：文件系统，Fs 是 File System 的缩写。<br>Cc：文件缓存管理，Cc 表示 Cache。<br>Cm：系统配置管理，Cm 是 Configuration Manager 的缩写。<br>Pp：“即插即用”管理，Pp 表示 PnP。<br>Rtl：运行时程序库，Rtl 是 Runtime Library 的缩写。本系列内核函数用于运行时库，以Rtl为前缀的函数可以完成多种操作，例如字符串、线程、资源、临界区、安全对象的初始化和使用，内存、进程异常和数据类型的处理，还用于完成定时器、堆、IPv4和IPv6方面的操作，以及压缩和解压缩等。</p>
<p>Ndis：与NDIS网络驱动开发相关的函数。<br>Wdf：开发WDF驱动相关的函数都是以 Wdf 开头。<br>KiEtw：本系列内核函数用于系统内核，这些函数只能从内核的内部进行调用，常用的有：KiUserCallbackDispatcher、KiRaiseUserExceptionDispatcher、KiUserApcDispatcher、KiUserExceptionDispatcher等。</p>
<p>Csr系列：此系列函数用于客户机和服务器运行时，如果您想拦截客户机/服务器方面的操作，那么就需要对Csr系列内核函数做进一步的了解。常见的有：CsrClientCallServer、CsrCaptureMessageBuffer、CsrConnectClientToServer和CrsNewThread等。</p>
<p>Ldr系列：本系列内核函数用于加载程序管理器，如果你打算拦截加载程序的话，那么请进一步考察这组以Ldr为前缀的函数，常用的有：LdrInitializeThunk、LdrLockLoaderLock、LdrUnlockLoaderLock、LdrGetDllHandle、LdrGetProcedureAddress等。</p>
<p>Dbg系列：本系列内核函数用于调试管理，如果打算拦截调试操作的话，那么请进一步考察这组以Dbg为前缀的函数，常用的函数包括：、DbgBreakPoint、DbgUserBreakPoint、DbgPrint和DbgUiConnectToDbg等。</p>
<p>Etw系列：本系列内核函数用于追踪窗口事件，如果你打算拦截追踪之类的操作的话,那么请进一步考察这组以Etw为前缀的函数。常用的函数包括：EtwTraceEvent、EtwEnableTrace、EtwGetTraceEnableLevel和EtwGetTraceEnableFlags等。</p>
<p>Pfx系列：本系列内核函数用于ANSI字符串操作，如果你打算拦截ASNI串表方面的操作的话，就需要进一步了解这些函数。常用的包括：PfxInitialize、PfxRemovePrefix、PfxInsertPrefix、PfxFindPrefix等。</p>
<p>不过并非所有函数名都带有这样的前缀，对前缀的使用也并非非常严格。<br>例如：核心层函数名的前缀本应该是Ke，但实际上有不少核心层函数名的前缀是 Ki，这些函数大都是与中断有关的比较底层的函数。</p>
<p>有时候还在函数名的前缀后面加上小写字母 f，表示这个函数是快速调用函数。<br>例如：NTKERNELAPI LONG_PTR FASTCALL ObfDereferenceObject(IN PVOID Object);<br>这里的类型说明 FASTCALL 向编译工具表明这是个快速调用函数，函数名前缀加 f 则使人一看见函数名就知道这个函数是个快速调用函数，一般的函数调用是通过堆栈传递参数的，而快速调用函数则通过 ECX 等寄存器传递参数，因为避免了几个堆栈操作而使效率有所提高。<br>这里的 FASTCALL 是必须的，否则编译工具不知道应该通过寄存器传递参数，而在函数名中加 f 则只是为了增加程序的可读性</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[操作系统内存地址管理 (127)]]></title>
      <url>https://xuecat.github.io/2015/06/12/127/</url>
      <content type="html"><![CDATA[<p>先看内存的分段机制，了解到这个被linux所“抛弃”，算了先放一放，但是汇编中的cs、ss、ds还是要记住（笔记本上）<br><br><strong>分页</strong><br><br>一个32位的机器，线性地址最大可为4G，可以用4KB为一个页来划分，这页，整个线性地址就被划分为一个tatol_page[2^20]的大数组，共有2的20个次方个页。这个大数组我们称之为页目录。目录中的每一个目录项，就是一个地址——对应的页的地址。</p>
<p><strong>个人认识，以后修改</strong><br><br>首先，一个程序里面用的是逻辑地址，代码访问的也是逻辑地址。<br><br>对于程序的逻辑地址来说，用的是分段机制，我想那几个段寄存器应该有用了吧。<br><br>一般32位系统是有3层页表，4k对齐方式页面大小是4kb 2^12，2^20个页。为了方便访问，使用前10位表示一级页表地址，中间10位2级页表，后12位3级页表。只有三级页表指向的才是4kb内存，其它是指针。<br><br>对于现在的操作系统来说，一个程序的加载（严格说进程），会被分配4gb的（32位）的虚拟内存，我认为，就是逻辑地址的分配，虚假的东西<br></p>
<p>我的问题，逻辑地址4gb，线性地址4gb（32位），为何转换要当前段地址加上偏移地址？完全不够？？<br></p>
<p>问题以后解决，接下来是过程。</p>
<p>首先，我认为线性地址作为y=nx+z的形式存在，且分页机制管理。我觉得它就是一个物理地址的使用情况虚拟表。</p>
<p>windows中，一个进程的开辟会有4GB（32）空间，里面有用户区、内核区等。内核区的代码和数据肯定是非分页内存。<br><br>多个进程可以共享一个内核区代码。所以，我觉得当用户区的逻辑地址进行操作时，转换线性地址通过分页来得到物理地址，进行操作。<br><br>对于内核区的逻辑地址，无须线性地址的转换，直接转换物理地址进行操作。<br></p>
<p>多个进程进行读写时，会使用当前虚拟地址（逻辑地址），转换为线性地址（具体转换：由于每个进程会对分页内存记录，只是页表项，页目录的记录。CR3寄存器会加载当前进程页目录来进行切换）<br><br>当发现转换的地址不在内存中（我认为线性地址就是对内存的管理，所以就是从线性地址寻找），就会发生缺页，缺页中断是软中断。irl不要忘了。<br><br>缺页的发生会让系统从页交换文件里寻找，没有就坏了！有就发生页交换。<br></p>
<p>我想一般2GB的内存条能装上64位系统，也是因为页交换文件。能使用的物理地址被保持到了住够，</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[内核dll crt 堆 (126)]]></title>
      <url>https://xuecat.github.io/2015/06/09/126/</url>
      <content type="html"><![CDATA[<p>  <strong>把这个放语言类。。是因为有个内核代码见居然没反应过来，惭愧！</strong></p>
<p>先说堆，默认堆、额外堆，我就不说了，它们必须要依次访问的，所以多线程注意下就好。</p>
<p>new -&gt;heapalloc，这段中用静态变量记录new类的个数。</p>
<p><strong>看下dll，首先dll</strong><br>先看隐式的：它会在程序加载的时候（**.dll 地址 import 函数….）<br>。讲dll的文件映像映射到进程的地址空间。<br>然而值得注意的是用的是写时复制，也就是说，dll的静态全局会被复制到新的空间里面。<br>而且，对预定的内存区域是为进程所拥有，也就是说，开辟内存啥的是玩的进程的，堆就会从默认堆分配，栈就会从进程空间预定。</p>
<p><strong>然后是大问题来了CRT和MTD MDD到底有哪些错误？</strong><br><br>一个程序可以链接多个库，这些库有的有静态的crt有的有动态crt。栈空间到好说，有响应汇编代码去销毁。对于堆，问题就来了。：</p>
<p><strong>如果在相应库里面开辟堆，是否应该在程序中释放？</strong> <br> 第一dll的crt是和程序共享一个堆空间的。所以完全没问题。第二 静态的crt是有自己的额外堆的，库里面开辟，在程序中释放内存是错误的做法。<br>这也就是为何大多数库都要自己写销毁内存的代码</p>
<p><strong>最后讲下dll吧</strong><br><br>//今天不想写了，改天继续(显式)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[汇编指令（125）]]></title>
      <url>https://xuecat.github.io/2015/05/21/125/</url>
      <content type="html"><![CDATA[<p> 说个不是汇编的：</p>
<blockquote>
<p>C语言调用约定(__cdecl)</p>
<p>标准调用约定(__stdcall)</p>
</blockquote>
<p>这俩个不同的约定函数，翻译成的汇编是不同的。然而驱动的是寻的_DriverEntry入口,所以注意要用标准的调用约定。</p>
<p>在函数的末尾ret指令是为了平衡esp指针在开始的参数入栈。所以看参数情况pop ip。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[windows内存管理（124）]]></title>
      <url>https://xuecat.github.io/2015/05/19/124/</url>
      <content type="html"><![CDATA[<p>一个进程是4gb虚拟内存（win32），存在分区，一般用户分区为2gb。</p>
<p>虚拟内存，也只是个内存对应表而已。实际内存，物理内存地址</p>
<p>vitrualalloc先向这么多虚拟内存预定一块内存，再分配物理存储器，再使用。</p>
<p>原话：最好把物理存储器看成是保存在磁盘（通常是硬盘）上页交换文件中的数据。</p>
<p>.exe或者dll（以下的说法dll没测试过）文件，文件头有相应的数据，通过那个，知道代码和数据大小等。然后就预定相应大小的内存空间，硬盘的话就直接映射内存文件上去，软盘就复制上去。</p>
<p>分页内存和非分页内存  </p>
<p>首先介绍几个术语：</p>
<p>进程上下文，就是表示进程信息的一系列东西，包括各种变量、寄存器以及进程的运行的环境。这样，当进程被切换后，下次再切换回来继续执行，能够知道原来的状态。<br>中断上下文，就是中断发生时，原来的进程执行被打断，那么就要把原来的那些变量保存下来，以便中断完成后再恢复。</p>
<p>Windows NT和Windows 98都是运行在支持虚拟地址空间的计算机上，虚拟地址空间或者映射到一段真实的物理内存，或者映射到交换文件中的页帧。</p>
<p>每一个进程有4G的虚拟地址空间空间（因为一般机器是32位），这4G的空间被分为用户模式地址空间以及用户模式地址空间。无论何时我们需要访问计算机内存，都要使用内核模式的虚拟地址。每一个用户模式进程都有自己的地址上下文，记录了进程信息的一系列东西。当Windows NT调度器把控制从一个进程的当前线程切换到另一个进程的某个线程时，与进程相对应的虚拟地址空间也被更换（执行到别的进程了，也就是跑到另外的一个4G的地址）。线程切换的一个步骤就是改变处理器当前使用的页表，以便它能引用新线程的进程上下文。</p>
<p>虚拟内存系统的特征就是能使软件有一个比物理内存大得多的虚拟内存空间。为了做到这一点，内存管理器需要在物理内存和磁盘文件间交换页帧。但操作系统的某些部分是不能被分页的，这些内存用来支持内存管理器本身。最明显的例子就是，用于处理页故障的代码和数据结构必须常驻内存。</p>
<p>Windows NT把内核模式地址空间分成分页内存池和非分页内存池。(用户模式地址空间总是分页的) 必须驻留的代码和数据放在非分页池；不必常驻的代码和数据放在分页池中。Windows NT为决定代码和数据是否需要驻留非分页池提供了一个简单规则。</p>
<p>非分页内容的空间是很小的，所以一般的东西都会放入分页内存中。</p>
<p>执行在高于或等于DISPATCH_LEVEL级上的代码必须存在于非分页内存中。</p>
<p>在写驱动的时候，经常要调用ExAllocatePoolWithTag函数分配内存，其中第一个参数可以是如下几个：</p>
<p>NonPagedPool    从非分页内存池中分配内存<br>PagedPool    从分页内存池中分配内存<br>NonPagedPoolMustSucceed    从非分页内存池中分配内存，如果不能分配则产生bugcheck<br>NonPagedPoolCacheAligned    从非分页内存池中分配内存，并确保内存与CPU cache对齐<br>NonPagedPoolCacheAlignedMustS    与NonPagedPoolCacheAligned类似，但如果不能分配则产生bugcheck<br>PagedPoolCacheAligned<br>从分页内存池中分配内存，并确保内存与CPU cache对齐</p>
<h2 id="最后我来说下驱动编程的的宏"><a href="#最后我来说下驱动编程的的宏" class="headerlink" title="最后我来说下驱动编程的的宏"></a>最后我来说下驱动编程的的宏</h2><p>PAGEDCODE<br>对于#pragram来说，code_seg是函数，data_seg是变量<br><br>LOCKEDCODE<br><br>INITCODE<br></p>
<p>首先，驱动函数是严格分了IRQL的。<br>运行一个函数，如fun，如果永远是在DISPATCH_LEVEL上运行。</p>
<p>就最好用非分页内存LOCKEDCODE进行开辟函数<br>在函数中对内存的开辟也必须是ExAllocatePool  NonPagePool类型的</p>
<p><br>如果对于在这种irql的运行函数进行PAGEDCODE声明和ExAllocatePool PagePool</p>
<p><br>当出现蓝屏：而如果访问分页内存的话，（注意，这是关键）如果分页内存数据不在物理内存中，也就是被交换到了虚拟内存页面文件中，将触发内存缺页中断，windows将会试图访问虚拟内存页面文件pagefile.sys，把被交换出的数据读入物理内存中，可是，访问文件是会引发i/o操作的，i/o操作中会有等待，<br>接着，系统直接崩溃</p>
<p>没有蓝屏：<br>就算你的页面属性是分页内存，但是没有被交换出去，还是在内存中，访问时不会引发缺页中断<br>但是，哪天，windows发现内存不够了，把你的代码数据交换到内存页面文件中（pagefile。sys），<br>呵呵，立即蓝屏~~~</p>
<p>所以建议严格分内存声明。。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[证书格式（122）]]></title>
      <url>https://xuecat.github.io/2015/05/18/122/</url>
      <content type="html"><![CDATA[<p><strong>X509</strong></p>
<blockquote>
<p>通用证书格式，国际标准</p>
</blockquote>
<p><strong>pem</strong></p>
<blockquote>
<p>一般用来当做数字认证机构（CA）<br>BASE64编码的ASCII码的文件</p>
</blockquote>
<p><strong>DER</strong></p>
<blockquote>
<p>二进制文件（网上说java适用），但windows上我也看到有，呵呵</p>
</blockquote>
<p><strong>CSR</strong></p>
<blockquote>
<p>证书请求文件</p>
</blockquote>
<p><strong>PKCS7</strong></p>
<blockquote>
<p>是个标准，存储认证证书，证书路径，证书链。实际编程中我发现证书签名验证等都是用它那个标准</p>
</blockquote>
<p><strong>PKCS12/PFX</strong></p>
<blockquote>
<p>加密二进制形式<br>服务器证书，中级证书和私钥</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[release和debug详细（121）]]></title>
      <url>https://xuecat.github.io/2015/05/18/121/</url>
      <content type="html"><![CDATA[<p>这几天翻了下笔记本，有好多知识没同步上来，写起！</p>
<blockquote>
<p>它们无本质区别，只是在编译的时候多添加了一些编译选项。</p>
</blockquote>
<table>
<thead>
<tr>
<th>DEBUG</th>
<th style="text-align:center">Are</th>
</tr>
</thead>
<tbody>
<tr>
<td>/mdd,mtd</td>
<td style="text-align:center">c语言运行库（不讲了）</td>
</tr>
<tr>
<td>/od</td>
<td style="text-align:center">关闭优化开关</td>
</tr>
<tr>
<td>/D</td>
<td style="text-align:center">给_DEBUG宏</td>
</tr>
<tr>
<td>/ZI</td>
<td style="text-align:center">创建edit continue数据库（就是修改源码不重新编译）</td>
</tr>
<tr>
<td>/GI</td>
<td style="text-align:center">捕获内存错误</td>
</tr>
<tr>
<td>/GM</td>
<td style="text-align:center">打开最小化重链接开关，减少链接时间</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>RELEASE</th>
<th style="text-align:center">Are</th>
</tr>
</thead>
<tbody>
<tr>
<td>/mt,/md</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>/o1,/o2</td>
<td style="text-align:center">优化开关，使程序最小或最快</td>
</tr>
<tr>
<td>/d</td>
<td style="text-align:center">“NDEBUG宏” 关闭条件编译调试代码开关(即不编译assert函数)</td>
</tr>
<tr>
<td>/gf</td>
<td style="text-align:center">合并重复字符串并放入只读内存</td>
</tr>
</tbody>
</table>
<p><strong>再来看下一个debug的现象</strong><br>/rtcx（插入动态检测代码）这个编译选项有点意思<br></p>
<blockquote>
<h4 id="0XCC初始化所有的自动变量-。"><a href="#0XCC初始化所有的自动变量-。" class="headerlink" title="0XCC初始化所有的自动变量 。"></a>0XCC初始化所有的自动变量 。<br></h4><p>所以会发现无论在栈控件只声明不定义会发现：int都是（-858993460）<br>char*一般都是0xccccccc，开辟个char数组会是：烫烫烫烫烫烫类型的</p>
<p>####oxcd堆分配内存，0xdd填充delete内存，0xfd填充被保护内存<br><br>所以看到的堆new的数据：int永远是-842150451， char*：0xcdcdcdcd（屯屯屯屯屯屯屯）<br>还有一种情况，就是debug模式一般会保护new的内存，所以会向前后加0xfdfdfdfd保护内存防止越界访问（恰恰恰恰恰恰“麻蛋，金字旁的不会打，算了”）</p>
</blockquote>
<p><strong><em>最后说下俩个模式注意项</em></strong></p>
<h4 id="网上说对windows的消息函数格式要严格要求（呵呵，-我没遇见过，反正一直都严格要求了）"><a href="#网上说对windows的消息函数格式要严格要求（呵呵，-我没遇见过，反正一直都严格要求了）" class="headerlink" title="网上说对windows的消息函数格式要严格要求（呵呵， 我没遇见过，反正一直都严格要求了）"></a>网上说对windows的消息函数格式要严格要求（呵呵， 我没遇见过，反正一直都严格要求了）<br></h4><h4 id="assert代码会忽略（遇见过）verify可以使用，但自己注意吧，我觉得这种宏。。"><a href="#assert代码会忽略（遇见过）verify可以使用，但自己注意吧，我觉得这种宏。。" class="headerlink" title="assert代码会忽略（遇见过）verify可以使用，但自己注意吧，我觉得这种宏。。"></a>assert代码会忽略（遇见过）verify可以使用，但自己注意吧，我觉得这种宏。。<br></h4><h3 id="未使用的变量会被去掉，网上有段这相关的代码，从代码的函数内存分配和入栈来想，确实会导致内存越界，结果跑的时候就是没变化感觉是坑，但还是注意吧。。-lt-gt"><a href="#未使用的变量会被去掉，网上有段这相关的代码，从代码的函数内存分配和入栈来想，确实会导致内存越界，结果跑的时候就是没变化感觉是坑，但还是注意吧。。-lt-gt" class="headerlink" title="未使用的变量会被去掉，网上有段这相关的代码，从代码的函数内存分配和入栈来想，确实会导致内存越界，结果跑的时候就是没变化感觉是坑，但还是注意吧。。&lt;&gt;"></a>未使用的变量会被去掉，网上有段这相关的代码，从代码的函数内存分配和入栈来想，确实会导致内存越界，结果跑的时候就是没变化感觉是坑，但还是注意吧。。&lt;&gt;</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[编译后各个文件（123）]]></title>
      <url>https://xuecat.github.io/2015/05/18/123/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li><p>pdb这个是二进制代码和源代码映射文件。有了这个才能调试定位代码位置</p>
</li>
<li><p>dump是进程内存镜像文件。用windbg打开。程序崩溃时用windbg生成下dmp文件，然后分析内存的错，而定位代码</p>
</li>
<li><p>obj文件是目标文件，一般是程序编译后的二进制文件，在通过链接器和资源文件链接就成exe文件了。   </p>
</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[cpu中断（120）]]></title>
      <url>https://xuecat.github.io/2015/05/17/120/</url>
      <content type="html"><![CDATA[<p><strong>中断和异常(为了理解驱动写的，多有错误)</strong></p>
<blockquote>
<ul>
<li><p>中断(interrupt)是异步的事件，典型的比如由I/O设备触发；异常(exception)是同步的事件，典型的比如处理器执行某条指令时发现出错了等等。</p>
</li>
<li><p>需要明确的一点是CPU对于中断和异常的具体处理机制本质上是完全一致的，即：<br>当CPU收到中断或者异常的信号时，它会暂停执行当前的程序或任务，通过一定的机制跳转到负责处理这个信号的相关处理程序中，在完成对这个信号的处理后再跳回到刚才被打断的程序或任务中。</p>
</li>
<li><p>系统要想能够应对各种不同的中断信号，总的来看就是需要知道每种信号应该由哪个中断服务程序负责以及这些中断服务程序具体是如何工作的。[a]系统将所有的中断信号统一进行了编号（一共256个：0～255），这个号称为中断向量，具体哪个中断向量表示哪种中断有的是规定好的，也有的是在给定范围内自行设定的。  </p>
</li>
</ul>
</blockquote>
<ul>
<li><p>中断向量和中断服务程序的对应关系主要是由IDT（中断向量表）负责。操作系统在IDT中设置好各种中断向量对应的中断描述符（一共有三类中断门描述符：任务门、中断门和陷阱门），留待CPU查询使用。而IDT本身的位置是由idtr保存的，当然这个地址也是由OS填充的。</p>
</li>
<li><p>[b]中断服务程序具体负责处理中断（异常）的代码是由软件，也就是操作系统实现的，这部分代码属于操作系统内核代码。也就是说从CPU检测中断信号到加载中断服务程序以及从中断服务程序中恢复执行被暂停的程序，这个流程基本上是硬件确定下来的，而具体的中断向量和服务程序的对应关系设置和中断服务程序的内容是由操作系统确定的。<br>保护当前程序的现场</p>
</li>
<li><p>CPU开始利用栈保护被暂停执行的程序的现场：依次压入当前程序使用的eflags，cs，eip，errorCode（如果是有错误码的异常）信息。</p>
</li>
</ul>
<blockquote>
<blockquote>
<p>也就是说中断的接收（一般每隔一段时间向寄存器读中断信息），处理由cpu处理。处理方式交给系统。</p>
</blockquote>
</blockquote>
<p><strong>（windows下）当硬件出发中断，中断信号先发给中断控制器IOAPIC（系统提供编程），IOAPIC通过重定位表判断中断类型和其他，再把相应IRQ(如IRQ1是键盘中断请求)发送到相应的CPU核心，CPU再来中断处理，处理方式交给系统提供的IDT表</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DDB和DIB（119）]]></title>
      <url>https://xuecat.github.io/2015/05/16/119/</url>
      <content type="html"><![CDATA[<p><strong>DDB</strong></p>
<blockquote>
<ul>
<li>是一个依赖设备的位图。它的颜色模式必需和输出的设备一致（16色的dc那内存图就是16色，256色dc内存图就是256,）<br><br>256色以下的位图中存储的像素值是系统调色板的索引，其颜色依赖于系统调色板。我想256的调色板应该在dc中吧<blockquote>
<p>我们一般编程创建的兼容dc就是ddb的</p>
</blockquote>
</li>
</ul>
</blockquote>
<pre><code>typedef struct tagBITMAP {
LONG bmType; //必需为0
LONG bmWidth; //位图的宽度(以像素为单位)
LONG bmHeight; //位图的高度(以像素为单位)
LONG bmWidthBytes; //每一扫描行所需的字节数，应是偶数
WORD bmPlanes; //色平面数
WORD bmBitsPixel; //色平面的颜色位数
LPVOID bmBits; //指向存储像素阵列的数组
} BITMAP;
</code></pre><p><strong>DIB</strong></p>
<blockquote>
<ul>
<li><p>DIB的颜色模式与设备无关。例如，一个256色的DIB即可以在真彩色显示模式下使用，也可以在16色模式下使用。</p>
</li>
<li><p>256色以下(包括256色)的DIB拥有自己的颜色表，像素的颜色独立于系统调色板。</p>
</li>
</ul>
<ul>
<li>由于DIB不依赖于具体设备，因此可以用来永久性地保存图象。DIB一般是以<em>.BMP文件的形式保存在磁盘中的，有时也会保存在</em>.DIB文件中。运行在不同输出设备下的应用程序可以通过DIB来交换图象。</li>
</ul>
</blockquote>
<pre><code>typedef struct tagBITMAPINFO {

BITMAPINFOHEADER bmiHeader;

RGBQUAD bmiColors[1]; //颜色表

} BITMAPINFO;

RGBQUAD结构用来描述颜色，其定义为

typedef struct tagRGBQUAD {

BYTE rgbBlue; //蓝色的强度

BYTE rgbGreen; //绿色的强度

BYTE rgbRed; //红色的强度

BYTE rgbReserved; //保留字节，为0

} RGBQUAD;

注意，RGBQUAD结构中的颜色顺序是BGR，而不是平常的RGB。

BITMAPINFOHEADER结构包含了DIB的各种信息，其定义为

typedef struct tagBITMAPINFOHEADER{

DWORD biSize; //该结构的大小

LONG biWidth; //位图的宽度(以像素为单位)

LONG biHeight; //位图的高度(以像素为单位)

WORD biPlanes; //必须为1

WORD biBitCount //每个像素的位数(1、4、8、16、24或32)

DWORD biCompression; //压缩方式，一般为0或BI_RGB (未压缩)

DWORD biSizeImage; //以字节为单位的图象大小(仅用于压缩位图)

LONG biXPelsPerMeter; //以目标设备每米的像素数来说明位图的水平分辨率

LONG biYPelsPerMeter; //以目标设备每米的像素数来说明位图的垂直分辨率

DWORD biClrUsed; /*颜色表的颜色数，若为0则位图使用由biBitCount指定的最大颜色数*/

DWORD biClrImportant; //重要颜色的数目，若该值为0则所有颜色都重要

} BITMAPINFOHEADER;
</code></pre><blockquote>
<blockquote>
<ul>
<li>与DDB不同，DIB的字节数组是从图象的最下面一行开始的逐行向上存储的，也即等于把图象倒过来然后在逐行扫描。另外，字节数组中每个扫描行的字节数必需是4的倍数，如果不足要用0补齐。<br><br>这一点我有点不懂，指的是颜色表的链表吗？</li>
</ul>
</blockquote>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[编译语法和C语言位域（117）]]></title>
      <url>https://xuecat.github.io/2015/05/14/117/</url>
      <content type="html"><![CDATA[<blockquote>
<p>编译器中提供了#pragma pack(n)来设定变量以n字节对齐方式。n字节对齐就是说变量存放的起始地址的偏移量有两种情况：第一、如果n大于等于该变量所占用的字节数，那么偏移量必须满足默认的对齐方式，第二、如果n小于该变量的类型所占用的字节数，那么偏移量为n的倍数，不用满足默认的对齐方式</p>
<p>测试了下基本就是比最大字节大就默认对齐，比最大字节小就指定对齐</p>
<p>使用位域时，发现同一类型无论多少sizeof都是类型大小<br><br>：0自动填充剩下</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[microsoft c++（118）]]></title>
      <url>https://xuecat.github.io/2015/05/13/118/</url>
      <content type="html"><![CDATA[<h1 id="declspec语法"><a href="#declspec语法" class="headerlink" title="__declspec语法"></a>__declspec语法</h1><blockquote>
<ul>
<li><p>__declspec(align(n)) n字节对齐和pragram pack一样<br>前者最大值，后者对齐最小值</p>
</li>
<li><p>__declspec(deprecated )说明一个函数，类型，或别的标识符在新的版本或未来版本中不再支持，你不应该用这个函数或类型。它和#pragma deprecated作用一样。<br>后面跟函数</p>
</li>
<li><p>__declspec( allocate(“segname”) )要和pragma的ode_seg， const_seg, data_seg,section,init_seg配合使用。<br><br>感觉好复杂，先放放</p>
</li>
<li><p>用<strong>declspec(dllexport)，</strong>declspec(dllimport)显式的定义dll接口给调用它的exe或dll文件，用 dllexport定义的函数不再需要（.def）文件声明这些函数接口了。<br>注意：若在dll中定义了模板类那它已经隐式的进行了这两种声明，我们只需在 调用的时候实例化即可，呵呵。</p>
</li>
<li><p><strong>declspec( naked )<br>对于没有用naked声明的函数一般编译器都会产生保存现场（进入函数时编译器会产生代码来保存ESI，EDI，EBX，EBP寄存器 ——prolog）和清除现场（退出函数时则产生代码恢复这些寄存器的内容——epilog） 代码，而对于用naked声明的函数一般不会产生这些代码，这个属性对于写设备驱动程序非常有用，我们自己可以写这样一个过程，它仅支持x86 。naked只对函数有效，而对类型定义无效。对于一个标志了naked的函数不能产生一个内联函数即时使用了</strong>forceinline 关键字。 </p>
</li>
<li><p>__declspec(restrict) ，restrict 说明函数返回值没有被别名化，返回的指针是唯一的，没有被别的函数指针别名花，也就是说返回指针还没有被用过是唯一的。编译器一般会去检查指针是否可用和 是否被别名化，是否已经在使用，使用了这个关键字，编译器就不在去检查这些信息了。</p>
<blockquote>
<ul>
<li>可以理解为和编译器做了一个君子协定（只针对指针函数），返回的指针值绝对不会在当前程序使用的（别名）</li>
</ul>
</blockquote>
</li>
<li><p>__declspec(noalias) 也是仅适用于函数，它指出该函数是半纯粹的函数。半纯粹的函数是指仅引用或修改局部变量、参数和第一层间接参数。</p>
<blockquote>
<ul>
<li>网上说不能用全局变量或第二层间接指针参数，但测试没错误。实在不明白呢！</li>
</ul>
</blockquote>
</li>
<li><p>__declspec(noinline)<br>告诉编译器不去内联一个具体函数。（记得.h文件的定义是默认内联的）</p>
</li>
<li><p><strong>declspec(noreturn)<br>告诉编译器没有返回值.注意添加</strong>declspec(noreturn)到一个不希望返回的函数会导致已没有定义错误. </p>
</li>
<li><p>__declspec(nothrow)<br>用于函数声明,它告诉编译器函数不会抛出异常。</p>
<blockquote>
<ul>
<li>这个和函数后面加throw()这个君子协定一样</li>
</ul>
</blockquote>
</li>
<li><p>_declspec(novtable)<br>用在任意类的声明,但是只用在纯虚接口类,因此这样的不能够被自己实例话.它阻止编译器初始化虚表指针在构造和析构类的时候,这将移除对关联到类的虚表的 引用.如果你尝试这实例化一个有novtable关键字的类,它将发生AV(access violation)错误.C++里virtual的缺陷就是vtable会增大代码的尺寸,在不需要实例化的类或者纯虚接口的时候,用这个关键字可以减 小代码的大小.</p>
<blockquote>
<ul>
<li>我想它只用于纯虚基类。因为这样可以减少虚表的空间。<br>测试了下，然而并没有什么卵用。sizeof依旧。。<br>记个代码</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<pre><code>#if _MSC_VER &gt;= 1100 &amp;&amp; !defined(_DEBUG)//这个条件判断可以学习
#define AFX_NOVTABLE __declspec(novtable)
#else
#define AFX_NOVTABLE
#endif
</code></pre><blockquote>
<ul>
<li><p><strong>declspec(selectany)可以让我们在.h文件中初始化一个全局变量而不是只能放在.cpp中。比如有一个类，其中有一个静态变量，那 么我们可以在.h中通过类似” </strong>declspec(selectany) type class::variable = value; “这样的代码来初始化这个全局变量。既是该.h被多次include，链接器也会为我们剔除多重定义的错误。这个有什么好处呢，我觉得对于 teamplate的编程会有很多便利。</p>
</li>
<li><p><strong>declspec(thread) 用于声明一个线程本地变量它告诉编译器，对应的变量应该放入可执行文件或DLL文件中它的自己的节中。</strong>declspec(thread)后面的变量 必须声明为函数中（或函数外）的一个全局变量或静态变量。不能声明一个类型为__declspec(thread)的局部变量。我想可能和volatile有点关系</p>
</li>
<li><p>uuid__declspec(uuid)<br>用于编译器关联一个GUID到一个有uuid属性的类或结构的声明或者定义.</p>
</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">:  __stdcall :</th>
<th style="text-align:center">: __cdecl :</th>
<th style="text-align:center">:  __fastcall  :</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数传递</td>
<td style="text-align:center">右-&gt;左 压栈</td>
<td style="text-align:center">右-&gt;左 压栈</td>
<td style="text-align:center">左边开始的两个不大于4字节（DWORD）的参数分别放在ECX和EDX寄存器，其余的参数仍旧自右向左压栈传送</td>
</tr>
<tr>
<td>清理栈方</td>
<td style="text-align:center">被调用函数清理（即函数自己清理)</td>
<td style="text-align:center">调用者清理</td>
<td style="text-align:center">被调用者清理栈</td>
</tr>
<tr>
<td>适用场合</td>
<td style="text-align:center">Win API</td>
<td style="text-align:center">c/C++  MFC默认方式可变参数的时候使用</td>
<td style="text-align:center">速度快</td>
</tr>
</tbody>
</table>
<h1 id="pragram语法"><a href="#pragram语法" class="headerlink" title="pragram语法"></a>pragram语法</h1><p>所有的预处理指令中，#pragma 指令可能是最复杂的了</p>
<blockquote>
<p>/#ifdef _X86<br><br>/#pragma message(“_X86 macro activated!”)<br><br>/#endif<br><br>当我们定义了_X86这个宏以后，应用程序在编译时就会在编译输出窗口里显示<br>“_X86 macro activated!”<br>这样，我们就不会因为不记得自己定义的一些特定的宏而抓耳挠腮了。</p>
<p>/#pragma hdrstop表示预编译头文件到此为止，后面的头文件不进行预编译。</p>
<p>/#pragma warning指令<br>该指令允许有选择性的修改编译器的警告消息的行为<br><br>once:只显示一次(警告/错误等)消息<br><br>default:重置编译器的警告行为到默认状态<br><br>1,2,3,4:四个警告级别<br><br>disable:禁止指定的警告信息<br><br>error:将指定的警告信息作为错误报告<br><br>pragma warning( push )保存所有警告信息的现有的警告状态。<br><br>/#pragma warning( push, n)保存所有警告信息的现有的警告状态，并且把全局警告等级设定为n。<br><br>/#pragma warning( pop )向栈中弹出最后一个警告信息，在入栈和出栈之间所作的一切改动取消。<br></p>
<p>pragma comment(…)  很多，具体自己查吧，反正就用了几个。</p>
</blockquote>
<p>pragma code_seg( [ [ { push | pop}, ] [ identifier, ] ] [ “segment-name” [, “segment-class” ] )</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[驱动]]></title>
      <url>https://xuecat.github.io/2015/05/11/116/</url>
      <content type="html"><![CDATA[<blockquote>
<p>注册问题</p>
</blockquote>
<p>Windows Registry Editor Version 5.00</p>
<p>[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Debug Print Filter]<br>“DEFAULT”=dword:0000000f</p>
<blockquote>
<p>rv<em>c:\symbols</em><a href="http://msdl.microsoft.com/download/symbols" target="_blank" rel="external">http://msdl.microsoft.com/download/symbols</a></p>
<p>illegal use of this type as an expression错误出现的原因 C语言的声明必须放在函数的开始（所有的变量声明和定义必须分开）</p>
<p>根据DDK上说明,Unicode格式(%C, %S, %lc, %ls, %wc, %ws, and %wZ)只能在 IRQL = PASSIVE_LEVEL时才能使用。  所以用 DBPrint老是蓝屏。KDPrint没事（check版）</p>
<p>driverentry和riverunload 分发函数。是passive级别的。完成函数、NDIS回调是dispatch级别的</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[驱动笔记115]]></title>
      <url>https://xuecat.github.io/2015/04/27/115/</url>
      <content type="html"><![CDATA[<h1 id="REMARK"><a href="#REMARK" class="headerlink" title="REMARK"></a>REMARK</h1><p>wdk7用于vs2010<br>wdk8用于vs2012<br>wdk8.1用于vs2013<br>装了低版本的，没法整合高版本到vs的了。还有最好自己去vs默认的地方下载，免得手动下载出错</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p> <strong>OBJ_CASE_INSENSITIVE</strong>不区分大小写，进行字符比对寻找驱动</p>
<p> <strong>ObDereferenceObeject</strong>减少对读取到的引用计数，一般是Reference函数，都要减少。<br><strong>IoGetDeviceObjectPointer</strong>查阅msdn发现也要用它来减少，以后对设备的打开都要用它来进行减少。  只有减少到0才能被系统所卸载销毁。</p>
<p><strong>DO_POWER_PAGABLE</strong>:如果IRP_MJ_POWER请求的派遣函数必须运行在PASSIVE_LEVEL级别，你需要设置DO_POWER_PAGABLE标志。该标志的名称含有相关的含义，因为只有在PASSIVE_LEVEL级上才允许分页操作。如果你把该标志设置为0，则电源管理器可以在DISPATCH_LEVEL级上向你发送电源管理请求<br>(更多关于设备对象的type可以去看张帆89上面的)</p>
<p><strong>IoCreateDevice</strong><br>设备对象名：字符串必须是”\Device[设备名]”(UNICODE)<br>如：C盘（\Device\HarddiskVolume1）D盘（\Device\HarddiskVolume2）。如果不指定名字，会默认给一个数字来当做名。然而“c:，d:”这一类的是符号链接字符。<br><br>这个函数的倒数第二个参数，表示产生的对象是用于内核模式还是用户模式。在内核模式下，符号链接是以”\??\”（或者\DosDevices）开头。在用户模式下，是以”\.\”开头<br>注意，再看下它第二个参数。大小是扩展项的大小，不然后面强制转换扩展项会越界，并发生泄漏。</p>
<p><strong>DO_DIRECT_IO和DO_BUFFERED_IO</strong> 自己去保存页看吧。。</p>
<h1 id="inf"><a href="#inf" class="headerlink" title="inf"></a>inf</h1><p>看下inf结构：</p>
<pre><code>Version Section
SourceDisksNames Section
SourceDisksFiles Section
ClassInstall32 Section（可选）
ClassInstall32.Services Section（可选）
DestinationDirs Section
ControlFlags Section
Manufacturer Section
    Models Section (per Manufacturer entry)
        DDInstall Section (per Models entry)
        DDInstall.Services Section
        DDInstall.HW Section
        DDInstall.CoInstallers Section
        DDInstall.FactDef Section
        DDInstall.LogConfigOverride Section
        DDInstall.Interfaces Section
InterfaceInstall32 Section
DefaultInstall Section
DefaultInstall.Services Section
Strings Section
</code></pre><p><strong>DestinationDirs</strong>安装目录(用代号表示)</p>
<p><strong>SourceDisksNames</strong> 源文件目录。如果忽略，就会从inf文件目录找。可以设置为inf相对目录或者绝对目录。</p>
<p><strong>class</strong>这个字段会在指定的设备名添加</p>
<p><strong>ClassInstall</strong>当加载自定义的驱动时候，用这个。它会新建一个设备，就不是从已有设备做过滤啥的。（官方：A ClassInstall32 section installs a new device setup class (and possibly a class installer) for devices in the new class.）</p>
<p><a href="https://msdn.microsoft.com/zh-cn/library/windows/hardware/ff546335" target="_blank" rel="external">https://msdn.microsoft.com/zh-cn/library/windows/hardware/ff546335</a>  这里有它必须包含的字段</p>
<p><strong>DefaultInstall</strong> 当右键“安装”时候访问(没有字段却点击会报错)（section is accessed if a user selects the “Install” menu item after right-clicking on the INF file name.）<br><br>通过remarks知道，这个字段不能用来当做设备驱动安装，仅用于类过滤驱动，类共同安装，文件系统过滤驱动，内核驱动服务程序等不与设备驱动关联的服务。<br>数字签名不能使用这个字段<br> Unlike a DDInstall section, a DefaultInstall section cannot contain DriverVer or LogConfig directives.(和ddinstall的不同)</p>
<p><strong>ddinstall</strong> 每个DDInstall Section包含一个可选项DriverVer指令，adreg好像也是必选<br>从marks知道，它用于安装段名（自定义），指定有或没有平台。（详细看<a href="https://msdn.microsoft.com/zh-cn/library/windows/hardware/ff547344）" target="_blank" rel="external">https://msdn.microsoft.com/zh-cn/library/windows/hardware/ff547344）</a><br>所以Manufacturer是安装入口（这个必选联系理解，下面就说它，）</p>
<p><strong>Manufacturer</strong>：官方的name我有点不懂就跳过，讲点大众的。</p>
<pre><code>%strkey%=models-section-name [,TargetOSVersion] [,TargetOSVersion] ...  (Windows XP and later versions of Windows)
</code></pre><p>strkey是string段里面的被代替为name<br><br>models-section-name 这里理解为另一个节（section翻译都行）<br><br>version最后的是平台，可以选择多个平台，但是也就意味着相应的model节也必需匹配平台信息。(有时会有个主版本号和副版本号，我们用它来确定系统xpwin7)<br><br>如：%MFGNAME% = MyDevice_WinUSB,NTx86,NTamd64后面就必需有<br>[MyDevice_WinUSB.NTx86]和[MyDevice_WinUSB.NTamd64]节</p>
<p><strong>Models</strong><br><br>device-description=install-section-name[,hw-id][,compatible-id…]</p>
<p>desciption:是个string节的id(中文就是设备描述)<br><br>section-name:<br>然后，这个就是ddinstall的模块了。<br><br>hw-id:指定一个设备制造商定义的硬件ID串(hardware ID string)。PnP管理器用这个项来找匹配的INF文件<br><br>compatible-id:指定一个设备制造商定义的兼容ID字符串(compatible ID string)。同时可以指定多个compatible-id，之间用逗号隔开<br>后面俩个不是很理解，以后来更新。<br></p>
<h1 id="INF-三键"><a href="#INF-三键" class="headerlink" title="INF 三键"></a>INF 三键</h1><p>硬件子键：<br>这里是对设备的键值修饰，“我的电脑”右键“管理”，指的便是这里的硬件设备。当然可以通过classinstall添加一个设备，或是虚拟设备<br>在这个里面内容主要是厂家设备信息（msdn就说过通过models的俩个id给设备增添加服务），然后为了唯一性有个类子键（classguid管理），服务性有个服务子键（加载的具体驱动服务，sys，几个type）</p>
<p>类子键：<br>一个类键管理一个设备。<br>（以下自己理解，有待修改）<br>“我的电脑”右键“管理”这么多个设备被格子guid标识，当厂家要在某个设备下添加驱动时，就把class和classguid弄上去，但Manufacturer是厂家自己的信息，当驱动更新时，系统会更快通过这些信息更新。<br>所以一个设备下可能有很多个驱动。</p>
<p>服务子键：<br>俩个type和错误type，和sys文件路径</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常量折叠和debug填充114]]></title>
      <url>https://xuecat.github.io/2015/04/26/114/</url>
      <content type="html"><![CDATA[<p><strong>先看常量重叠</strong></p>
<pre><code>int main(int argc, char* argv[])
{
    const int i=0;
    int *j = (int *) &amp;i;
    *j=1;
    cout&lt;&lt;&amp;i&lt;&lt;endlcout&lt;&lt;j&lt;&lt;endl;
    cout&lt;&lt;i&lt;&lt;endl;
    cout&lt;&lt;*j&lt;&lt;endl;
    return 0;
}
</code></pre><p>结果是</p>
<pre><code>0012ff7c
0012ff7c

0

1
</code></pre><p>因为编译器在优化的过程中，会把碰见的const全部以内容替换掉（跟宏似的: #define pi 3.1415,用到pi时就用3.1415代替），这个出现在预编译阶段；但是在运行阶段，它的内存里存的东西确实改变了!</p>
<p>最后注意下：</p>
<pre><code>char* p = &quot;hello world1&quot;；//常量区
char a[] = &quot;hello world2&quot;；//栈区
</code></pre><p><strong>看debug下的内存吧</strong></p>
<p>0xcccccccc所有自动变量<br><br>0xcdcdcdcd new内存<br><br>0xdddddddd delete内存<br><br>0xfdfdfdfd 保护堆内存<br><br>也就解释了new 老是是铪 妄 等字符。。未赋值的老是-858993460等了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[WINdows函数记录(113)]]></title>
      <url>https://xuecat.github.io/2015/04/16/113/</url>
      <content type="html"><![CDATA[<p> ValidateRect用这个来更新重绘区域，达到剪切界面效果</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[windows属性设置]]></title>
      <url>https://xuecat.github.io/2015/04/13/112/</url>
      <content type="html"><![CDATA[<blockquote>
<p>windows喜欢用 |=添加属性，&amp;=~来删除属性，(&amp;)!=0判断是否拥有属性</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c++ typdef指针111(111)]]></title>
      <url>https://xuecat.github.io/2015/03/27/111/</url>
      <content type="html"><![CDATA[<blockquote>
<p>typdef 和define的区别。</p>
</blockquote>
<pre><code>typdef int* int_ptr;
#define int* int_ptr;
</code></pre><blockquote>
<p>我相信一看就知道了。</p>
</blockquote>
<p><strong>数组</strong></p>
<pre><code>typdef int carry[3];//嘿嘿，不知道了吧
</code></pre><blockquote>
<p>实际上就是申明了一个数组。用法：</p>
</blockquote>
<pre><code>carry temp;
cout &lt;&lt; typeid(temp).name();//输出结果是int [3]; 说明temp就是个int数组的别名。
</code></pre><p><strong>函数</strong></p>
<pre><code>typdef int (*fun)(int);//这种写法早就见过了。嘿嘿看下面的
typdef int fun(int);//是否见过？。除了，使用时必须添加&amp;符号外。。它还有个用处，就是在声明函数的时候，可以成为一个别名，但是有个缺点是，也仅仅是声明，只是表明有这个函数类型，定义的时候，还是要老老实实还原类型进行定义;
//int* (*a[5])(int, char*) 函数指针和指针函数已经有了解，从已有了解到a是一个5大小的函数指针数组，看下面这个。
//doube(*)() (*pa)[9]; 然而并没有区别。
</code></pre><blockquote>
<p>看一段高级用法代码:</p>
</blockquote>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">NTSTATUS</span><span class="params">(*fcntab[])</span><span class="params">(PDEVICE_EXTENSION pdx, PIRP Irp)</span></span>;<span class="comment">//静态数组指针</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*FP_CALC)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;   </div><div class="line"><span class="function"><span class="keyword">typedef</span> FP_CALC <span class="title">CAll</span><span class="params">(<span class="keyword">char</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hehea</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> a+b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">FP_CALC <span class="title">test</span><span class="params">(<span class="keyword">char</span> f)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (f == <span class="string">'a'</span>) &#123;</div><div class="line">		<span class="keyword">return</span> hehea;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	CAll* p = test;</div><div class="line">	p(<span class="string">'a'</span>);</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<blockquote>
<p>亮点一：返回函数指针，太棒了，以前都没用过。。<br>亮点二：typedef的使用可以对函数本体使用，但是使用的时候必须添加指针。</p>
</blockquote>
<p><strong>对了</strong></p>
<blockquote>
<p>要对结构体的用法，</p>
</blockquote>
<pre><code>struct mem {int a; int b; char c;} *mem_ptr;//基本完了。。。。嘿嘿！
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[函数堆栈110(110)]]></title>
      <url>https://xuecat.github.io/2015/03/26/110/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/Binhua-Liu/archive/2010/08/24/1803095.html" target="_blank" rel="external">http://www.cnblogs.com/Binhua-Liu/archive/2010/08/24/1803095.html</a></p>
<pre><code>---------------------
二进制 局部 - return -  参数 -//我去对不齐。。。
           -    -   -
           -    -   -
---------------------
</code></pre><blockquote>
<p>堆栈由处理器支持<br>高地址向地地址扩展，栈顶地址不断减小，越后入，地址越低。</p>
</blockquote>
<pre><code>---------------------
-   -高
-   -
-   -
- - -低
</code></pre><blockquote>
<p>32位堆栈每个数据单元大小4字节，这便和数据对齐相关了。</p>
<blockquote>
<p>普及下寄存器EBP（extended base pointer） ESP(extended stack pointer)</p>
<p>指令，push 寄存器指针减4，拷贝数据到ESP指向地址</p>
<p>pop 寄存器拷贝出数据，加4.</p>
</blockquote>
</blockquote>
<p><strong>上主菜</strong></p>
<blockquote>
<p>先对参数的压入栈。我觉得这个过程完成形参对实参的赋值，所以压入的是实参。<br><br>然后是返回的压入，压入返回指令。<br><br>我认为以上的压入在32为下4字节内压入类型，8字节压入俩寄存器表示的类型，上压入指针<br><br>压入EBP寄存指针。访问参数和局部变量使用。调用函数形成链表。<br><br>ESP赋值EBP，EBP指向中间。<br><br>局部变量的压栈<br><br>通用寄存器压栈<br><br>开始执行二进制代码.</p>
<pre><code>假设执行函数前堆栈指针ESP为NN
push   p2    ;参数2入栈, ESP -= 4h , ESP = NN - 4h
push   p1    ;参数1入栈, ESP -= 4h , ESP = NN - 8h
call test    ;压入返回地址 ESP -= 4h, ESP = NN - 0Ch  
;//进入函数内
{
push   ebp                        ;保护先前EBP指针， EBP入栈， ESP-=4h, ESP = NN - 10h
mov    ebp, esp                   ;设置EBP指针指向栈顶 NN-10h
mov    eax, dword ptr  [ebp+0ch]  ;ebp+0ch为NN-4h,即参数2的位置
mov    ebx, dword ptr  [ebp+08h]  ;ebp+08h为NN-8h,即参数1的位置
sub    esp, 8                     ;局部变量所占空间ESP-=8, ESP = NN-18h
...
add    esp, 8                     ;释放局部变量, ESP+=8, ESP = NN-10h
pop    ebp                        ;出栈,恢复EBP, ESP+=4, ESP = NN-0Ch
ret    8                          ;ret返回,弹出返回地址,ESP+=4, ESP=NN-08h, 后面加操作数8为平衡堆栈,ESP+=8,ESP=NN, 恢复进入函数前的堆栈.
}
//看完汇编后,再看EBP和ESP的定义,哦,豁然开朗,
原来ESP就是一直指向栈顶的指针,而EBP只是存取某时刻的栈顶指针,以方便对栈的操作,如获取函数参数、局部变量等。
</code></pre></blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[动态类109]]></title>
      <url>https://xuecat.github.io/2015/03/10/109/</url>
      <content type="html"><![CDATA[<pre><code>virtual BOOL StartAnimation(int nElapse, int nTotalFrame, int nAnimationID = 0, BOOL bLoop = FALSE);
</code></pre><blockquote>
<p>timeout时间（也就是定时）、总共帧数、事件ID、是否循环</p>
</blockquote>
<p>定义一个类保存：<br>        int m_nAnimationID;<br>        int m_nElapse;</p>
<pre><code>int m_nTotalFrame;
int m_nCurFrame;

BOOL m_bLoop;
BOOL m_bFirstLoop;//数据
</code></pre><p>看似乎要相关类OnTimer调用OnAnimationElapse来实现每帧的处理。<br>实际要重载OnAnimationStart OnAnimationStep OnAnimationStop来实现处理。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[shell笔记-dll注入(106)]]></title>
      <url>https://xuecat.github.io/2015/03/05/106/</url>
      <content type="html"><![CDATA[<p> 最开始的时候一直无法注入，后来使用explorer强制全部退出，用手动注入，如果出现错误，就进入注入目录，重新注入。</p>
<p>之后运行成功。。多个菜单项添加要注意返回值。（这也是com编程注意的，failed successed MAKE_HRESULT）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[有必要的c++(强制++对齐11符号)(108)]]></title>
      <url>https://xuecat.github.io/2015/02/18/108/</url>
      <content type="html"><![CDATA[<h6 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h6><p>reinterpret_cast任意类型转换，包括指针和整数的转换<br>static<strong><em>cast和dynamic</em></strong>cast对类型转换比较苛刻，必须是指针到指针或者实例到实例<br>dynamic__cast对虚函数有要求才能体现，所以注意转换是否对的，如果错误运行会错误，编译无错。</p>
<h6 id="11新特性"><a href="#11新特性" class="headerlink" title="11新特性"></a>11新特性</h6><p>default编译器自动添加默认构建函数<br>delete编译器删除默认构建函数</p>
<p>class B : A  测试发现默认是protected继承</p>
<h6 id="逻辑符号"><a href="#逻辑符号" class="headerlink" title="逻辑符号"></a>逻辑符号</h6><p>!和~   一个是逻辑符一个是按位符。。逻辑符号后要么1要么0<br><br>按位与：取最小<br>按位或：取平均<br><br>    计算x二进制包含1的个数：</p>
<pre><code>count = 0;
while(x) {
    count++;
    x=x&amp;(x-1);
}
return count;
</code></pre><h6 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h6><p>8字节的边界<br>4字节的舍入<br>所以类和结构体对成员的构建顺序很是要求。<br>方法：先比对最大的类型。其大小必定是它的倍数，再按次数填入数据。</p>
<h6 id="自加和加自"><a href="#自加和加自" class="headerlink" title="自加和加自"></a>自加和加自</h6><p><em>(pp++)+=2;就是</em>(pp)+=2;<br> 先使用pp  switch(p++)就是switch(p)</p>
<h6 id="多重继承和虚继承"><a href="#多重继承和虚继承" class="headerlink" title="多重继承和虚继承"></a>多重继承和虚继承</h6><blockquote>
<p>多重继承只需要考虑一个报错“ambiguous”</p>
<blockquote>
<p>因为a; b; c&gt;b,&gt;a;如果有重复函数名无法识别，或者自己添加类限定。</p>
</blockquote>
<p>当多重继承是这种关系时a; b&gt;a; c&gt;a,&gt;b;问题就是already<br>所以这时候要用虚继承</p>
<blockquote>
<p>所谓的虚继承也只是多了个虚化表而已，只要保证有一个东东就行！！虚化谁你自己看着办。。两次或者一次虚化都可以办到。</p>
<blockquote>
<p>这之后还有个ambiguous错误，，同样或者自己添加类限定。。</p>
</blockquote>
</blockquote>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[windows进程堆和空间(107)]]></title>
      <url>https://xuecat.github.io/2015/02/01/107/</url>
      <content type="html"><![CDATA[<h6 id="看进程空间"><a href="#看进程空间" class="headerlink" title="看进程空间"></a>看进程空间</h6><blockquote>
<p>每个进程都有自己的虚拟空间（win32程序中每个进程拥有4GB的虚拟地址空间，每个进程都有各自编址，同一个数据块在不同进程编址可能不一样，这存在调度问题：）</p>
<blockquote>
<p>虚拟空间被分为好几个区：空指针赋值区、用户模式区、64k禁入区（为了分开内核和用户的边界区）、内核模式区</p>
<blockquote>
<p>分配的空间大小事分配粒度的倍数。<br>涉及给分区调拨物理存储器，映射虚拟内存到物理内存</p>
<p>######来说下堆<br>用户模式区装载exe、dll等数据。</p>
</blockquote>
<p>程序开始开辟进程，进程开辟堆空间。也就是默认1mb的缺省堆。<br>我认为一开始堆空间是申请好了的，当执行到new或者malloc时再向一开始的堆申请空间和写入数据。<br>当然堆空间可以自由扩展，但还是要先分配到缺省堆空间那边去。<br>new-&gt;malloc-&gt;heapalloc-&gt;virtualalloc-&gt;pagealloc<br><br>现在唯一不解的就是网上讲的mtd和mdd对堆得影响。。。。</p>
</blockquote>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微软实用绘图函数（158）]]></title>
      <url>https://xuecat.github.io/2015/01/28/158/</url>
      <content type="html"><![CDATA[<p><strong><em>当要绘制 渐变色，透明色，等一些高级点的绘制的时候，gdi其实是有方法的</em></strong></p>
<blockquote>
<p>afxdrawmanager.h这个里面全是封装好了，原来微软早就有了。以后要多看看这个了！！！！</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[复制字符的时候，字符优先级(105)]]></title>
      <url>https://xuecat.github.io/2015/01/21/105/</url>
      <content type="html"><![CDATA[<blockquote>
<p>今天用memcpy和strcpy，复制字符串。有很多冗余的数据。</p>
<blockquote>
<p>分析原因，估计是string的几次动态扩容造成的。于是限度长度复制，还是不行。</p>
<blockquote>
<p>后来用指定结尾符，(<em>_out)[sz_buffer.length()]=’\0’;注意符号优先级。开始的</em>_out[sz_buffer.length()]=’\0’;会导致赋值内存越界，因为符号优先级问题。</p>
</blockquote>
</blockquote>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OpenSSL字符]]></title>
      <url>https://xuecat.github.io/2015/01/15/104/</url>
      <content type="html"><![CDATA[<blockquote>
<p>我在用OpenSSL进行der编码解码的时候，有一个问题。无论如何无法获取。<br>后来用unsigned char排除了。</p>
</blockquote>
<p>从中学习到，对于密码和编码数据要用unsigned char进行表示，不然错误情况太头疼了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c++字符数字转换(103)]]></title>
      <url>https://xuecat.github.io/2015/01/09/103/</url>
      <content type="html"><![CDATA[<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">stringstream</span> ss;</div><div class="line">    <span class="comment">//字符串转换成数值</span></div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    ss &lt;&lt; <span class="string">"325"</span>;</div><div class="line">    ss &gt;&gt; n;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    ss.clear();</div><div class="line">    <span class="comment">//数值转换成字符串</span></div><div class="line">    <span class="built_in">string</span> str;</div><div class="line">    ss &lt;&lt; <span class="number">888</span>;</div><div class="line">    ss &gt;&gt; str;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    ss.clear();</div><div class="line">    str.empty();</div><div class="line">    <span class="comment">//数值转换成16进制表示的字符串</span></div><div class="line">    ss &lt;&lt; hex &lt;&lt; <span class="number">255</span>;</div><div class="line">    ss &gt;&gt; str;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    ss.clear();</div><div class="line">    n = <span class="number">0</span>;</div><div class="line">    <span class="comment">//16进制表示的字符串转换为数值</span></div><div class="line">    ss &lt;&lt; <span class="string">"FFA"</span>;</div><div class="line">    ss &gt;&gt; n;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[时间戳错误认识(101)]]></title>
      <url>https://xuecat.github.io/2015/01/07/101/</url>
      <content type="html"><![CDATA[<p>  今天查看时间戳后，发现OpenSSL原来封装了很多接口，有些函数我完全不用去写。</p>
<p>当初看ts部分代码时候，就想先看这么点，写一些，再继续。<br>结果后面的没看，现在才发现后面的接口已经这么成熟了。</p>
<p>后悔，一开始就想弄，没完全看下去。</p>
<p>这是一个重大的错误，我没有去了解以前的时间戳流程，没去认真读下代码。没有问他对自己代码的看法。这真心是个错误。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git发现(100)]]></title>
      <url>https://xuecat.github.io/2015/01/06/100/</url>
      <content type="html"><![CDATA[<p>git checkout哪个分支，就是哪个分支的代码。（用vs打开发现）</p>
<p>git pull会把冲突代码直接放入冲突文件中，需要自己修改。</p>
<p>本地删除文件，想git也删除跟踪用git rm 文件名。如果文件多了，git add -A自动全部更新。</p>
<p>修改了未commit： <code>git reset --hard</code> (git checkout .) [git clean -xdf]<br>(单个文件：<code>git checkout -- &lt;文件名&gt;</code>)<br>撤销git add(即保留本地修改): git reset . (单个文件撤销 <code>git rm --cached &lt;added_file_to_undo&gt;</code>)</p>
<p>修改了commit: <code>git reset --hard</code> <commit_id><br>(单个文件：git reset HEAD &lt;文件名&gt;)<br>撤销git commit但是保留本地修改： git reset commit_id </commit_id></p>
<p>修改了未提交： git diff &lt;文件名&gt; 查看具体修改<br>修改了已经提交： git show <hash> 查看具体修改</hash></p>
<p>revert是用于push提交后的 </p>
<p><code>git branch -va</code> 可以罗列远程分支</p>
<p>放弃修改直接回复：<br>今天改了点文件，但是一直<code>reset</code>不回去，好像是没有add的没有记录。气死了最后用<code>git checkout .</code>抛弃所有修改，直接返回。</p>
<hr>
<p>git删除文件<br>今天手动删除了很多文件，又新建了。然后才想起该用<code>git rm</code>，然而现在在一个一个弄好麻烦，又想保留现在修改。<br>发现<code>git add --all</code>或<code>git add -A</code>可以解决。</p>
<p>git 清理未跟踪的文件<br><code>git clean -f</code></p>
<h2 id="git-clean-fd-目录也一起删除"><a href="#git-clean-fd-目录也一起删除" class="headerlink" title="git clean -fd 目录也一起删除"></a><code>git clean -fd</code> 目录也一起删除</h2><p>放弃本地修改，使用远程库内容更新<br><code>git fetch --all</code>  //下载远程的库的内容<br><code>git reset --hard origin/master</code> </p>
<p><code>git stash</code>本地修改保存起来<br><code>git stash list</code> 查看保存信息<br><code>git pull</code> 更新远程内容<br><code>git stash pop</code> {缓存名}<br>解决冲突后走提交流程</p>
<hr>
<pre><code>今天想查看修改文件列表来着：git diff --name-only &lt;commit-1&gt; &lt;commit-2&gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[项目认识(99)]]></title>
      <url>https://xuecat.github.io/2015/01/02/99/</url>
      <content type="html"><![CDATA[<blockquote>
<p>我从**加入项目学到一些感悟。</p>
<blockquote>
<p>少话多做：老大把要求提出来后，先做，再提。<br>少问：他中问，请示，这让人很烦恼。就算老大不理，做了再说。</p>
</blockquote>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[项目(142)]]></title>
      <url>https://xuecat.github.io/2015/01/01/142/</url>
      <content type="html"><![CDATA[<p> <a href="http://www.epweike.com/soft/task/page2.html" target="_blank" rel="external">http://www.epweike.com/soft/task/page2.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[字符内存越界(98)]]></title>
      <url>https://xuecat.github.io/2015/01/01/98/</url>
      <content type="html"><![CDATA[<blockquote>
<p>第一个越界：     我用变长参数函数的时候<code>va_arg(t_args, char*)</code> 又把参数强制转换成int后发现，内存越界。</p>
<blockquote>
<p>分析原因：char<em>的内存界是char</em>指向的一个字节字符界。int<em>的内存界是int</em>指向的4个字节（32）字符界。    强制转换会根据类型偏移量进行数据转换，所以出现错误。</p>
</blockquote>
<p>第二个：我自己的失误，字符数组内存开辟小了（没有结尾的空字符），导致char*把后面的数据以前读了。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[string发现(97)]]></title>
      <url>https://xuecat.github.io/2015/01/01/97/</url>
      <content type="html"><![CDATA[<p>  今天用string的时候，发现这几处。</p>
<blockquote>
<ul>
<li>append传入的是指针，它会一个一个遍历开辟入栈（所以会开辟内部空间吧指针字符串全部复制进去）  </li>
<li>push_back是传入字符，只传入单个字符。</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[栈和堆(95)]]></title>
      <url>https://xuecat.github.io/2014/12/11/95/</url>
      <content type="html"><![CDATA[<p>   今天收集了资料研究了下，希望以后扩充。</p>
<p>先说编译回顾下。1、预处理 2、编译（汇编生成）3、汇编（机器指令）4、链接</p>
<p>再说说二进制文件。</p>
<p>对于一个程序有四个空间：</p>
<pre><code>栈： 由操作系统提供，是个数据结构。底层支持，专门寄存器处理。先进后出。

堆：任意存取，首地址记录堆空间大小，可以动态扩容。由c/c++提供实现，设有专门算法进行分配销毁，有记录链表。(方式地址到高地址遍历).我在windows上用vc和vs2012发现堆空间的遍历是高地址到底地址，而我在Ubuntu上发现堆空间的遍历是底地址到高地址（是操作系统的原因？）

数据段：
    1、只读数据段；const修饰变量（不会被更改）

    2、已初始化读写数据段；静态变量被初始化/全局变量被初始化

    3、未被初始化数据段；静态、全局变量未被初始化。（Linux下有bss段保存）

程序代码区：函数体二进制代码。
</code></pre><p>然后我们讲下函数调用：</p>
<p>  压入参数（顺序视编译器而定；一般从右到左）</p>
<p>  压入函数返回值地址</p>
<p>  开辟栈空间，根据压入参数，执行函数二进制代码</p>
<p>  回收栈堆空间，返回返回值</p>
<p>然后讲程序调用：</p>
<p>  我认为在程序开始时，堆空间会一起开辟；但根据代码运行开辟；但必须有一个记录链表（c/c++实现）。 遇见开辟堆空间时，算法先找到第一个满足大小的连续空间来开辟到程序堆空间。若没有就优化碎片，再遍历。所以需要程序自己free内存来从链表删除，系统添加。<br>  所谓的内存泄露，我想也是链表上还存在内存地址吧！</p>
<p>  操作系统也是有链表来记录空闲空间的，来分配和扩容。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[const进阶]]></title>
      <url>https://xuecat.github.io/2014/12/10/94/</url>
      <content type="html"><![CDATA[<p>   const char* p = “greet” 只是const数据</p>
<p>   char* const p = “greet” 只是const指针(写法可能变化)</p>
<p>   const char* const p = “greet” const指针和数据</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[动态链接库(96)]]></title>
      <url>https://xuecat.github.io/2014/12/07/96/</url>
      <content type="html"><![CDATA[<p>  首先，windows、Linux对动态链接库的访问都是通过名字来寻找的。</p>
<p><strong>先比较它们的约定：</strong></p>
<p> 来分析下windows的约定了。</p>
<pre><code>__cdecl是C/C++和MFC程序默认使用的调用约定，也可以在函数声明时加上__cdecl关键字来手工指定。采用__cdecl约定时，函数参数按照从右到左的顺序入栈，并且由调用函数者把参数弹出栈以清理堆栈。因此，实现可变参数的函数只能使用该调用约定。由于每一个使用__cdecl约定的函数都要包含清理堆栈的代码，所以产生的可执行文件大小会比较大。

__stdcall大多约定用于调用Win32 API函数。是从右往左压参数，由被调者清理参数的相关堆栈（也是windows的动态库用_stdcall extern &quot;C&quot;。让库去清理栈空间）

__fastcall约定用于对性能要求非常高的场合。__fastcall约定将函数的从左边开始的两个大小不大于4个字节（DWORD）的参数分别放在ECX和EDX寄存器，其余的参数仍旧自右向左压栈传送，被调用的函数在返回前清理传送参数的堆栈。
</code></pre><p>  以上对Linux无效。</p>
<p><strong>再比较它们的接口修饰符：</strong></p>
<p>  windows：</p>
<pre><code>__declspec(dllexport) 从 DLL 导出数据、函数、类或类成员函数。
__declspec(dllimport) dll中这样导出全局变量、导出类的静态成员方面
</code></pre><p>  Linux：</p>
<pre><code>Linux动态库会把所有函数导出，不需要这些修饰符。
</code></pre><p><strong>相同</strong></p>
<p>  extern “C”关键字由此而生, 它只是告诉C++编译器按照C的方法去编译,这样就不会出现重命名问题, 当然被extern “C” 限制的函数也无法重载了.（没有类的概念）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[夏日(93)]]></title>
      <url>https://xuecat.github.io/2014/12/01/93/</url>
      <content type="html"><![CDATA[<p><img src="/picture/p.png" alt=""></p>
<p> 很早就想写，今天突然想起：</p>
<p> 2007年的夏天，她像夏日里荷叶上泛着月光的露珠。</p>
<p>愿她一生美好！<br>纪念最好的回忆！<br>我的朋友！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[内存分配函数 malloc realloc calloc(92)]]></title>
      <url>https://xuecat.github.io/2014/11/21/92/</url>
      <content type="html"><![CDATA[<p>  alloca: 是向栈申请内存,因此无需释放.  </p>
<p>  calloc：初始化内存，设置为0. calloc在动态分配完内存后，自动初始化该内存空间为零，而malloc不初始化，里边数据是随机的垃圾数据。</p>
<p>  malloc不能初始化所分配的内存空间，   <strong>如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0;反之, 如果这部分内存曾经被分配过,则其中可能遗留有各种各样的数据</strong>           可以看出和memset的联合使用时必须的。  也呼应了前面内存释放只是改变权限问题。</p>
<p>  realloc：是从堆上分配内存的.当扩大一块内存空间时，realloc()试图直接从堆上现存的数据后面的那些字节中获得附加的字节，如果能够满足，自然天下太平；如果数据后面的字节不够，问题就出来了，那么就使用堆上第一个有足够大小的自由块，现存的数据然后就被拷贝至新的位置，而老块则放回到堆上.这句话传递的一个重要的信息就是数据可能被移动</p>
<p>  另外说下指针：今天用OpenSSL的错误。</p>
<pre><code>char* demo = (char*)calloc(0, 10);
  memset(demo, 0, 10);
  if (demo == NULL) {
      cout &lt;&lt; &quot;wangiu&quot; &lt;&lt; endl;
  }//就是置0了，也不会等于NULL,  要自己指定。
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IfileDialog(91)]]></title>
      <url>https://xuecat.github.io/2014/11/17/91/</url>
      <content type="html"><![CDATA[<p>   在过去（Vista之前），在win32中是使用GetOpenFileName或是GetSaveFileName API来实现，在MFC中使用CFileDialog类来实现。现在在Vista之后的系统，有了一种新的实现方法，就是今天要讲的，通过IFileDialog接口，这是一个COM接口，从它继承之后有两个接口，一个是IFileOpenDialog，另外一个IFileSaveDialog。这两个接口分别实现了打开文件对话框和另存为文件对话框</p>
<p>  <a href="http://blog.csdn.net/xinzhiyounizhiyouni/article/details/22430735" target="_blank" rel="external">http://blog.csdn.net/xinzhiyounizhiyouni/article/details/22430735</a></p>
<p>  我想用这个的效果应该更好吧！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[类成员指针(90)]]></title>
      <url>https://xuecat.github.io/2014/11/14/90/</url>
      <content type="html"><![CDATA[<figure class="highlight c"><figcaption><span>先看代码：++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(Baseclass::*ptr)</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//我先指定ptr是一个返回为void的函数指针</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">itdemo</span><span class="params">(Baseclass* p, ptr fun)</span> </span>&#123;</div><div class="line">	(p-&gt;*fun)(<span class="number">2</span>);<span class="comment">//调用类成员函数指针必须指定类对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	Driverclass d;</div><div class="line">	Baseclass b;</div><div class="line">	itdemo(&amp;d, &amp;Baseclass::demo);<span class="comment">//测试后发现，支持多态，估计是因为虚函数指针变化了。</span></div><div class="line"></div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">	<span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[openssl(89)]]></title>
      <url>https://xuecat.github.io/2014/11/09/89/</url>
      <content type="html"><![CDATA[<p>OpenSSL，把所有的类型（int,long,结构体,UTC等）变成它自己的ASN格式，封装。 这些值的传输全用der编码（字节上）传输通信。</p>
<pre><code>int TS_MSG_IMPRINT_set_algo(TS_MSG_IMPRINT *a, X509_ALGOR *alg);

X509_ALGOR:表示算法  是x509.h（一个表示算法，一个表示需要参数数据）
TS_MSG_IMPRINT：时间戳数据，国标有介绍

dup函数；貌似就是复制函数。

string_to_hex 字符转ascii编码的十六进制结果

ASN1_TYPE 表示任意类型，所有的ASN1类型都可以代表。

set函数，向已有内存写入数据

从结构体中获取结构体，不能free。

dup获取结构体，要free。（它内部开辟）

不要尝试去strlen 编码字符串（字节编码），这样永远是错误的。

我用字符串读取保存时间戳结构体，bio示例。d2i_TS_RESP_bio居然有错误！
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[for循环习惯(87)]]></title>
      <url>https://xuecat.github.io/2014/11/08/87/</url>
      <content type="html"><![CDATA[<figure class="highlight c"><figcaption><span>for循环也是有讲究的。看代码：++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">bad：</div><div class="line"></div><div class="line">	var listData = document.getElementsByTagName(<span class="string">"li"</span>);</div><div class="line"></div><div class="line">	<span class="keyword">for</span>（var i = <span class="number">0</span>; i &lt; listData.length; i++)</div><div class="line">	</div><div class="line">	&#123;</div><div class="line">	</div><div class="line">	<span class="comment">//对listData进行操作</span></div><div class="line">	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">good：</div><div class="line"></div><div class="line">	<span class="comment">//优化后的代码</span></div><div class="line">	</div><div class="line">	var listData = document.getElementByTagName(<span class="string">"li"</span>);</div><div class="line">	</div><div class="line">	<span class="keyword">for</span>（var i = <span class="number">0</span>, len = listData.length; i &lt; len; i++)</div><div class="line">	&#123;</div><div class="line">	</div><div class="line">	<span class="comment">//对listData进行操作</span></div><div class="line">	</div><div class="line">	&#125;</div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux指令学习(88)]]></title>
      <url>https://xuecat.github.io/2014/11/08/88/</url>
      <content type="html"><![CDATA[<p>apt-get purge 软件名</p>
<p>apt-get (按tab会自动罗列软件名匹配软件)</p>
<p>安装程序最后别用root用户安装</p>
<p>su - git :切换到git管理用户</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[openssl、libcurl]]></title>
      <url>https://xuecat.github.io/2014/11/04/86/</url>
      <content type="html"><![CDATA[<p>  今天晚上做了啥，我想想都可怕。</p>
<p>第一个错误：Linux的OpenSSL编译，无法找到库。我当时用cmake设置了库目录的，还是无法。</p>
<p>  最后发现的原因：Linux下默认的静态库是以lib开头的，我去！这个居然忘了，伤心。</p>
<p>第二个错误：我想编译libcurl来更新东西，找了尼玛半天都没找到。。。。。。无语了！</p>
<p>  最后发现原因：我嚓，在它里面的目录居然有个叫project/vc。我嚓，直接用vs打开呀。。。<br>我去，现在的第三方库真是太智能了，把平台都给你搞好了。。</p>
<p>  还有一个：编译库，发现不能用静态库编译，必须要动态库。唉伤心，我也不知道。没法了，只好这样。</p>
<p>第三个错误：编译libcurl静态库，windows上静态库老是编译不好，已经添加了网页上去了（自己看）。</p>
<p>看Linux的，编译时发现</p>
<pre><code>../../../lib/Win32/libcurl.a(content_encoding.o):content_encoding.c:(.text+0x37): undefined reference to `inflateEnd&apos;

../../../lib/Win32/libcurl.a(content_encoding.o):content_encoding.c:(.text+0xbb): undefined reference to `inflate&apos;

../../../lib/Win32/libcurl.a(content_encoding.o):content_encoding.c:(.text+0x105): undefined reference to `inflateEnd&apos;

../../../lib/Win32/libcurl.a(content_encoding.o):content_encoding.c:(.text+0x156): undefined reference to `inflateReset&apos;
</code></pre><p>等这些错误，纠结死了，后来发现这些代码是zlib上的，想起自己还没有安装zlib这个库。于是知道了<br>要么我安装这个第三方库，要么不去生成它。</p>
<p>所以， –without-zlib完美解决。</p>
<p>附加： ldap.c:(.text+0x91): undefined reference to `ldap_url_parse’错误</p>
<p>./configure –disable-ldap –disable-ldaps （同样也有shared错误） </p>
<p>学习：以后第三方库，还是要多看下呀，人家都弄的很智能了。不需要我去困扰了！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c++正则(85)]]></title>
      <url>https://xuecat.github.io/2014/10/24/85/</url>
      <content type="html"><![CDATA[<p>支持宽字符，（有w_函数）</p>
<p>(“(\w+)(\.|_)?(\w*)@(\w+)(\.(\w+))+”);</p>
<p> 首先注意‘()’表示将正则表达式分成子表达式，每个‘()’之间的内容表示一个子表达式；</p>
<p>‘\’是一个转义字符，‘\’表示扔掉第二个‘\’的转义特性，‘\w+’表示匹配一个或多个单词，‘+’表示重复一次或者多次，因此第一个子表达式的意思就是匹配一个或者多个单词；</p>
<p>接着看第二个子表达式，‘|’表示选择，出现‘.’或者‘<em>’，后面的‘?’表示该子表示出现一次或者零次，因此第二个子表示表示‘.’或‘</em>’出现不出现都匹配。</p>
<p>第三个子表达式表示出现一个单词，‘*’表示任意个字符。</p>
<p>(\d{1,3}):(\d{1,3}):(\d{1,3}):(\d{1,3})</p>
<p>首先还是通过‘()’将这个串分成几个子表达式，其中\d表示匹配一个数字，{,}表示数字的个数，例如{1,3}可以理解为匹配一个小于1000的数字</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C语言中的一些小知识(84)]]></title>
      <url>https://xuecat.github.io/2014/10/24/84/</url>
      <content type="html"><![CDATA[<pre><code>前面加0b表示二进制
</code></pre><p>　　加0x表示十六进制</p>
<p>　　数字前加0表示八进制</p>
<p>　　‘ ‘ //ASCII值是63</p>
<p>　　‘\077’ //是8进制表示’ ‘，0可以省略，因为C,C++规定不允许使用斜杠加10进制数来表示字符</p>
<p>　　‘\0x3F’ //是16进制表示’ ‘</p>
<p>　　<br>关键字    位长(字节)    范围    格式化字符串<br>char    1    -128..127（或0..255，与体系结构相关）     %c</p>
<p>unsigned char    1    0..255     </p>
<p>signed char    1    -128..127     </p>
<p>int        2(16位系统)或4         -32768..32767 或-2147483648..2147483647     %i, %d</p>
<p>unsigned int    2或4        0..65535 或0..4294967295           %u</p>
<p>signed int    2 或4    -32768..32767 或-2147483648..2147483647     %i, %d</p>
<p>short int    2    -32768..32767     %hi</p>
<p>unsigned short    2    0..65535     %hu</p>
<p>signed short    2    -32768..32767     long int    4 或8[3]    -2147483648..2147483647或-9223372036854775808..9223372036854775807     %li, %ld</p>
<p>unsigned long    4 或8    0..4294967295 或0..18446744073709551615     %lu</p>
<p>signed long    4 或8    -2147483648..2147483647或-9223372036854775808..9223372036854775807    </p>
<p>long long    8    -9223372036854775808..9223372036854775807     %lli</p>
<p>unsigned long long    8    0..18446744073709551615     %llu</p>
<p>float    4    3.4x10 38..3.4x10+38 (7 sf)     %f, %e, %g</p>
<p>double    8    1.7x10 308..1.7x10+308 (15 sf)     %f, %e, %g</p>
<p>long double    8 或以上    编译器相关     %Lf, %Le, %Lg</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[演讲认识]]></title>
      <url>https://xuecat.github.io/2014/10/23/82/</url>
      <content type="html"><![CDATA[<p>   今天演讲，我自己认识到几个问题。</p>
<p><strong>演讲的时候：</strong></p>
<p>1、不能让别人觉是是在应付他（我简单的说几句，这些就不要来了）。</p>
<p>2、用“大家都应该知道吧”这句来，给人感觉是应付一些问题（要从细小的东西讲出大的东西才是好的）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[减少编译依赖2(83)]]></title>
      <url>https://xuecat.github.io/2014/10/23/83/</url>
      <content type="html"><![CDATA[<p>   今天看书，有这句：</p>
<pre><code>#include &lt;a.h&gt;
class b;
class c;
b fun();
c demo();

main() {}
</code></pre><p>思想：头文件用class进行前置声明，比包含相关头文件，要依赖小。</p>
<p>这个对.h文件的申明是没问题的，对.cpp文件的定义就必须要包含头文件了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac安装(81)]]></title>
      <url>https://xuecat.github.io/2014/10/17/81/</url>
      <content type="html"><![CDATA[<p>记录下：</p>
<p>U盘安装最好用2.0接口，3.0接口要驱动</p>
<p>（系统：osx mavericles 10.9）</p>
<p>启动盘：</p>
<p>1、新加卷不能格式化</p>
<p>2、驱动替换：Extra文件替换（保留文件smbios和org，Facke复制到SLE）</p>
<p>3、去掉显卡驱动，去掉电源驱动</p>
<p>4、安全启动-v -x -f</p>
<p>5、进入安装界面</p>
<p>6、5步如果出现错误：不能抹掉的字卷磁盘（格式化要安装盘为FAT32, 手动强制”修改分区ID”为AF）</p>
<p>7、随时移动，确保不能黑屏</p>
<p>安装盘：</p>
<p>8、复制extra到安装盘，去掉文件里面的电源驱动</p>
<p>8.5、修改启动模式，修改屏幕分辨率。extra文件下找文件修改</p>
<p>9、完全启动，补打驱动（kext Utility）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[继承大小(80)]]></title>
      <url>https://xuecat.github.io/2014/10/16/80/</url>
      <content type="html"><![CDATA[<p>  虚函数的继承会增加派生类的大小（虚函数指针大小）</p>
<p>虚继承类会增加派生类的大小（虚继承指针大小）</p>
<p>但类的大小还要考虑内存对齐值。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[王道]]></title>
      <url>https://xuecat.github.io/2014/10/14/79/</url>
      <content type="html"><![CDATA[<p><img src="/picture/f.jpg" alt=""></p>
<p>   Rider生前东征西讨，从西亚到北非，征服了波斯与印度，他与他的军团却不是为了权利或是财富，只是为了希望能到达“世界的尽头”亲眼看一看传说中的“无垠之海（Oceanus）”。他崇尚的是王应该被自己的子民所崇拜。</p>
<p><strong>（“身为王，就必须比任何人拥有强烈的欲望，比任何人都豪放，比任何人都易怒。他应该是一个包含着清与浊的，比任何人都要真实的人类。只有这样，臣子才能被王所折服，人民的心里才会有‘如果我是王就好了’这样的憧憬!”<br>）</strong></p>
<p><em>王也是人，一个真实的人，只有这样臣子才不会觉得王高高在上，而是认为，只要我有能力也能成为新的王，这样的国家会走上强盛的道路。</em><br>————————————————————————————————————————————————————————————</p>
<p><em>对于金闪闪而言讨论王应该做什么是一件完全没有意义的是，因为他就是王、全世界唯一的王，他做的事就是王所应该去做的事，他是正确也是法律。作为一个极度崇拜自己的人，他对于自己所做的事不会有任何的迷茫与忧郁，因为他所做的所有的事都是对的。</em></p>
<p>————————————————————————————————————————————————————————————<br>对于Saber而言王应该为国家而献身，应该为自己的子民付出自己的一切。</p>
<p><strong>（正确的统治、正确的秩序，这是所有臣民所期待的）-（“人们通过王能够了解法律和秩序。王所体现的不应该是那种会随着王的死亡而一同消逝的东西，而是一种更为尊贵的东西。”）<br>王所做的事拯救自己的子民，制定正确的法律与秩序来拯救自己的国家与子民。</strong></p>
<p>所以Saber才会如此执着于获得圣杯来拯救自己的大不列颠王国。</p>
<p>————————————————————————————————————————————————————————————</p>
<p>但是在Archer和Rider的质疑与嘲弄之下Saber怀疑了自己作为王的道路，兰斯洛斯对自己的仇恨，义子对自己的叛乱，国家的最终分崩离析使得Saber怀疑起自己的选择，变得迷茫起来（那时好萌啊…萌啊…萌）</p>
<p><strong>其实王没有绝对正确的道路，绝对的正确本来就不存在于世上，真正应该做的是像Rider所说的那样（“如果我的决断以及我的臣子们导致了这样的结果，那么毁灭是必然的。我会哀悼，也会流泪，但我绝不后悔。”）</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[程序软件(77)]]></title>
      <url>https://xuecat.github.io/2014/10/14/77/</url>
      <content type="html"><![CDATA[<pre><code>//quicksilver mac下面的软件。
//alfred mac下的软件
//caffeine mac下的软件
//eudic mac下的软件
//Parallels Desktop mac下软件
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[fate zero]]></title>
      <url>https://xuecat.github.io/2014/10/13/76/</url>
      <content type="html"><![CDATA[<p><strong>可胜不可灭</strong></p>
<p><strong>可称霸不可羞辱</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c字符串比较函数(75)]]></title>
      <url>https://xuecat.github.io/2014/10/10/75/</url>
      <content type="html"><![CDATA[<pre><code>char *strchr(const char *string, int c);

查找字符c字符串string首现位置, NULL结束符包含查找.

返指针, 指向字符c字符串string首现位置, 没找, 则返NULL.




char *strrchr(const char *string, int c);

查找字符c字符串string现位置, string进行反序搜索, 包含NULL结束符.

返指针, 指向字符c字符串string现位置, 没找, 则返NULL.




char *strstr(const char *string, const char *strSearch);

字符串string查找strSearch串.

返串strSearchstring首现位置指针. 没找串strSearch, 则返NULL. 串strSearch空串, 函数返string值. 




int strcmp(const char *string1, const char *string2);

比较字符串string1string2.

返值&lt; 0, 表示string1于string2;
返值0, 表示string1等于string2;
返值&gt; 0, 表示string1于string2.




int stricmp(const char *string1, const char *string2);

比较字符串string1string2strcmp同, 比较写字母版本.

返值与strcmp相同.




int strcmpi(const char *string1, const char *string2);

等价于stricmp函数, 提供向兼容版本.




int strncmp(const char *string1, const char *string2, size_t count);

比较字符串string1string2比较前面count字符. 比较程, 任何字符串度于count, 则count较短字符串度取代. 两串前面字符都相等, 则较短串要.

返值&lt; 0, 表示string1串于string2串;
返值0, 表示string1串等于string2串;
返值&gt; 0, 表示string1串于string2串.




int strnicmp(const char *string1, const char *string2, size_t count);

比较字符串string1string2比较前面count字符. 与strncmp同, 比较写字母版本.

返值与strncmp相同.




char *strtok(char *strToken, const char *strDelimit);

strToken 串查找标记, strDelimit字符集则指定前查找调用能遇界符.

返指针, 指向strToken找标记. 找标记, 返NULL值. 每调用都修改strToken内容, 用NULL字符替换遇每界符. 

内存块比较函数参考面：
void *memchr(const void *buf, int c, size_t count);

buf前面count字节查找首现字符c位置. 找字符c或者已经搜寻count字节, 查找即停止.

操作功则返buf首现c位置指针, 否则返NULL.




void *_memccpy(void *dest, const void *src, int c, size_t count);

src复制0或字节字符dest. 字符c复制或者count字符复制, 复制停止.

字符c复制, 函数返字符面紧挨字符位置指针. 否则返NULL.




int memcmp(const void *buf1, const void *buf2, size_t count);

比较buf1buf2前面count字节.

返值&lt; 0, 表示buf1于buf2;
返值0, 表示buf1等于buf2;
返值&gt; 0, 表示buf1于buf2.




int memicmp(const void *buf1, const void *buf2, size_t count);

比较buf1buf2前面count字节. 与memcmp同, 区写.

返值同.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[字符截取替换(78)]]></title>
      <url>https://xuecat.github.io/2014/10/01/78/</url>
      <content type="html"><![CDATA[<pre><code>//    &apos;;&apos;字符为界
size_t pos = 0, found = 0;
while (found != wstring::npos)
{
    found = m_strData.find(L&quot;;&quot;, pos);
    m_strLineData.push_back(wstring(m_strData, pos, found - pos));
    pos = found + 1;
}



//&apos; &apos;为界（空格）
wistringstream line(wstr);
wstring word;

while (line &gt;&gt; word) {
    temp.push_back(word);
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[dulib里面的头文件包含(74)]]></title>
      <url>https://xuecat.github.io/2014/10/01/74/</url>
      <content type="html"><![CDATA[<p>他头文件用namespace包括。</p>
<p>cpp文件也用namespace包括。</p>
<p>cpp包含个stadx.h文件</p>
<p>stadx.h文件包含duilib.h文件</p>
<p>所有的东西写在duilib.h文件里面</p>
<p>亮点在cpp文件包括，然后包含。导致头文件不用包含。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[static作用(73)]]></title>
      <url>https://xuecat.github.io/2014/10/01/73/</url>
      <content type="html"><![CDATA[<p>static作用（修饰函数、局部变量、全局变量）</p>
<p>当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性</p>
<p>如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。</p>
<p>利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。Static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏，而对于变量，static还有下面两个作用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[编程忠告(72)]]></title>
      <url>https://xuecat.github.io/2014/09/29/72/</url>
      <content type="html"><![CDATA[<p>对学习编程者的忠告：<br>多用小脑和手，少用大脑、眼睛和嘴，会更快地学会编程！</p>
<p>眼过千遍不如手过一遍！</p>
<p>书看千行不如手敲一行！</p>
<p>手敲千行不如单步一行！</p>
<p>单步源代码千行不如单步Debug版对应汇编一行！</p>
<p>单步Debug版对应汇编千行不如单步Release版对应汇编一行！</p>
<p>单步类的实例“构造”或“复制”或“作为函数参数”或“作为函数返回值返回”或“参加各种运算”或“退出作用域”的语句对应的汇编代码几步后，</p>
<p>就会来到该类的“构造函数”或“复制构造函数”或“运算符重载”或“析构函数”对应的C/C++源代码处。</p>
<p>VC调试时按Alt+8、Alt+7、Alt+6和Alt+5,打开汇编窗口、堆栈窗口、内存窗口和寄存器窗口看每句C对应的汇编、单步执行并观察相应堆栈、内存和寄存器变化，</p>
<p>这样过一遍不就啥都明白了吗。</p>
<p>对VC来说，所谓‘调试时’就是编译连接通过以后，按F10或F11键单步执行一步以后的时候，或者在某行按F9设了断点后按F5执行停在该断点处的时候。</p>
<p>（Turbo C或Borland C用Turbo Debugger调试,Linux或Unix下用GDB调试时,看每句C对应的汇编并单步执行观察相应内存和寄存器变化。）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[自定义消息，多个函数响应：宏(71)]]></title>
      <url>https://xuecat.github.io/2014/09/28/71/</url>
      <content type="html"><![CDATA[<p>ON_COMMAND 以及 ON_COMMAND_RANGE 是用于处理菜单项或工具栏按钮的命令消息的<br>对于复选框这样的控件，请使用ON_CONTROL_RANGE</p>
<ol>
<li><p>打开 resource.h，将你的复选框控件ID进行连续编号，例如1001，1002…</p>
</li>
<li><p>在对话框类的头文件中添加公有成员函数：afx_msg void OnCheckBox(UINT uID) ;</p>
</li>
<li><p>在对话框类的cpp文件中BEGIN_MESSAGE_MAP(CTestDlg, CDialog) 的 //}}AFX_MSG_MAP下添加代码 ON_CONTROL_RANGE(BN_CLICKED,1001,1003,OnCheckBox)</p>
</li>
<li><p>然后在cpp文件中添加函数void CTestDlg::OnCheckBox(UINT uID) {}</p>
</li>
<li><p>在函数内判断 uID，来确定用户单击了哪项复选框，并作相应处理。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[already defined in *.obj(70)]]></title>
      <url>https://xuecat.github.io/2014/09/28/70/</url>
      <content type="html"><![CDATA[<p>首先注意不能在.h头文件中定义全局变量，否则只要其他文件包括了该头文件，就会出现already defined in *.obj的错误。</p>
<p>应该把全局变量放在.cpp文件中定义，然后在其他文件中用到该变量时用extern声明一下。</p>
<p>即使在.h中定义全局变量，用extern可以避免。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[duilib自定义(68)]]></title>
      <url>https://xuecat.github.io/2014/09/24/68/</url>
      <content type="html"><![CDATA[<p>我擦，又是漫长的调试。</p>
<p>自定义的窗口居然这样，服了。</p>
<p>原来我在OnFinalMessage里面已经delete了</p>
<p>所以后面的再次调用出错。写下，记录。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[list vector deque的区别(69)]]></title>
      <url>https://xuecat.github.io/2014/09/24/69/</url>
      <content type="html"><![CDATA[<p><strong>vector</strong></p>
<p>表示一段连续的内存区域每个元素被顺序存储在这段内存中对vector的随机访问比如先访问元素5 然后访问15然后再访问7等等效率很高，因为每次访问离vector起始处的位移都是固定的。</p>
<p>但是在任意位置而不是在vector末尾插人元素则效率很低 ，因为它需要把待插入元素右边的每个元素都拷贝一遍。</p>
<p>类似地删除任意一个而不是vector 的最后一个元素效率同样很低。<br>因为待删除元素右边的每个元素都必须被复制一遍这种代价对于大型的复杂的类对象来说尤其大。</p>
<p><strong>deque</strong></p>
<p>一个deque 也表示一段连续的内存区域但是与vector不同的是它支持高效地在其首部插入和删除元素它通过两级数组结构来实现一级表示实际的容器第二级指向容器的首和尾</p>
<p><strong>list</strong></p>
<p>List表示非连续的内存区域并通过一对指向首尾元素的指针双向链接起来从而允许向前和向后两个方向进行遍历在list的任意位置插入和删除元素的效率都很高</p>
<p>指针必须被重新赋值但是不需要用拷贝元素来实现移动</p>
<p>另一方面它对随机访问的支持并不好，访问一个元素需要遍历中间的元素另外每个元素还有两个指针的额外空间开销  </p>
<p><strong>如果我们需要随机访问一个容器则vector要比list好得多 。</strong></p>
<p><strong>如果我们已知要存储元素的个数则vector 又是一个比list好的选择。</strong></p>
<p><strong>如果我们需要的不只是在容器两端插入和删除元素则list显然要比vector好</strong></p>
<p><strong>除非我们需要在容器首部插入和删除元素否则vector要比deque好</strong></p>
<p>1 vector向量 相当于一个数组</p>
<p>在内存中分配 一块连续的内存空间进行存储。支持不指定vector大小的存储。STL内部实现时，首先分配一个非常大的内存空间预备进行存储，即 capacituy（）函数返回的大小，当超过此分配的空间时再整体重新放分配一块内存存储，这给人以vector可以不指定vector即一个连续内存 的大小的感觉。通常此默认的内存分配能完成大部分情况下的存储。</p>
<p>优点：</p>
<pre><code>(1) 不指定一块内存大小的数组的连续存储，即可以像数组一样操作，但可以对此数组
进行动态操作。通常体现在push_back() pop_back()

(2) 随机访问方便，即支持[ ]操作符和vector.at()

(3) 节省空间。
</code></pre><p>缺点：</p>
<pre><code>(1) 在内部进行插入删除操作效率低。
(2) 只能在vector的最后进行push和pop，不能在vector的头进行push和pop。
(3) 当动态添加的数据超过vector默认分配的大小时要进行整体的重新分配、拷贝与释放
</code></pre><p>2 list双向链表</p>
<p>每一个结点都包括一个信息快Info、一个前驱指针Pre、一个后驱指针Post。可以不分配必须的内存大小方便的进行添加和删除操作。使用的是非连续的内存空间进行存储。</p>
<p>优点：<br>    (1) 不使用连续内存完成动态操作。<br>    (2) 在内部方便的进行插入和删除操作<br>    (3) 可在两端进行push、pop<br>缺点：<br>    (1) 不能进行内部的随机访问，即不支持[ ]操作符和vector.at()<br>    (2) 相对于verctor占用内存多</p>
<p>3 deque双端队列 double-end queue</p>
<p>deque是在功能上合并了vector和list。</p>
<p>优点：<br>    (1) 随机访问方便，即支持[ ]操作符和vector.at()<br>    (2) 在内部方便的进行插入和删除操作<br>    (3) 可在两端进行push、pop</p>
<p>缺点：<br>    (1) 占用内存多</p>
<p>使用区别：</p>
<p>1 如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector</p>
<p>2 如果你需要大量的插入和删除，而不关心随即存取，则应使用list</p>
<p>3 如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[间接访问权限（基类派生类）(67)]]></title>
      <url>https://xuecat.github.io/2014/09/23/67/</url>
      <content type="html"><![CDATA[<figure class="highlight c"><figcaption><span>先看代码：++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Baseclass</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Baseclass() &#123;</div><div class="line">	&#125;</div><div class="line">	~Baseclass()&#123;&#125;;</div><div class="line">	</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">demo</span> <span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"asdf"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> Driverclass : <span class="keyword">public</span> Baseclass</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Driverclass()&#123;&#125;</div><div class="line">	~Driverclass()&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"qwe"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	Baseclass* pb;</div><div class="line">	Baseclass*  p = <span class="keyword">new</span> Baseclass;</div><div class="line">	Driverclass* d = <span class="keyword">new</span> Driverclass;</div><div class="line">	pb = p;</div><div class="line">	pb-&gt;demo(<span class="number">2</span>);</div><div class="line">	pb = d;</div><div class="line">	pb-&gt;demo(<span class="number">2</span>);</div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看demo虽然是driverclass的私有函数，可通过pb我们却访问到了他的私有成员。</p>
<p>如果直接：d-&gt;demo(2)必定会报错。</p>
<p>因为demo在基类就被声明为public了，所以如此的间接访问是可以的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SIGPIPE信号(55)]]></title>
      <url>https://xuecat.github.io/2014/09/20/55/</url>
      <content type="html"><![CDATA[<p>使用libevent编写websocket服务端时遇到了一个问题：</p>
<p>浏览器与服务端建立连接后，若刷新或关闭浏览器窗口（未监听相应事件并处理），服务端无法得知连接断开，按理说，这种情况属于client异常终止，跟拔网线的情况类似。这种情况下，服务端不知情，仍保留此连接，仍按照既定逻辑向client写数据，写了两次后，服务端程序终止（多次测试，均是第2次后终止），不是崩溃，是异常终止，非常不解。</p>
<p> ，得知是SIGPIPE信号导致程序终止。</p>
<p>查了相关资料，大致明白：连接建立，若某一端关闭连接，而另一端仍然向它写数据，第一次写数据后会收到RST响应，此后再写数据，内核将向进程发出SIGPIPE信号，通知进程此连接已经断开。而SIGPIPE信号的默认处理是终止程序，导致上述问题的发生。</p>
<p>为避免这种情况，可以选择忽略SIGPIPE信号，不执行任何动作。</p>
<pre><code>#include &lt;signal.h&gt;
//SIGPIPE ignore
struct sigaction act;
act.sa_handler = SIG_IGN;
if (sigaction(SIGPIPE, &amp;act, NULL) == 0) {
    LOG(&quot;SIGPIPE ignore&quot;);
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[输出中文(66)]]></title>
      <url>https://xuecat.github.io/2014/09/20/66/</url>
      <content type="html"><![CDATA[<pre><code> cout.imbue(locale(&quot;&quot;));
char data[] = &quot;dfwe玩GIS股份&quot;;
for (size_t i = 0; i &lt; strlen(data); i++)
{
    cout &lt;&lt; data[i] &lt;&lt; endl;
}

cout &lt;&lt; data;
</code></pre><p>结果：第一个无法输出中文，第二个可以。</p>
<p>分析：昨天已经讲了，今天写下只是写个例子。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多层窗口(54)]]></title>
      <url>https://xuecat.github.io/2014/09/20/54/</url>
      <content type="html"><![CDATA[<p>总于过期了，把上面的东西搬过来</p>
<p> 我已经被这个多层窗口弄晕了，快死了。<br>首先，要使用透明窗口函数：</p>
<pre><code>SetLayeredWindowAttributes， updataLayeredWindowAttributes，
//就必须设置窗口属性为WS_EX_LAYERED。
//然后，这两个函数完全可以混合使用，
</code></pre><p>  updataLayeredWindowAttributes会拦截wm_paint消息，窗口上的所有东西，重绘，必需自己处理。前一个函数则不会这样。</p>
<p>WS_EX_TRANSPARENT这个属性，会让窗体透明，真正的透明，不响应任何消息的透明。就只能自己去处理画图的那种。</p>
<p>窗体透明控件不透明：</p>
<pre><code>this-&gt;SetBackgroundColor(RGB(255, 255, 255), TRUE);
SetLayeredWindowAttributes(RGB(255, 255, 255), 200, LWA_ALPHA | LWA_COLORKEY);
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[内存对齐偏移量(56)]]></title>
      <url>https://xuecat.github.io/2014/09/20/56/</url>
      <content type="html"><![CDATA[<p> 编译器对变量存储的一个特殊处理。为了提高CPU的存储速度，编译器对一些变量的起始地址做了“对齐”处理</p>
<p>。在默认情况下，规定各成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数。<br>类型</p>
<p>对齐方式（变量存放的起始地址相对于结构的起始地址的偏移量）</p>
<p>Char 偏移量必须为sizeof(char)即1的倍数</p>
<p>int 偏移量必须为sizeof(int)即4的倍数</p>
<p>float 偏移量必须为sizeof(float)即4的倍数</p>
<p>double 偏移量必须为sizeof(double)即8的倍数</p>
<p>Short 偏移量必须为sizeof(short)即2的倍数</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计流程(57)]]></title>
      <url>https://xuecat.github.io/2014/09/20/57/</url>
      <content type="html"><![CDATA[<p> 想出的设计流程：</p>
<p> 先画出程序运行功能的基本流程-&gt;确定类的个数和作用-&gt;设计模式-&gt;按照先想好的类功能模块把设计模式搭建出来-&gt;最后按照功能流程图再写一遍。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[回调函数(60)]]></title>
      <url>https://xuecat.github.io/2014/09/20/60/</url>
      <content type="html"><![CDATA[<p>回调函数类型：</p>
<pre><code>void PrintfText(char* s) 
{
    printf(s);
}
</code></pre><p>//定义实现带参回调函数的”调用函数”</p>
<p>这里注意第一个void代表回调的数返回值，第二个char*代表的回调的函数的参数，就像写下它的参数一样。</p>
<pre><code>void CallPrintfText(void (*callfuct)(char*),char* s)
{
    callfuct(s);
}
</code></pre><p>//在main函数中实现带参的函数回调</p>
<pre><code>int main(int argc,char* argv[])
{
    CallPrintfText(PrintfText,&quot;Hello World!\n&quot;);
    return 0;
}
</code></pre><p>只是个函数指针，没什么好理解的。c++的RTTI技术用的更多</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[++和++ 入栈顺序(65)]]></title>
      <url>https://xuecat.github.io/2014/09/20/65/</url>
      <content type="html"><![CDATA[<figure class="highlight c"><figcaption><span>直接上代码++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minuus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> a-b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> cc = <span class="number">4</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; minuus(cc++, cc++) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">while</span> (cc--)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>vc6编译环境：</p>
<p>minuus（cc, cc++）；while(–cc) 输出：4,4,0 aaaa</p>
<p>minuus（++cc, ++cc）；while(–cc) 输出：6,5,0 aaaaa</p>
<p>minuus（cc++, ++cc）；while(–cc) 输出：5,5,0 aaaaa</p>
<p><strong>分析：首先vc6对参数入栈默认是从右到左的，然后入栈参数必定存在赋值临时参数(意思就是先拷贝了数据值再进行操作，不然第一个示例中：cc++确实执行了，却没有传入值)。</strong></p>
<p>vs2012编译环境：</p>
<p>minuus（cc, cc++）；while(–cc) 输出：5 4 1 5(和想象中的一样)</p>
<p>minuus（++cc, ++cc）；while(–cc) 输出：6 6 0 6(不同了)</p>
<p>minuus（cc++, ++cc）；while(–cc) 输出：5 6 -1 6(不同了)</p>
<p>minuus（cc++, cc++）；while(–cc) 输出：5 4 1 6(不同)</p>
<p>minuus(cc, ++cc) :5 5 0 5</p>
<p>minuus(++cc, cc++) 6 4 2 6</p>
<p>minuus(++cc, cc) 5 5 0 5</p>
<p><strong>分析：首先它会对++c进行预先处理， 所以cc会自加，玩了后它才开始参数从右到左进行入栈处理。<br>有cc++就处理。</strong></p>
<p>相比vc6对数据的自加进行了修改，但是对++c的处理并不是很好。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[杂项]]></title>
      <url>https://xuecat.github.io/2014/09/20/61/</url>
      <content type="html"><![CDATA[<p>   变长参数的纠正，绑定第一参数时，直接赋值貌似不成功。要绑定临近的参数才成功。(好像它是临近取值的)</p>
<p><strong>我擦，居然用错绘图dc。onpaintdc和cclientdc，前者只能在onpaint函数用才有效，如果传入或者其他函数调用是无效的。后者随意用。</strong></p>
<p>  <strong> 发现当设计后，封装的类有三个完成时必须要调试跑一边，不然后期有些许不合理的地方不能及时修改。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[强制转换临时和原对象(虚函数测试)(59)]]></title>
      <url>https://xuecat.github.io/2014/09/20/59/</url>
      <content type="html"><![CDATA[<p>这是个很坑的地方,大多数想法,转换嘛,</p>
<pre><code>我把static_cast&lt;A&gt;(B)不就是把B转成A吗? 错! :
static_cast&lt;window*&gt;(this)-&gt;onResize(); //这是拿this当成window,没问题
static_cast&lt;window&amp;&gt;(*this).onResize();//这个也是

static_cast&lt;window&gt;(*this).onResize();
这个相当于:
window temp=(*this);
temp.onResize();
</code></pre><p>我做了一下测试，你的临时对象的说法应该是对的，</p>
<pre><code>static_cast&lt;window&gt;(*this).onresize();  确实无法执行到 对象的 base class 部分 

static_cast&lt;window*&gt;(this)-&gt;onResize(); //这是拿this当成window,没问题
static_cast&lt;window&amp;&gt;(*this).onResize();//这个也是
</code></pre><p>这两种可以执行到base class 部分，但是因为例子中是 virtual function，所以base class 部分的 vtable pointer 跟 derived class 的 vtable pointer 指向同一个virtual table，里面的 函数是一个，所以会递归调用</p>
<p>而 如果用 window::onResize()，就应该是直接调用的base class  里面的 virtual function 。<br>应该是这样的</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[指针内存长度和大小(64)]]></title>
      <url>https://xuecat.github.io/2014/09/20/64/</url>
      <content type="html"><![CDATA[<p> 今天字符处理遇见这个问题：我new了一块内存，然后sizeof()；strlen()；都正常（一个返回4，一个返回分配大小）</p>
<p>之后我用了ZeroMemory来分配，发现有异议了。<br>sizeof(); strlen(); 一个返回4，一个返回0；     原来用了这个函数会置空内存。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[string和wstring(62)]]></title>
      <url>https://xuecat.github.io/2014/09/20/62/</url>
      <content type="html"><![CDATA[<p>今天用string来find一个中文符号，首先返回符号位置正确。然后符号为界，截取字符串出现问题；</p>
<p>分析原因：中文符号在string中是占用两个字节的。而string对所有的字符串是一个字符一个字节的</p>
<p>，所以按位取时，夺取了一个字节，导致数据获取失败。</p>
<p>用wstring进行存取，可以完全避免。</p>
<p><strong>学到：或许第三方库和一些协议对unicode字符集支持不是很好，导致数据传输要使用ANSI字符串。<br>但程序之间的通信为了保证中文字符，必须使用unicode。     最多在数据传输时做一次编码转换！</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[变长参数(58)]]></title>
      <url>https://xuecat.github.io/2014/09/20/58/</url>
      <content type="html"><![CDATA[<p>可变长函数：</p>
<p>  函数多参数情况下，可变长函数虽然设置“…”   //一定要“…”之前的那个参数 va_start，来避免异常抛出。（实践）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[duilib 动态tab(53)]]></title>
      <url>https://xuecat.github.io/2014/09/19/53/</url>
      <content type="html"><![CDATA[<p>尼玛的，差点哭了。弄了这么久，调试都没法。</p>
<p>原来是动态链接库没有替换上。我去！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[duilib错误(52)]]></title>
      <url>https://xuecat.github.io/2014/09/18/52/</url>
      <content type="html"><![CDATA[<p>group属性，会让关联控件只能成为一个。比如只能让其中一个option选中状态</p>
<p>remove今天死活识别不了，添加#include <algorithm>后可以使用。</algorithm></p>
<p>我去！死活弄了好久，结果路径问题！</p>
<pre><code>#include &quot;..\\StdAfx.h&quot;
#include &quot;..\\Control\UIAnimation.h&quot;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[勿忘初心(51)]]></title>
      <url>https://xuecat.github.io/2014/09/17/51/</url>
      <content type="html"><![CDATA[<p>  不忘初心，方得始终</p>
<p>  这几天自己也有点想多了，因为本来就进入大三了，该考虑的也多了起来。<br>反而烦恼了自己。</p>
<p>  写下日记，提醒自己，大三上的时间还是很充足的，不要被迷惑。做好自己！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[模板和虚函数(50)]]></title>
      <url>https://xuecat.github.io/2014/09/17/50/</url>
      <content type="html"><![CDATA[<p><strong>模板编程不允许虚函数的出现。为了使用基类函数，我们只能用转交函数</strong><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> SquareMatrixBase &#123;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> matrixsize)</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> n&gt;</div><div class="line"><span class="keyword">class</span> SquareMatrix : <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123;<span class="keyword">this</span>-&gt;invert(n);&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[non-virtual和virtual函数(49)]]></title>
      <url>https://xuecat.github.io/2014/09/15/49/</url>
      <content type="html"><![CDATA[<p><strong>首先，普通函数的派生会出现遮掩情况：</strong></p>
<pre><code>如；基类有多个重载函数（fun）。派生类只要定义一个（fun）；
所有的基类函数（fun（int）、fun（double）等）不能使用。
当然可以通过using::Base::fun()来解决。
（编译器智能使用父子关系类的fun函数）
</code></pre><p><strong>遮掩不仅会阻止派生类内部访问基类，还有种情况：</strong></p>
<pre><code>class B {public: void mf();}
class D : Public B {public: void mf();}

D x;
B* pb = &amp;x;
D* pd = &amp;x;
pb-&gt;mf();//调用B的mf函数
pd-&gt;mf();//调用D的mf函数
//得出，它只看定义类型调用。那一定是编译期间的覆盖。
</code></pre><p><strong>另外还有种情况会出现遮掩：</strong></p>
<pre><code>class B {virtual void f() const;}
class A : public B {virtual void f();}
//只是少了个const也会出现遮掩
</code></pre><p><strong>写个基类调用函数：        ps1-&gt;Shape::draw();</strong></p>
<p><strong>写一个转交函数：</strong></p>
<pre><code>class GameCharacter {
    public:
        int healthValue() const {
            ....
            int rectval = doHealthValue();
            return retVal;
        }
    private:
        virtual int doHealthValue() const {..}
    //转交虚函数的调用。
} 
</code></pre><p><strong>讲下虚函数的参数：缺省参数</strong></p>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">class</span> B &#123;<span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf</span><span class="params">(<span class="keyword">int</span> a = <span class="number">2</span>)</span></span>;&#125;</div><div class="line">	<span class="keyword">class</span> D : Public B &#123;<span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf</span><span class="params">(<span class="keyword">int</span> a = <span class="number">3</span>)</span></span>;&#125;</div><div class="line">	</div><div class="line">	B* pb = <span class="keyword">new</span> B;</div><div class="line">	D* pd = <span class="keyword">new</span> D;</div><div class="line">	pb-&gt;mf();<span class="comment">//调用B的mf函数</span></div><div class="line">	pd-&gt;mf();<span class="comment">//调用D的mf函数</span></div><div class="line">	<span class="comment">//但是，缺省参数时静态编译的，当出现下面情况的时候。</span></div><div class="line">	pb = pd;</div><div class="line">	pb-&gt;mf()<span class="comment">//调用的却是B的mf函数.</span></div><div class="line"></div><div class="line">解决方案：</div><div class="line"></div><div class="line">	取消默认赋值，为派生写转交函数来达到相同的效果。</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> a = <span class="number">3</span>)</span> <span class="keyword">const</span> </span>&#123;doDraw(a)&#125;<span class="comment">//调用虚函数</span></div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span> </span>&#123;&#125;<span class="comment">//构建虚函数</span></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[大三的开学(48)]]></title>
      <url>https://xuecat.github.io/2014/09/14/48/</url>
      <content type="html"><![CDATA[<p>不知不觉我也大三了，这几天我又没有天天去试验室。现在感觉一天不去实验室就有点罪恶感了！<br>然后就愈来愈不敢去。</p>
<p>我还有梦想没实现，我还这么弱小，我这样的颓废生活真心烦死了！<br>现在的交际圈也越来越小了，连已有的我都不知道能不能把握到！</p>
<p>写下日记，告诉自己还没有实现的东西，大学别留遗憾！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[降低文件依赖，减少编译时间(47)]]></title>
      <url>https://xuecat.github.io/2014/09/12/47/</url>
      <content type="html"><![CDATA[<p>首先是第二次做这种题了。大概分析下吧：</p>
<pre><code>1、无前置声明，直接包含头文件调用。（当包含的头文件出现变化时，编译器就必须重新对包含文件重新编译）

2、我来说明下前置声明后的情况
    分析对象：
        前置的意义不大，编译器编译的时候首先对声明的对象分配大小内存，即使有了前置声明，
        它还是会访问一次头文件的定义，来分配大小。
        而且，对于类的方法调用始终是要通过类的定义来的。
        作者对于这种情况做了一个处理，我觉得。。。（把调用类分成提供类和实现类两个接口）
    分析指针：
        首先编译期间的内存分配就解决了。只要你不调用方法，就永远不会访问定义。
        大大节省了编译时间。

        同时，这也是头文件互相包含的解决方案。
</code></pre><p>所以建议。使用类指针，有前置声明习惯。类对象，看你自己办！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[pass by reference to const replace pass by value(45)]]></title>
      <url>https://xuecat.github.io/2014/09/11/45/</url>
      <content type="html"><![CDATA[<p>当用类去传递的时候遇见这么一个编译消耗。</p>
<pre><code>Class Person {std::string str1, std::string str2;};
Class Student : public Person {std::string str1, std::string str2;};

//函数 validateStudent(Student s);
//分析：Student一次构造，成员对象有两个构造；父类一个构造，父类成员对象两个构造
要调用6次构造函数.大大的加大负担.

//解决方案:
validateStudent(const Student&amp; s);一次不需要
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[返回对象(46)]]></title>
      <url>https://xuecat.github.io/2014/09/11/46/</url>
      <content type="html"><![CDATA[<p>作者对返回对象觉得：</p>
<pre><code>1、拒绝用new 指针来返回引用对象（栈空间返回就省略了）。销毁问题
2、拒绝用静态，全局空间来返回。多次调用问题。

作者觉得该返回一个新的对象，调用构造函数。（具体情况而定，当是上一个栈空间的时候，返回也是很好的）
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[effective c++数组指针销毁(43)]]></title>
      <url>https://xuecat.github.io/2014/09/10/43/</url>
      <content type="html"><![CDATA[<p>遇见：</p>
<pre><code>std::string* p = new std::string[100];
请用:     delete[] p;
用delete p；会出现内存错误。
所以对于数组指针，拒绝使用typedef（typdedef string ADD[4];） 避免销毁异常。
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[effectivec++ 设计接口正确使用(44)]]></title>
      <url>https://xuecat.github.io/2014/09/10/44/</url>
      <content type="html"><![CDATA[<figure class="highlight"><figcaption><span>看代码:++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Date &#123;</div><div class="line">public:</div><div class="line">	Date(int moth, int day, int year);</div><div class="line">&#125;</div><div class="line">//存在的问题，由于都是int，调用会出现顺序错误。</div><div class="line">修改</div><div class="line">struct Day &#123;explicit Day(int d):val(d)&#123;&#125; int val;&#125;;</div><div class="line">struct Month &#123;explicit Month(int d):val(d)&#123;&#125; int val;&#125;;</div><div class="line">struct Year &#123;explicit Year(int d):val(d)&#123;&#125; int val;&#125;;</div><div class="line"></div><div class="line">class Date &#123;</div><div class="line">public:</div><div class="line">	Date(const Month&amp; m, const Day&amp; d, const Year&amp; y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[取非符和内存对齐进阶(42)]]></title>
      <url>https://xuecat.github.io/2014/09/09/42/</url>
      <content type="html"><![CDATA[<p>先看取非符：</p>
<pre><code>a=0=(00000000);  ~a=(11111111)=-1
a=1=(00000001);  ~a=(11111110)=-2
a=2=(00000010);  ~a=(11111101)=-3
而计算机里是用补码来存储的，因此111...11101是补码，对应的有符号数是-3
运算也是补码。a&amp;~a = 0
</code></pre><p>再看内存对齐：</p>
<pre><code>首先只会当下一阶内存大于本阶内存时，才会修改偏移量来对齐。对齐的倍数是4、8
:int a;          //4字节
short int b;  //2字节
char c;       //1字节
(1字节padding, 因为d要从整4字节开始，所以要插入1字节)
float d;       //4字节
(4字节padding, 因为e要从整8字节开始，所以要插入4字节)
double e;   //8字节
long double f; //12字节
(4字节padding, 因为整个结构的长度要能被8整除，这个8是按结构中最长对齐的字段e决定的
，所以要加4字节补齐) 
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[more effective c++非尾端类设计抽象类(41)]]></title>
      <url>https://xuecat.github.io/2014/09/06/41/</url>
      <content type="html"><![CDATA[<figure class="highlight c"><figcaption><span>先看代码：++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">class</span> Animal &#123;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		<span class="keyword">int</span> a;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		Animal&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs) &#123;</div><div class="line">			<span class="keyword">this</span>-&gt;a = rhs.a;</div><div class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">class</span> Lizard : <span class="keyword">public</span> Animal &#123;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		<span class="keyword">int</span> d;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		Lizard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Lizard&amp; rhs) &#123;</div><div class="line">			<span class="keyword">this</span>-&gt;d = rhs.d;</div><div class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">class</span> Chicken : <span class="keyword">public</span> Animal &#123;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		<span class="built_in">string</span> str;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		Chicken&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Chicken&amp; rhs) &#123;</div><div class="line">			<span class="keyword">this</span>-&gt;str = rhs.str;</div><div class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	Lizard liz1;</div><div class="line">	Lizard liz2;</div><div class="line">	Animal* panimal1 = &amp;liz1;</div><div class="line">	Animal* panimal2 = &amp;liz2;</div><div class="line"></div><div class="line">	*panimal1 = *panimal2;</div><div class="line"></div><div class="line"><span class="comment">//问题1：执行最后一个函数时，必定会执行Animal的赋值函数。 导致情况：liz1的Animal部分被修改，</span></div><div class="line">liz1的Animal内容变得和liz2的Animal内容一样。</div><div class="line"></div><div class="line"><span class="comment">//采取行动：虚化赋值函数(注意：成员函数是基类)</span></div><div class="line"></div><div class="line">	<span class="keyword">virtual</span> Animal&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);</div><div class="line">	<span class="keyword">virtual</span> Lizard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);</div><div class="line">	<span class="keyword">virtual</span> Chicken&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);</div><div class="line"></div><div class="line"><span class="comment">//问题：虽然它现在会动态改变赋值对象函数了，但存在”异型赋值“（类没有的成员进行赋值）</span></div><div class="line"></div><div class="line"><span class="comment">//采取行动：重载函数，动态强制转换</span></div><div class="line"></div><div class="line">	例如Lizard：</div><div class="line">		Lizard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);<span class="comment">//用来转换本地的</span></div><div class="line">		<span class="keyword">virtual</span> Lizard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Animal&amp; rhs);<span class="comment">//用来转换继承关系的</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">operator</span>=(<span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Lizard&amp;&gt;(rhs));</div><div class="line">			<span class="comment">//当被转换的类型不是Lizard的时候，就会抛出异常错误。</span></div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>后面的纯虚化基类，我看不太懂；</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[static_cast dynamic_cast再进一步]]></title>
      <url>https://xuecat.github.io/2014/09/05/39/</url>
      <content type="html"><![CDATA[<p>string a = typeid(dynamic_cast<novebook*>(this)).name();</novebook*></p>
<p>发现dynamic_cast确实能把父子类的类型做转换，但是<br>对于虚函数，还是无法，应该是内存覆盖了就无法修改了。</p>
<p>只有<br>int selfprice = static_cast<novebook>(*this).GetPrice();<br>才能转换成临时变量，调用基类虚函数。</novebook></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[more effective c++根据类型决定虚化(40)]]></title>
      <url>https://xuecat.github.io/2014/09/05/40/</url>
      <content type="html"><![CDATA[<p>第31条了，这一跳一下就解决了我最近的疑惑！</p>
<p>先看游戏规则:</p>
<p>1、有的类型，宇宙飞船、太空站、小行星、</p>
<p>2、他们互相碰撞，任意两两进行碰撞。</p>
<p>3、具有主被动性！且不同的主被动，不同的类型进行碰撞，产生的结果也不一样。</p>
<p>分析，需要运行时动态识别，所包含的对象，所以设计c++RTTI计数。（过程代码不列出了，直接走封装）</p>
<figure class="highlight c"><figcaption><span>看代码：++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">class</span> GameObject;</div><div class="line"><span class="keyword">class</span> SpaceShip : <span class="keyword">public</span> GameObject &#123;&#125;;</div><div class="line"><span class="keyword">class</span> SpaceStation : <span class="keyword">public</span> GameObject &#123;&#125;;</div><div class="line"><span class="keyword">class</span> Asteroid : <span class="keyword">public</span> GameObject &#123;&#125;;</div><div class="line"><span class="keyword">class</span> GameObject</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherobject)</span> </span>= <span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitSpaceShip</span><span class="params">(GameObject&amp; otherobject)</span> </span>= <span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitSpaceStation</span><span class="params">(GameObject&amp; otherobject)</span> </span>= <span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitAsteroid</span><span class="params">(GameObject&amp; otherobject)</span> </span>= <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> SpaceShip : <span class="keyword">public</span> GameObject &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(SpaceShip::*HitFunctionPtr)</span><span class="params">(GameObject&amp;)</span></span>;</div><div class="line">	<span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, HitFunctionPtr&gt; HitMap;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">static</span> HitFunctionPtr <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> GameObject&amp; whats)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">static</span> HitMap <span class="title">initializeCollisionMap</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject&amp; otherobject)</span> </span>&#123;</div><div class="line">		HitFunctionPtr hfp = lookup(otherobject);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (hfp) &#123;</div><div class="line">			(<span class="keyword">this</span>-&gt;*hfp)(otherobject);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="comment">/*抛出错误*/</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitSpaceShip</span><span class="params">(GameObject&amp; otherobject)</span> </span>&#123;</div><div class="line">		SpaceShip&amp; other = <span class="keyword">dynamic_cast</span>&lt;SpaceShip&amp;&gt;(otherobject);</div><div class="line">		<span class="comment">//处理撞击</span></div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitSpaceStation</span><span class="params">(GameObject&amp; otherobject)</span> </span>&#123;</div><div class="line">		SpaceStation&amp; other = <span class="keyword">dynamic_cast</span>&lt;SpaceStation&amp;&gt;(otherobject);</div><div class="line">		<span class="comment">//处理撞击</span></div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitAsteroid</span><span class="params">(GameObject&amp; otherobject)</span> </span>&#123;</div><div class="line">		Asteroid&amp; other = <span class="keyword">dynamic_cast</span>&lt;Asteroid&amp;&gt;(otherobject);</div><div class="line">		<span class="comment">//处理撞击</span></div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">SpaceShip::HitMap</div><div class="line">	SpaceShip::initializeCollisionMap() &#123;</div><div class="line">		HitMap* phm = <span class="keyword">new</span> HitMap;</div><div class="line">		(*phm)[<span class="string">"SpaceShip"</span>] = &amp;hitSpaceShip;</div><div class="line">		(*phm)[<span class="string">"SpaceStation"</span>] = &amp;hitSpaceStation;</div><div class="line">		(*phm)[<span class="string">"Asteroid"</span>] = &amp;hitAsteroid;</div><div class="line">&#125;</div><div class="line">SpaceShip::HitFunctionPtr</div><div class="line">	SpaceShip::lookup(<span class="keyword">const</span> GameObject&amp; whats) &#123;</div><div class="line">		<span class="keyword">static</span> HitMap collisionMap = initializeCollisionMap();</div><div class="line">		HitMap::iterator it = </div><div class="line">			collisionMap.find(<span class="keyword">typeid</span>(whats).name());</div><div class="line">		<span class="keyword">if</span> (it == collisionMap.end()) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> (*it).second;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//其它类的封装都基本一样，只需要处理撞击函数</span></div><div class="line"><span class="comment">//便可以了，下面是场景类，进行调用</span></div><div class="line"><span class="keyword">class</span> Client &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftcollide</span><span class="params">(GameObject&amp; ot, GameObject&amp; or)</span> </span>&#123;</div><div class="line">		ot.collide(or);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rightcollide</span><span class="params">(GameObject&amp; ot, GameObject&amp; or)</span> </span>&#123;</div><div class="line">		leftcollide(or, ot);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>作者对函数指针的使用，对c++的rtti技术体现的</p>
<p>最后要提下的是，作者在后面添加了一个注册函数指针的接口。我感觉他写的并不是很好。</p>
<p>如果是我的话，我重写一个类让他继承这些类，重写initializeCollisionMap函数不就好了吗？</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[非成员函数(38)]]></title>
      <url>https://xuecat.github.io/2014/09/05/38/</url>
      <content type="html"><![CDATA[<p>more effective c++作者在封装全局函数时，对当前有效的所有全局函数都使用了“匿名空间”</p>
<p>函数的定义和声明都要在匿名空间才能被识别。</p>
<p>多个namespace，是没问题的，会在一个匿名空间。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[内存对齐(31)]]></title>
      <url>https://xuecat.github.io/2014/09/04/31/</url>
      <content type="html"><![CDATA[<p>无论是类还是结构体，对于数据对其都遵循按照最高字节数，进行对齐。</p>
<p>注意一点就是，当无数据时候是占一个字节，只有一个char时，也只占一个字节</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[more effective c++为智能指针添加计数(36)]]></title>
      <url>https://xuecat.github.io/2014/09/03/36/</url>
      <content type="html"><![CDATA[<p>作者使用结构体完成这一功能。为使用字符串添加引用计数。</p>
<figure class="highlight c"><figcaption><span>看代码：++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Stringg &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line"><span class="comment">//作者声明了一个结构体，来完成操作</span></div><div class="line"> 		 <span class="keyword">struct</span>  StringValue &#123;</div><div class="line">        	<span class="keyword">int</span> refCount;</div><div class="line">        	<span class="keyword">char</span>* data;</div><div class="line"></div><div class="line">        StringValue(<span class="keyword">const</span> <span class="keyword">char</span> * initValue);</div><div class="line">        ~StringValue();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">String::StringValue::StringValue(<span class="keyword">const</span> <span class="keyword">char</span>* initValue)</div><div class="line">: refCont(<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">      data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</div><div class="line">      <span class="built_in">strcpy</span>(data, initValue);</div><div class="line">&#125;</div><div class="line"></div><div class="line">String::StringVlue::~StrinValue()</div><div class="line">&#123;</div><div class="line">     <span class="keyword">delete</span> []data;</div><div class="line">&#125;</div><div class="line"></div><div class="line">String::String(<span class="keyword">const</span> <span class="keyword">char</span>* initValue)</div><div class="line"> 	: value(<span class="keyword">new</span> StringValue(initValue))</div><div class="line">&#123;\\它这里就创建对数据的跟踪&#125;</div><div class="line"></div><div class="line"><span class="comment">//对于赋值和复制函数，就先判断是否自己，</span></div><div class="line"><span class="comment">//是否--value-&gt;refCount==0;delete.++refcount.</span></div><div class="line"></div><div class="line">Stringg::~Stringg()</div><div class="line">&#123;<span class="keyword">if</span>(--value-&gt;refCount == <span class="number">0</span> ) <span class="keyword">delete</span> value;&#125;</div></pre></td></tr></table></figure>
<p>最后：混蛋作者，最后还是封装了一个智能基类。<br>详细见199  </p>
<p>分析：String需要StringValue模块来专门服务，相应功能String不管，只是知道初始化时构造它就好。然后String需要StringValue的一些结果，所以设计智能指针模块来访问数据，当然也可以修改数据。</p>
<p>如此关系，可以记录下。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[指针函数与函数指针(33)]]></title>
      <url>https://xuecat.github.io/2014/09/03/33/</url>
      <content type="html"><![CDATA[<figure class="highlight c"><figcaption><span>先看一段代码：++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*outhead)</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is A"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">return</span> d;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span>* <span class="title">cou</span><span class="params">(<span class="keyword">int</span>* a, outhead d)</span> </span>&#123;</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; d(*a);</div><div class="line">		<span class="keyword">return</span> a;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">int</span> aa = <span class="number">2</span>;</div><div class="line">		cou(&amp;aa, a);</div><div class="line">		system(<span class="string">"pause"</span>);</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"><span class="comment">//输出 2\n this is a\n 2\n</span></div></pre></td></tr></table></figure>
<p>分析：<br>先定义outthead函数指针为int的别名。 (只对静态和全局有效）)<br>我可以规定一种类型封装很多个全局函数，用一个指针函数，参数是函数指针，然后调用就好了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[函数指针获取成员函数地址（包括虚函数）]]></title>
      <url>https://xuecat.github.io/2014/09/03/32/</url>
      <content type="html"><![CDATA[<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Base</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"Enter Base::func()\n"</span>); &#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virtual_func</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"Enter Base::virtual_func()\n"</span>); &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> Base</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"Enter Derived::func()\n"</span>); &#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virtual_func</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"Enter Derived::virtual_func()\n"</span>); &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(Base::*p_base_func)</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span></div><div class="line">&#123; </div><div class="line">	Derived d;</div><div class="line">	Base b;</div><div class="line">	Base *pb = &amp;d;</div><div class="line"></div><div class="line">	p_base_func pbf = &amp;Base::func;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"-- Call via pointer to normal function of base\n"</span>);</div><div class="line">	(pb-&gt;*pbf)();</div><div class="line">	(d.*pbf)();</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="comment">//cout &lt;&lt; (pb-&gt;*pbf) &lt;&lt; endl;</span></div><div class="line"></div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	pbf = &amp;Base::virtual_func;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"-- Call via pointer to virtual function of base\n"</span>);</div><div class="line">	(pb-&gt;*pbf)();</div><div class="line">	(d.*pbf)();</div><div class="line">	<span class="comment">//cout &lt;&lt; (pb-&gt;*pbf) &lt;&lt; endl;</span></div><div class="line"></div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 注释部分会发生编译器内部错误。我也不知道为什么？</p>
<p>看代码，为成员函数添加一个引用（支持虚函数）。<br>然后利用对象调用函数。<br>貌似，只能利用对象才能成功。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常量区进阶(34)]]></title>
      <url>https://xuecat.github.io/2014/09/02/34/</url>
      <content type="html"><![CDATA[<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strA</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">   	<span class="keyword">char</span> str[]=<span class="string">"hello world"</span>;</div><div class="line">   	<span class="keyword">return</span> str;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strA</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">   	<span class="keyword">char</span> *str=<span class="string">"hello world"</span>;</div><div class="line">   	<span class="keyword">return</span> str;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，指针只有四个字节，无法保持数据，所以定义后会在常量区开辟空间赋值。<br>所以return str返回的是常量区空间（在程序结束后才会被释放）</p>
<p>这也解释了第一个为什么返回乱码了。</p>
<figure class="highlight c"><figcaption><span>然后继续再来看这一句：++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span>* <span class="title">strr</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a = <span class="number">3</span>;</div><div class="line">	<span class="keyword">int</span> *d = &amp;a;</div><div class="line">	<span class="keyword">return</span> d;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span></div><div class="line">&#123; </div><div class="line">	<span class="keyword">int</span>* d =  strr();</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; *d &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">int</span>* q1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</div><div class="line">	<span class="keyword">int</span>* q2 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>);</div><div class="line">	<span class="keyword">int</span>* q3 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>);</div><div class="line">	<span class="keyword">int</span>* q4 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">4</span>);</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; *d;</div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[more effective c++智能指针继承传递(35)]]></title>
      <url>https://xuecat.github.io/2014/09/02/35/</url>
      <content type="html"><![CDATA[<figure class="highlight"><figcaption><span>先看示例：++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class MusicProduct;</div><div class="line">class Cassette : public MusicProduct;</div><div class="line">class CD : public MusicProduct;</div><div class="line"></div><div class="line">void DisplayAndPlay(const SmartPtr&lt;MusicProduct&gt;&amp; pmp, int times)</div><div class="line">SmartPtr&lt;Cassette&gt; f(new );</div><div class="line">SmartPtr&lt;CD&gt; fd(new );</div><div class="line">DisplayAndPlay(f, 10)</div><div class="line">DisplayAndPlay(fd, 10);</div><div class="line">这样是无法通过的，</div><div class="line">解决方法是使用智能隐式转换。为SmartPtr添加转换函数</div><div class="line"></div><div class="line">templatee&lt;class newType&gt;</div><div class="line">operator SmartPtr&lt;newType&gt;()</div><div class="line">&#123;</div><div class="line">   	  return SmartPtr&lt;newType&gt;(pointee);</div><div class="line">&#125;</div><div class="line"></div><div class="line">分析：编译器总是会企图找到一种方式使成功。</div><div class="line">所以函数赋值时，它就会解析为：</div><div class="line"></div><div class="line">SmartPtr&lt;Cassette&gt;::operator SmartPtr&lt;MusicProduct&gt; () &#123;</div><div class="line">   	    return Smart&lt;MusicProduct&gt;(pointee);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[libcurl源码学习(37)]]></title>
      <url>https://xuecat.github.io/2014/09/01/37/</url>
      <content type="html"><![CDATA[<p>libcurl：预编译头文件，就是放置工具的地方。<br>其它文件要使用工具直接#define一下就好了。</p>
<p>把va_list当值传入。</p>
<p>回调函数的使用typedf  获取函数指针。指针的指针，执行就好了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[More effective c++解引操作符及指针(30)]]></title>
      <url>https://xuecat.github.io/2014/09/01/30/</url>
      <content type="html"><![CDATA[<figure class="highlight c"><figcaption><span>智能指针解引操作符:++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Template&lt;Class T&gt;</div><div class="line">T&amp;SmartPtr&lt;T&gt;::<span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</div><div class="line"> 	……….</div><div class="line">	 Return * pointee;</div><div class="line">&#125;</div><div class="line">DBPtr&lt;Tuple&gt;&amp;pt;</div><div class="line">Pt-&gt;dispalyEditDialog();</div></pre></td></tr></table></figure> 
<p>注意编译器解释为：</p>
<pre><code>(pt.operator-&gt;())-&gt;displayEditDialog();
</code></pre><p>所以     operator-&gt;可能返回俩种东西，一个对象，一个智能指针，要注意分清。</p>
<p>指针判断</p>
<pre><code>If (ptn == 0)
If (ptn)
</code></pre><p>都是错误的，应该向类提供隐式转换才会被认同。</p>
<p>添加：operator void*();<br>但有缺陷，在指针比较时if (pa == po)可以通过</p>
<p>所以，目的只是为了检索指针是否为空，直接重载否定符，只使用为空部分：</p>
<pre><code>bool operator !() const{};
</code></pre><p>这样if (!ptn)就没问题了</p>
<p>对于自己的编码需求给智能指针添加隐式转换</p>
<pre><code>operator T*() {return pointee;}
</code></pre><p>但是智能指针的隐式转换有臭虫漏洞！<br>注意，详细看172.<br>最好去掉隐式转换。自己封装函数来获取。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[more effective c++智能指针(28)]]></title>
      <url>https://xuecat.github.io/2014/08/29/29/</url>
      <content type="html"><![CDATA[<figure class="highlight c"><figcaption><span>智能指针了：构造、赋值、析构:++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class</span> <span class="built_in">auto_ptr</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="built_in">auto_ptr</span>(T* ptr = <span class="number">0</span>) : pointee(ptr) &#123;&#125;</div><div class="line">	<span class="built_in">auto_ptr</span>(<span class="built_in">auto_ptr</span>&lt;T&gt;&amp; rhs); <span class="comment">//复制</span></div><div class="line">	<span class="built_in">auto_ptr</span>&lt;T&gt;&amp; operate= (<span class="built_in">auto_ptr</span>&lt;T&gt;&amp; rhs);</div><div class="line">	~<span class="built_in">auto_ptr</span>() &#123;<span class="keyword">delete</span> pointee;&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	T* pointee;</div><div class="line">	<span class="comment">/* data */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//可以看出，使用时用f</span></div><div class="line"><span class="comment">//auto_ptr&lt;TreeNode&gt; ptnq(new TreeNode);便可以了。</span></div><div class="line"><span class="comment">///</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="built_in">auto_ptr</span>&lt;T&gt;:::<span class="built_in">auto_ptr</span>(<span class="built_in">auto_ptr</span>&lt;T&gt;&amp; rhs)</div><div class="line">&#123;</div><div class="line">	pointee = rhs.pointee;</div><div class="line">	rhs.pointee = <span class="number">0</span>;<span class="comment">//因为实现的是auto，被复制后拒绝前一个变量访问</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="built_in">auto_ptr</span>&lt;T&gt;&amp; <span class="built_in">auto_ptr</span>&lt;T&gt;::operate= (<span class="built_in">auto_ptr</span>&lt;T&gt;&amp; rhs)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//这个赋值函数处理的很好，以后赋值函数添加上</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">delete</span> pointee;</div><div class="line">	。。。。</div><div class="line">	。。。。</div><div class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure> ]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mfc windows 程序设计（线程）]]></title>
      <url>https://xuecat.github.io/2014/08/29/28/</url>
      <content type="html"><![CDATA[<p>线程分：ui线程和工作线程</p>
<p>概念：</p>
<pre><code>  在Windows中，UI控件也被视为一个“Window”，它也拥有自己的“窗体过程”，因此，它也可以同窗体一样，具备处理消息的能力。

由此我们可以知道UI线程所完成的大致工作就是：

UI线程启动一个消息循环，每次从本线程所对应的消息队列中取出一条消息，然后根据消息所包容的信息，将其转发给特定的窗体对象，此窗体对象所对应的“窗体过程”函数被调用以处理这些消息。
</code></pre><p>用户操作消息是怎样“跑”到UI线程的消息队列中的？</p>
<pre><code> 操作系统会监控计算机上的键盘和鼠标等输入设备，为每一个输入事件（由用户操作所引发，比如用户按了某个键）生成一个消息。根据事件发生时的情况（比如当前激活的窗体负责接收用户按键，而依据用户点击鼠标的坐标可以知道用户在哪个窗体区域内点击了鼠标），操作系统会确定出此消息应该发给哪个窗体对象。

这些生成的消息会统一地先临时放置在一个“系统消息队列（system message queue）”中，然后，操作系统有一个专门的线程负责从这一队列中取出消息，根据消息的目标对象（就是窗体的句柄），将其移动到创建它的UI线程所对应的消息队列中。操作系统在创建进程和线程时，都同时记录了大量的控制信息（比如通过进程控制块和句柄表可以查找到进程所创建的所有线程和引用的核心对象），因此，根据窗体句柄来确定此消息应属于哪个UI线程对于操作系统来说是很简单的一件事。

注意，每个UI线程都有一个消息队列，而不是每个窗体一个消息队列！

那么，操作系统是不是会为每一个线程都创建一个消息队列呢？

答案是：只有当一个线程调用Win32 API中的GDI（Graphics Device Interface）和User函数时，操作系统才会将其看成是一个UI线程，并为它创建一个消息队列。

需要注意的是，消息循环是由UI线程的线程函数启动的，操作系统不管这件事，它只管为UI线程创建消息队列。因此，如果某个UI线程的线程函数中没有定义消息循环，那么，它所拥有的窗体是无法正确绘制的。
</code></pre><p>   mfc中创建ui线程只能通过CWinthread派生下来，动态创建。<br>终止线程：AfxEndThread PostQuitMessage 获取线程返回值： GetExitCodeThred</p>
<p>   一个线程结束后就会处于信号发送状态：WaitforSingleObject(pThread-&gt;m_hThread, INFINITE);直到线程返回</p>
<p>同步：</p>
<pre><code>临界区： 通过CCriticalSection 类的Lock() Unlock()同步，就中间添加执行代码，
目的是为了避免俩个或多个线程同时访问一个资源。     执行时最好用InterlockedIncrement
来确保线程安全。（可以设置等待时间）

互斥量：和临界区基本相同，区别在于，临界区用于同一个进程中的线程。互斥量用于，不同进程中
的线程对同一个资源的访问。 CMutex

事件：不说了，经常用。

信号量：不说了，经常用。
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多个对象访问多线程资源]]></title>
      <url>https://xuecat.github.io/2014/08/29/27/</url>
      <content type="html"><![CDATA[<p>   我初始化多个对象，对象类里面有多线程代码。</p>
<p>多线程设置信号量来限制访问线程个数。</p>
<p>发现：多个对象执行的时候，访问的却是同一个线程资源。</p>
<p>分析原因：多线程函数是static或者全局函数，   函数的创建在静态或全局空间，与类的栈空间无关<br>所以访问的是同一个函数。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[言156]]></title>
      <url>https://xuecat.github.io/2014/08/28/156/</url>
      <content type="html"><![CDATA[<p>祸、天、延、五、生、六、绝、辅、弼<br><br>上二为五下二天<br><br>中变绝命自古然<br><br>上一为生初变祸<br><br>上下六煞全变延<br></p>
<p>蓬、任、冲、辅、英、芮、柱、心、禽<br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[言102]]></title>
      <url>https://xuecat.github.io/2014/08/28/102/</url>
      <content type="html"><![CDATA[<p>  我讨厌温柔，温柔的人，温柔的心，以及清澈娇媚的问候；<br><br>  被擅自的靠近，被擅自的憧憬，被擅自的失望，被信任的人无可挽回的背叛了，再次回到漆黑的孤独之中，唯一增加的只有被腐蚀的心灵。<br><br>  总以为不再迷惑了，不再恐惧了，自己变强了，坚强到不会再伤害别人了，比起以前已经成长了，我一直这么坚信。但是好不容易积累起来的信心，也在那刻倾圮崩塌！！<br><br>  真相是残酷的，善良是谎言的，训练有素的孤零零只能在在这柔和的黑暗之中！！！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[more effective c++限制对象个数(27)]]></title>
      <url>https://xuecat.github.io/2014/08/28/26/</url>
      <content type="html"><![CDATA[<p>这部分记住的有这几条：</p>
<figure class="highlight c"><figcaption><span>先看理论：stack（栈）高地址往底地址， heap（堆）由低地址往高地址成长++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">onHeap</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* address)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> onTheStack;</div><div class="line">	<span class="keyword">return</span> address &lt; &amp;onTheStack;</div><div class="line">&#125;</div></pre></td></tr></table></figure> 
<p>onHeap函数内，onTheStack是个局部变量，所以它被置于stack内。当onHeap被调用，其stack frame 会被放在stack的顶端，由于此框架中stack系向低地址成长，所以onThestack的地址移动比其他任何一个stack变量更低。</p>
<p>所以address比onthestack更低，它就一定位于heap中。</p>
<p>此部分，作者为了让对象产生于heap中，向operate new添加东西标记。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mousehover（25）]]></title>
      <url>https://xuecat.github.io/2014/08/28/25/</url>
      <content type="html"><![CDATA[<p>今天为程序添加mousehover函数，发现不能响应，很气人。</p>
<p>要仔细去看下官方，翻看msdn：</p>
<p>   msdn它只会在图像重绘地方响应<br>Posted to a window when the cursor hovers over the client area of the window for the period of time specified in a prior call to TrackMouseEvent.</p>
<p>如果在onpaint函数使用cclientdc绘图的话，就会被判定非客户区。<br>所以，必须在onpaint里面用cpaintdc绘图，才会响应mousehover。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[more effective c++对象产生于head（23）]]></title>
      <url>https://xuecat.github.io/2014/08/26/23/</url>
      <content type="html"><![CDATA[<p>作者安排了一个基类和派生类的调用方式</p>
<p>1、基类先封装 destroy函数提供外部调用</p>
<pre><code>void destroy() const {delete this;}
</code></pre><p>2、基类析构函数他说要限制为protected，我不懂。<br>我想应该是让外部调用必须使用destroy来销毁对象吧！</p>
 <figure class="highlight c"><figcaption><span>来看下调用和派生++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> UPNumber </div><div class="line">	&#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line"> 	UPNumber(arguments);</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line"> 	~UPNumber();</div><div class="line"> </div><div class="line"> 	<span class="comment">/* data */</span></div><div class="line"> &#125;;</div><div class="line"></div><div class="line"> <span class="keyword">class</span> Asset</div><div class="line"> &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line"> 	Asset(arguments);</div><div class="line"> 	~Asset();</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line"> 	UPNumber* value;</div><div class="line"> </div><div class="line"> 	<span class="comment">/* data */</span></div><div class="line"> &#125;;</div><div class="line"></div><div class="line"> Asset::Asset(arguments)</div><div class="line"> 	: value(<span class="keyword">new</span> UPNumber(arguments)) &#123;</div><div class="line"> 		...</div><div class="line"> 	&#125;</div><div class="line"> Asset::~Asset()</div><div class="line"> &#123;</div><div class="line"> 	value-&gt;destroy();</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>派生类产生基类数据于头，设置基类数据对象来调用函数。<br>析构使用基类自释放性！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[窗口风格（22）]]></title>
      <url>https://xuecat.github.io/2014/08/26/22/</url>
      <content type="html"><![CDATA[<p>首先，对WS_EX_LAYERED  /WS_EX_TRANSPARENT(这个前面讲过)<br>对子窗口无效。</p>
<p>如不设置WS_CHILD就从屏幕坐标开始计算。<br>只要是子窗口就不能设置WS_POPUP</p>
<p>所以WS_POPUP窗口都具有CLIPDRENW属性（记得貌似还有vscroll似的）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[小诗]]></title>
      <url>https://xuecat.github.io/2014/08/26/20/</url>
      <content type="html"><![CDATA[<pre><code>天下风云出我辈，一入江湖岁月催。

    皇图霸业谈笑中，不胜人生一场醉。

    只叹尘世如潮，

    人生如水！

    何时归！

    提剑跨骑挥鬼蜮，白骨如山鸟惊飞。

    尘世如潮如水，

    只叹江湖几人回！

    夜雨八方战孤城，平明剑气看刀声。

    侠骨千年寻不见，碧血红叶醉秋风。


            ——已开始以为伟大的是感情，到最后发现强悍的是命运！
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[more effective c++计算限制对象个数(21)]]></title>
      <url>https://xuecat.github.io/2014/08/25/21/</url>
      <content type="html"><![CDATA[ <figure class="highlight c"><figcaption><span>封装的基类很好++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   	<span class="keyword">template</span>&lt;calss BeingCounted&gt;</div><div class="line"></div><div class="line">	<span class="keyword">class</span> Counted &#123;</div><div class="line">		<span class="keyword">public</span>:</div><div class="line">		<span class="keyword">class</span> TooManyObjects&#123;&#125;;</div><div class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">objectcount</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> numObjects;&#125;</div><div class="line">		protect:</div><div class="line">		Counted();</div><div class="line">		Counted(<span class="keyword">const</span> Counted&amp; rhs);</div><div class="line">		~Counted() &#123;--numObjects;&#125;</div><div class="line">		<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">static</span> <span class="keyword">int</span> numObjects;</div><div class="line">		<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> maxobjects;</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> BeingCounted&gt;</div><div class="line">	Counted&lt;BeingCounted&gt;::Counted()</div><div class="line">	&#123;init();&#125;</div><div class="line"></div><div class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> BeingCounted&gt;</div><div class="line">	Counted&lt;BeingCounted&gt;::Counted(<span class="keyword">const</span> Counted&lt;BeingCounted&gt;&amp;)</div><div class="line">	&#123;init();&#125;</div><div class="line"></div><div class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> BeingCounted&gt;</div><div class="line">	<span class="keyword">void</span> Counted&lt;BeingCOunted&gt;::init()</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (numObjects &gt;= maxObjects) <span class="keyword">throw</span> TooManyObjects();</div><div class="line">		++numobjects;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">派生类很好：</div><div class="line"></div><div class="line">	<span class="keyword">class</span> Printer: Private Counted&lt;Printer&gt; &#123;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">static</span> Printer* <span class="title">MakePrinter</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">static</span> Pritner* <span class="title">makePrinter</span><span class="params">(<span class="keyword">const</span> Printer&amp; rhs)</span></span>;</div><div class="line">	~Printer</div><div class="line">	..............</div><div class="line">	..........</div><div class="line"></div><div class="line">	<span class="keyword">using</span> Counted&lt;Printer&gt;::objectCount;</div><div class="line">	<span class="keyword">using</span> Counted&lt;Printer&gt;::TooManyObjects;</div><div class="line"></div><div class="line">	<span class="keyword">private</span>:</div><div class="line">	Printer();</div><div class="line">	Printer(<span class="keyword">const</span> Printer&amp; rhs);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>方法一： 它用基类的两个成员，用静态成员，来避免了无法继承问题。（因为就是是私有，静态变量也能继承，毕竟同一块内存区）</p>
<p>也为后来的TooManyOBjects()和objectCount()函数调用做铺垫。</p>
<p>方法二：在头文件const只能初始化int size_t等类型</p>
<p>方法三：昨天一样，生成对象函数和复制函数用static，并返回。</p>
<p>方法四：私有继承也是继承，只要是继承，派生类就会拥有基类所有对象，只存在访问权限而已。<br>private权限导致派生类无法直接访问。<br>但是，派生类构造/析构函数默认是加入了基类的构造/析构函数的。Printer的调用，必定会导致Counted的调用，init便存在间接访问权限。</p>
<p>所以Printer可以只管用，计数功能完全基类代替。</p>
<p>不得不感叹作者写的太好了！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[libcurl 百度图片api(19)]]></title>
      <url>https://xuecat.github.io/2014/08/25/19/</url>
      <content type="html"><![CDATA[<p>今天差点就放弃了，简直作弄人。<br>我使用http协议走去调用我发现的那个百度api。<br>图片获取不到，总是返回302（资源重定向），重定向的资源确实错误的页面，我也不知道为何！</p>
<p>气人，最后我被逼无路，从http底层找错误。用google浏览器发现我的http头貌似。。<br>于是我复制google浏览器的http头，重写http请求（添加http头重定义）</p>
<p>发现可行，下载正常！问题解决！</p>
<p>十分开心！</p>
<p>附上过程猜测：<br>      我在一次过程猜测中，以为是我的数据问题，以为它传给我的数据存在换行符解析错误。<br>linux换行符是：’\n’<br>mac：相同<br>windows:’\n\t’</p>
<p>百度不可能犯这错误吧！ 后来发现数据大小不够。唉！居然这么解决了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多线程手动销毁(18)]]></title>
      <url>https://xuecat.github.io/2014/08/23/18/</url>
      <content type="html"><![CDATA[<p>为了获取线程返回值，必须要手动销毁线程，销毁线程错误的做法：</p>
<p><img src="/picture/img/de.jpg" alt=""></p>
<p>应该如此销毁：</p>
<p><img src="/picture/img/ok.jpg" alt=""></p>
<p>另外，讲一下c++的new：</p>
<p>类的静态成员变量， 它不是你new 出来的，你不new 它就已经分配了内存。</p>
<p>所以，delete无法销毁静态空间。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[more effective c++限制对象个数(17)]]></title>
      <url>https://xuecat.github.io/2014/08/22/17/</url>
      <content type="html"><![CDATA[<p>方法一：仅允许一个对象<br>它先把类构造析构函数私化，<br>然后为类写个friend Printer&amp; thePrinter()–——友元函数不是类成员，直接static Printer p; return p;来打到限制的作用。</p>
<p>感悟：<strong>封装有计数功能的类，最好把类析构构造函数私有化，（这两个函数进行计数值得自加和自减，抛出异常）。  设计一个static的接口来new创建对象，当然希望用auto_ptr来创建。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CreateMenu与CreatePopupMenu]]></title>
      <url>https://xuecat.github.io/2014/08/06/14/</url>
      <content type="html"><![CDATA[<p>很多人都弄不清楚这CreateMenu与CreatePopupMenu的区别，继而发生很多莫名其妙的菜单行为。虽然极少数情况下，Windows能检测出来是你混淆了这两个函数，并且会在合适的时候把错误的函数调换过来，但我们不能总是指望Windows能够正确的判断出我们想要的操作，所以还是得弄清楚这两个函数到底有什么不同。</p>
<p>CreateMenu是创建水平菜单，通常是放置在顶级窗口中，同时也是作为顶级菜单的，就像我们经常看到的“文件”，“编辑”等菜单。而CreatePopupMenu则是创建一个竖立的弹出菜单，通常被用来做另一个菜单的子菜单，或者右键菜单的顶级菜单。<br>菜单资源总是以菜单栏的形式出现，然而，当你想从资源中加载一个弹出菜单时，就应该将弹出菜单放到一个空的水平菜单栏中。下面通过这个函数来说明如何在水平菜单中内嵌一个弹出菜单。</p>
<figure class="highlight c"><figcaption><span>代码测试++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">UsePopUpMenu</span><span class="params">(HWND hwnd, HINSTANCE hinst, LPCTSTR pszMenu)</span></span></div><div class="line">&#123;</div><div class="line">    HMENU hmenu = LoadMenu(hinst, pszMenu);</div><div class="line">    <span class="keyword">if</span>(hmenu)</div><div class="line">    &#123;</div><div class="line">        HMENU hpopMenu = GetSubMenu(hmenu, <span class="number">0</span>);</div><div class="line">        TrackPopupMenu(hpopMenu, TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON, GET_X_LPARAM(lparam), GET_Y_LPARAM(lparam), <span class="number">0</span>, hwnd, <span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DC内存(13)]]></title>
      <url>https://xuecat.github.io/2014/08/04/13/</url>
      <content type="html"><![CDATA[<p> getdc和releasedc必须配对使用。造成内存泄露。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[切桌面函数]]></title>
      <url>https://xuecat.github.io/2014/08/02/11/</url>
      <content type="html"><![CDATA[<p>IShellDispatch4::ToggleDesktop<br>切换桌面函数。<br>全部最小化当前进程。切回桌面</p>
<pre><code>#undef **
</code></pre><p>取消对应宏定义。</p>
<p>SystemParametersInfo获取修改系统信息</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CT2A-CA2T]]></title>
      <url>https://xuecat.github.io/2014/06/27/CT2A-CA2T/</url>
      <content type="html"><![CDATA[<p>注意：USES_CONVERSION宏开头</p>
<p>之前自己写了4个CHAR与TCHAR的编码函数，后来发现ms早就提供了类似的方法：CA2T CT2A……</p>
<p>但是有同事说，这两个函数不安全，有隐患，没有在意</p>
<p>但是真的用的时候，的确发现它们有些注意事项，简单来说，其实就是作用域的问题</p>
<p>Fun(CA2T(szSrc));</p>
<p>可以，Fun函数用转换后的TCHAR，没问题，因为没有出Fun()这个括号的作用域</p>
<p>tstring strDes = CA2T(szSrc)；</p>
<p>可以，因为返回值立刻赋给了strDes，strDes有自己的存储空间，CA2T的数据作用域就在这一行，出了就不要了</p>
<p>TCHAR* szDes = CA2T(szSrc);</p>
<p>失败，这个szDes指向一个已经释放的作用域的值，下一行在用szDes就危险了，没有分配</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[字符转数字]]></title>
      <url>https://xuecat.github.io/2014/06/26/zifuzhuanshuzi/</url>
      <content type="html"><![CDATA[<p>msdn中使用字符串转数字、数字转字符串：_strtoui64, _wcstoui64,<br> _strtoui64_l, _wcstoui64_l, _itoa, _i64toa, _ui64toa,<br>_itow, _i64tow, _ui64tow</p>
<p>msdn当中有这么一句：Base of value; which must be in the range2–36和<br>   Number base to use.</p>
<p>调试发现指的是进制。十进制、二进制等（最多2-36）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[if-change]]></title>
      <url>https://xuecat.github.io/2014/06/26/if-change/</url>
      <content type="html"><![CDATA[<p>今天在使用if语句时，发现可以如此简写：(以前的无法编码，气死)<br> int demo = 1;<br> bool/int foo() (函数必须要是bool或者整形，只要不是void就好);<br> if (demo) {foo();} else{foo();}     改写成-&gt;   demo &amp;&amp; foo();  demo || foo();</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[框架(15)]]></title>
      <url>https://xuecat.github.io/2014/06/25/15/</url>
      <content type="html"><![CDATA[<p>今天代码改写button了，感觉，对于框架的架构还是欠缺点。</p>
<p> 才一开始的封装，当一个模块出现四个功能时，我就该单独封装类，不然<br>后期肯定会添加封装的，到时代码冗余就不好看了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[消息自定义（24）]]></title>
      <url>https://xuecat.github.io/2014/06/25/24/</url>
      <content type="html"><![CDATA[<p>严格要求：</p>
<pre><code>afx_msg LRESULT DisplayResult(WPARAM wParam,LPARAM lParam);
ON_MESSAGE(WM_RESULT,CDemo4View::DisplayResult)
return 0;
</code></pre><p>SetWindowPos会强制产生重绘，容易闪图。</p>
<p>WM_ERASEBKGND以及WS_EX_TRANSPARENT虽然获取了父窗口dc，<br>来先绘制背景图，再绘制透明图实现的子窗口透明，<br>有闪图出现。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mfc rtti技术(12)]]></title>
      <url>https://xuecat.github.io/2014/06/25/12/</url>
      <content type="html"><![CDATA[<p>模态对话框，非模态对话框（domodal， new、create、destroywindow）</p>
<p>CRuntimeClass DECLEAR_DYNAMIC/IMPLEMENT_DYNAMIC<br>由于所有的类继承CObject类都包含此结构，用于保存基类对象类等信息。定义宏则是为其添加此类必要成员函数和成员变量。<br>（也就是说每新建一个类我们都可以加入MFC的继承表中，就是每个类声明中加入一个CRuntimeClass但是这个数据结构中有很多成员变量和函数。而且在实现文件中也要加入一些成员变量和函数的初始化或者成员函数的定义工作，每个类都要这么做会花很多行代码。还好微软给我们定义了几个宏让我们可以很方便的把我们定义的类加入到MFC继承的大绳中去。）</p>
<p>（其实说白了就是一个链表，每个类里加DECLARE_DYNAMIC后就生成一个CRuntimeClass的静态变量，保存了自己的类名和基类的静态CRuntimeClass指针。其它那些函数都是用这两个遍历查找。对应基类的名字，或对应名字的基类指针,在程序全局中也有一个CRuntimeClass链表，里面有所有加了运行类支持的类信息。）</p>
<p>mfc的RTTI技术（运行时类型识别）：<br>       <code>IsKindOf(RUNTIME_CLASS(CtestDlg));</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[more effective c++处理时事新闻，内容有文字，图形构成(16)]]></title>
      <url>https://xuecat.github.io/2014/06/25/16/</url>
      <content type="html"><![CDATA[<pre><code>class NLComponent{}
class TextBlock: public NLComponent{}
class Graphic: public NLComponent{}

class NewsLetter{
list&lt;NLComponent*&gt; components
}    
</code></pre><p>方法一：他用了一个static NLComponent* readComponent(istream&amp; str)，来读取数据，分别创建对象。因为每次传入数据时，调用函数然后就push_back了返回值保存指针入栈。</p>
<p>方法二：对上面list这个成员的拷贝，因为存放的是类对象。所以他自己写了个虚函数:<br>virtual NLComponent<em> clone() const =0;<br>virtual TextBlock</em> clone() const {return new TextBlock(*this);}   等等等<br>变向的调用了复制构造函数，来进行复制。<br>所以NewsLetter的复制构造函数就直接pushback它的clone函数。</p>
<p>感悟：<br><strong>派生类能用到的函数，最好基类虚化，分别封装虚函数。然后封装用一个函数去调用这各个不同的虚函数。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[生活认识]]></title>
      <url>https://xuecat.github.io/2014/06/12/firsttest/</url>
      <content type="html"><![CDATA[<h1 id="以前用pelican，后面markdown语法多了，现在换hexo先把日记放个测试来看看效果。"><a href="#以前用pelican，后面markdown语法多了，现在换hexo先把日记放个测试来看看效果。" class="headerlink" title="以前用pelican，后面markdown语法多了，现在换hexo先把日记放个测试来看看效果。"></a>以前用pelican，后面markdown语法多了，现在换hexo先把日记放个测试来看看效果。</h1><p><img src="/picture/q.jpg" alt=""></p>
<p> 最近是我的复习时间，我在寝室边复习边玩的状态，让我很是无奈！隔壁的小潘、老牟、他们并没有开始复习。现在， 我发现其实上课时，认真听下老师讲的，期末复习真的只要做几道题就好了；真蛋疼。室友，蔡衫连续的学习精神已经让我十分佩服了。我为何无法成为那样的好学生；会想平时上课，基本喜欢玩手机。就算带了书去，也没有怎么看。大二饿了，我感觉自己慢慢有点堕落了！现在我有接近三周没去实验室了。汪自衡的代码我还并没有写完！<br>     我自己也很是困惑。每天每咋干就好疲惫！我想，我该去实验室了。。。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>https://xuecat.github.io/2013/11/26/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to My Blog!!!</p>
]]></content>
    </entry>
    
  
  
</search>
